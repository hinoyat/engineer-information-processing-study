## 🔹 255. Secure SDLC

#### 📘 정의
Secure SDLC(Secure Software Development Life Cycle)는 **소프트웨어 개발 생명주기의 모든 단계에서 보안을 고려하여 안전한 소프트웨어를 개발하는 방법론**이다.  
기존 SDLC에 보안 요소를 통합하여 **설계 단계부터 보안 취약점을 예방**하는 것을 목적으로 한다.

#### 🧩 핵심 단계별 보안 활동

| 단계 | 보안 활동 |
|------|-----------|
| **요구사항 분석** | 보안 요구사항 정의, 위협 분석 |
| **설계** | 보안 아키텍처 설계, 위협 모델링 |
| **구현** | 시큐어 코딩, 보안 가이드라인 준수 |
| **테스트** | 보안 테스트, 취약점 진단 |
| **배포** | 보안 설정, 접근 제어 구성 |
| **유지보수** | 보안 패치, 지속적 모니터링 |

#### 🧩 주요 특징
- **예방 중심**: 개발 초기부터 보안 고려
- **비용 효율성**: 사후 보안 패치보다 개발 단계 보안이 비용 절약
- **지속적 보안**: 전 생명주기에 걸친 보안 관리

#### 📝 기출 포맷 예시
- Secure SDLC의 목적으로 옳은 것은?
- 다음 중 설계 단계의 보안 활동은?
- 기존 SDLC와 Secure SDLC의 차이점은?

#### 🧠 용어 설명
- **Secure SDLC**: 보안이 통합된 소프트웨어 개발 생명주기
- **위협 모델링**: 시스템의 보안 위협을 체계적으로 분석하는 기법
- **시큐어 코딩**: 보안 취약점을 방지하는 안전한 프로그래밍 기법

---

## 🔹 256. 소프트웨어 개발 보안 요소

#### 📘 정의
소프트웨어 개발 보안 요소는 **안전한 소프트웨어를 개발하기 위해 반드시 고려해야 할 핵심 보안 특성들**을 의미한다.  
정보보안의 3대 요소(기밀성, 무결성, 가용성)를 기반으로 **인증, 인가, 감사추적** 등의 요소가 추가된다.

#### 🧩 핵심 보안 요소

| 보안 요소 | 영어명 | 설명 |
|-----------|--------|------|
| **기밀성** | Confidentiality | 인가된 사용자만 정보에 접근할 수 있도록 보장 |
| **무결성** | Integrity | 정보가 무단으로 수정되지 않음을 보장 |
| **가용성** | Availability | 필요할 때 언제든지 시스템에 접근할 수 있음을 보장 |
| **인증** | Authentication | 사용자나 시스템의 신원을 확인하는 과정 |
| **인가** | Authorization | 인증된 사용자에게 적절한 권한을 부여하는 과정 |
| **부인방지** | Non-repudiation | 수행한 행위를 나중에 부인할 수 없도록 보장 |
| **감사추적** | Auditing | 시스템 내 모든 활동을 기록하고 추적 |

#### 🧩 CIA 삼각형 (정보보안 3대 요소)
```
       기밀성
      /      \
   무결성 ---- 가용성
```

#### 📝 기출 포맷 예시
- 정보보안의 3대 요소는?
- 다음 중 부인방지에 해당하는 것은?
- 인증과 인가의 차이점을 설명하시오.

#### 🧠 용어 설명
- **CIA**: 기밀성(Confidentiality), 무결성(Integrity), 가용성(Availability)
- **Authentication**: 신원 확인 과정 ("너는 누구인가?")
- **Authorization**: 권한 부여 과정 ("너는 무엇을 할 수 있는가?")
- **Non-repudiation**: 행위에 대한 책임을 부인할 수 없도록 하는 특성

---

## 🔹 257. 시큐어 코딩

#### 📘 정의
시큐어 코딩(Secure Coding)은 **보안 취약점을 방지하기 위해 안전한 프로그래밍 기법을 사용하여 코드를 작성하는 것**이다.  
소프트웨어 개발 단계에서 **보안 약점을 사전에 제거**하여 해킹이나 악의적 공격으로부터 시스템을 보호한다.

#### 🧩 주요 시큐어 코딩 기법

| 취약점 유형 | 대응 기법 |
|-------------|-----------|
| **입력값 검증** | 모든 외부 입력에 대한 유효성 검사, 화이트리스트 방식 사용 |
| **SQL 삽입 방지** | PreparedStatement 사용, 동적 쿼리 금지 |
| **XSS 방지** | 출력값 인코딩, HTML 태그 필터링 |
| **버퍼 오버플로 방지** | 경계값 검사, 안전한 함수 사용 |
| **인증/세션 관리** | 강력한 패스워드 정책, 세션 타임아웃 설정 |
| **에러 처리** | 민감한 정보 노출 방지, 적절한 로그 기록 |
| **암호화** | 강력한 암호화 알고리즘 사용, 키 관리 |

#### 🧩 시큐어 코딩 원칙
- **최소 권한 원칙**: 필요한 최소한의 권한만 부여
- **완전한 중재**: 모든 접근에 대한 권한 검사
- **다층 방어**: 여러 보안 계층으로 시스템 보호
- **실패시 보안**: 오류 발생 시 안전한 상태로 복구

#### 📝 기출 포맷 예시
- 시큐어 코딩의 목적으로 옳은 것은?
- 다음 중 입력값 검증 방법은?
- SQL 삽입 공격을 방지하는 방법은?

#### 🧠 용어 설명
- **Secure Coding**: 보안 취약점을 방지하는 안전한 프로그래밍 기법
- **Input Validation**: 외부에서 입력받는 모든 데이터의 유효성 검증
- **Prepared Statement**: SQL 삽입 공격을 방지하는 안전한 쿼리 실행 방법
- **White List**: 허용된 항목만을 명시한 목록 방식

---

## 🔹 258. SQL 삽입 (SQL Injection)

#### 📘 정의
SQL 삽입 공격은 **웹 애플리케이션의 입력값을 통해 악의적인 SQL 문을 데이터베이스에 전달하여 정보를 탈취하거나 조작하는 공격 기법**이다.  
입력값 검증이 부족한 애플리케이션에서 주로 발생하며, **OWASP Top 10**의 주요 취약점 중 하나이다.

#### 🧩 공격 유형

| 공격 유형 | 설명 |
|-----------|------|
| **Union SQL Injection** | UNION 구문을 이용해 다른 테이블의 데이터를 조회 |
| **Boolean-based Blind** | 참/거짓 결과를 통해 데이터베이스 정보를 추측 |
| **Time-based Blind** | 시간 지연을 이용해 데이터베이스 정보를 추측 |
| **Error-based** | 데이터베이스 오류 메시지를 통해 정보를 획득 |

#### 🧩 공격 예시
```sql
-- 정상적인 로그인 쿼리
SELECT * FROM users WHERE id='user' AND pw='pass';

-- SQL 삽입 공격 (항상 참이 되는 조건)
SELECT * FROM users WHERE id='admin'--' AND pw='';
```

#### 🧩 방어 기법
- **Prepared Statement 사용**: 쿼리와 데이터를 분리
- **입력값 검증**: 특수문자 필터링, 길이 제한
- **최소 권한 원칙**: 데이터베이스 계정 권한 최소화
- **에러 메시지 숨김**: 데이터베이스 정보 노출 방지

#### 📝 기출 포맷 예시
- SQL 삽입 공격의 정의는?
- 다음 중 SQL 삽입 방어 방법은?
- Prepared Statement의 장점은?

#### 🧠 용어 설명
- **SQL Injection**: 악의적인 SQL 문을 삽입하는 공격
- **Union Injection**: UNION 구문을 악용한 SQL 삽입
- **Blind SQL Injection**: 결과를 직접 볼 수 없는 상황에서의 SQL 삽입
- **Prepared Statement**: SQL 쿼리를 미리 컴파일하여 안전하게 실행하는 방법

---

## 🔹 259. 크로스사이트 스크립팅 (XSS: Cross-Site Scripting)

#### 📘 정의
XSS는 **웹 애플리케이션의 취약점을 이용하여 악의적인 스크립트를 다른 사용자의 브라우저에서 실행시키는 공격**이다.  
공격자가 **클라이언트 측 스크립트를 웹 페이지에 삽입**하여 사용자의 쿠키나 세션 정보를 탈취하거나 악의적인 행동을 수행한다.

#### 🧩 XSS 공격 유형

| 유형 | 설명 | 특징 |
|------|------|------|
| **Stored XSS** | 악성 스크립트가 서버에 저장되어 지속적으로 실행 | 게시판, 댓글 등에서 발생 |
| **Reflected XSS** | 입력값이 그대로 응답에 반영되어 일회성으로 실행 | URL 파라미터를 통한 공격 |
| **DOM-based XSS** | 클라이언트 측 DOM 조작을 통해 실행 | JavaScript에서 DOM 직접 조작 시 발생 |

#### 🧩 공격 예시
```html
<!-- 정상적인 입력 -->
<div>안녕하세요, 홍길동님</div>

<!-- XSS 공격 스크립트 삽입 -->
<div>안녕하세요, <script>alert('XSS 공격!')</script>님</div>
```

#### 🧩 방어 기법
- **출력값 인코딩**: HTML 특수문자를 엔티티로 변환
- **입력값 검증**: 스크립트 태그 필터링
- **CSP 적용**: Content Security Policy 설정
- **HttpOnly 쿠키**: JavaScript에서 쿠키 접근 차단

#### 📝 기출 포맷 예시
- XSS 공격의 정의는?
- Stored XSS와 Reflected XSS의 차이점은?
- XSS 방어 방법으로 옳은 것은?

#### 🧠 용어 설명
- **XSS**: 악성 스크립트를 웹 페이지에 삽입하는 공격
- **Stored XSS**: 서버에 저장되는 지속형 XSS
- **Reflected XSS**: 즉시 반사되는 반사형 XSS
- **Output Encoding**: 출력값을 안전하게 인코딩하는 방법
- **CSP**: 스크립트 실행을 제어하는 보안 정책

---

## 🔹 260. 메모리 버퍼 오버플로 (Buffer Overflow)

#### 📘 정의
버퍼 오버플로는 **프로그램이 할당된 메모리 영역을 초과하여 데이터를 입력받을 때 발생하는 취약점**이다.  
공격자가 **메모리 경계를 넘어 데이터를 덮어써서** 프로그램의 실행 흐름을 조작하거나 악성 코드를 실행시킬 수 있다.

#### 🧩 버퍼 오버플로 유형

| 유형 | 설명 |
|------|------|
| **스택 오버플로** | 스택 영역에서 발생하는 오버플로, 함수 호출과 관련 |
| **힙 오버플로** | 힙 영역에서 발생하는 오버플로, 동적 메모리 할당과 관련 |
| **BOF(Buffer Over Flow)** | 일반적인 버퍼 경계 초과 현상 |

#### 🧩 공격 메커니즘
1. **버퍼 크기 초과**: 할당된 메모리보다 큰 데이터 입력
2. **스택/힙 덮어쓰기**: 인접 메모리 영역 오염
3. **리턴 주소 조작**: 함수 반환 주소를 악성 코드 주소로 변경
4. **쉘코드 실행**: 공격자가 원하는 코드 실행

#### 🧩 방어 기법
- **경계값 검사**: 입력값 크기 제한
- **안전한 함수 사용**: strcpy 대신 strncpy 사용
- **스택 보호**: 카나리(Canary), DEP(Data Execution Prevention)
- **ASLR**: Address Space Layout Randomization

#### 📝 기출 포맷 예시
- 버퍼 오버플로 공격의 정의는?
- 스택 오버플로와 힙 오버플로의 차이점은?
- 버퍼 오버플로 방어 방법으로 옳은 것은?

#### 🧠 용어 설명
- **Buffer Overflow**: 할당된 메모리 영역을 초과하는 취약점
- **Stack Overflow**: 스택 영역에서 발생하는 메모리 오버플로
- **Heap Overflow**: 힙 영역에서 발생하는 메모리 오버플로
- **Canary**: 스택 오버플로를 탐지하는 보호 기법
- **DEP**: 데이터 영역에서 코드 실행을 방지하는 기법
- **ASLR**: 메모리 주소를 무작위로 배치하는 보안 기법

---

## 🔹 261. 보안 기능 관련 용어

#### 📘 정의
보안 기능 관련 용어는 **소프트웨어 시스템에서 보안을 구현하고 관리하기 위해 사용되는 핵심 개념들**을 포함한다.  
접근 제어, 암호화, 감사 등 **다양한 보안 메커니즘을 이해하기 위한 기본 용어**들이다.

#### 🧩 주요 보안 기능 용어

| 용어 | 영어명 | 설명 |
|------|--------|------|
| **접근 제어** | Access Control | 자원에 대한 접근을 제한하고 관리하는 기능 |
| **방화벽** | Firewall | 네트워크 트래픽을 모니터링하고 차단하는 보안 시스템 |
| **침입 탐지** | Intrusion Detection | 시스템 침입을 실시간으로 탐지하는 기능 |
| **취약점 평가** | Vulnerability Assessment | 시스템의 보안 약점을 체계적으로 분석 |
| **보안 감사** | Security Audit | 보안 정책 준수 여부를 점검하는 활동 |
| **위험 관리** | Risk Management | 보안 위험을 식별하고 관리하는 프로세스 |
| **백업/복구** | Backup & Recovery | 데이터 손실에 대비한 백업 및 복구 체계 |
| **HTTPS** | HTTP Secure | HTTP에 SSL/TLS를 적용한 보안 통신 프로토콜 |
| **SSL** | Secure Socket Layer | 네트워크 통신을 암호화하는 보안 프로토콜 |
| **하드코딩** | Hard Coding | 소스 코드에 값을 직접 입력하는 방식 (보안상 위험) |

#### 🧩 접근 제어 모델
- **DAC**: 소유자가 권한을 설정하는 임의 접근 제어
- **MAC**: 시스템이 권한을 강제하는 강제 접근 제어
- **RBAC**: 역할 기반 접근 제어

#### 📝 기출 포맷 예시
- 접근 제어의 정의는?
- DAC와 MAC의 차이점은?
- 침입 탐지 시스템의 역할은?

#### 🧠 용어 설명
- **Access Control**: 시스템 자원에 대한 접근 권한 관리
- **DAC**: 데이터 소유자가 권한을 결정하는 방식
- **MAC**: 시스템 정책에 따라 강제되는 접근 제어
- **RBAC**: 사용자의 역할에 따른 권한 부여 방식
- **IDS**: 침입을 탐지하여 경고하는 시스템
- **Firewall**: 네트워크 경계에서 트래픽을 제어하는 보안 장치

---

## 🔹 262. 하드코딩된 암호화 키 (Hard-coded Cryptographic Key)

#### 📘 정의
하드코딩된 암호화 키는 **소스 코드에 암호화 키가 직접 입력되어 있는 보안 취약점**이다.  
암호화 키가 소스 코드에 노출되면 **키의 기밀성이 훼손**되어 암호화의 효과가 무의미해진다.

#### 🧩 핵심 문제점
- **키 노출**: 소스 코드 분석 시 키가 그대로 드러남
- **키 변경 어려움**: 키 변경 시 소스 코드 수정 필요
- **보안 강도 저하**: 암호화 알고리즘이 강력해도 키 노출로 무력화

#### 🧩 취약한 코드 예시
```java
// 잘못된 방법 - 하드코딩
String encryptionKey = "MySecretKey123";
cipher.init(Cipher.ENCRYPT_MODE, encryptionKey);
```

#### 🧩 안전한 대안
- **외부 파일 저장**: 설정 파일이나 환경 변수 활용
- **키 관리 시스템**: HSM(Hardware Security Module) 사용
- **동적 키 생성**: 런타임에 키 생성 또는 파생
- **키 암호화**: 마스터 키로 실제 키를 암호화하여 저장

#### 📝 기출 포맷 예시
- 하드코딩된 암호화 키의 문제점은?
- 암호화 키를 안전하게 관리하는 방법은?
- 다음 중 키 관리 모범 사례는?

#### 🧠 용어 설명
- **Hard-coded Key**: 소스 코드에 직접 작성된 암호화 키
- **HSM**: 하드웨어 기반 키 관리 및 암호화 처리 장치
- **Key Derivation**: 마스터 키로부터 서브 키를 생성하는 기법
- **Environment Variable**: 운영체제 환경에서 관리되는 변수

---

## 🔹 263. 스택 가드 (Stack Guard)

#### 📘 정의
스택 가드는 **버퍼 오버플로 공격을 방지하기 위해 스택에 보호 메커니즘을 적용하는 보안 기법**이다.  
**카나리(Canary) 값**을 스택에 삽입하여 **스택 오버플로 공격을 탐지**하고 프로그램을 안전하게 종료시킨다.

#### 🧩 핵심 메커니즘
- **카나리 값**: 스택 프레임에 특별한 값을 삽입
- **오버플로 탐지**: 함수 종료 시 카나리 값 변경 여부 확인
- **프로그램 종료**: 공격 탐지 시 프로그램 즉시 종료

#### 🧩 동작 원리
```
[지역변수] [카나리값] [이전 프레임 포인터] [리턴 주소]
    ↓           ↓
정상 상태    공격 시 변경됨 → 탐지!
```

#### 🧩 카나리 값 종류
- **Random Canary**: 프로그램 시작 시 무작위 생성
- **Terminator Canary**: 문자열 종료 문자 포함
- **Null Canary**: 0x00 값 사용

#### 🧩 활용 분야
- **GCC 컴파일러**: -fstack-protector 옵션
- **Visual Studio**: /GS 옵션
- **운영체제**: 시스템 레벨 보호

#### 📝 기출 포맷 예시
- 스택 가드의 목적은?
- 카나리 값의 역할은?
- 스택 가드 구현 방법으로 옳은 것은?

#### 🧠 용어 설명
- **Stack Guard**: 스택 오버플로 공격 방지 기법
- **Canary**: 공격 탐지를 위한 특별한 값
- **Buffer Overflow**: 버퍼 경계를 넘어서는 공격
- **Return Address**: 함수 종료 후 돌아갈 주소

---

## 🔹 264. 접근 제어자 (Access Modifier)

#### 📘 정의
접근 제어자는 **클래스, 메서드, 변수 등에 대한 접근 권한을 제어하는 키워드**이다.  
객체지향 프로그래밍에서 **캡슐화와 정보 은닉을 구현**하기 위한 핵심 메커니즘이다.

#### 🧩 자바 접근 제어자 종류

| 접근 제어자 | 접근 범위 | 설명 |
|-------------|-----------|------|
| **public** | 모든 곳 | 어떤 클래스에서든 접근 가능 |
| **protected** | 패키지 + 상속 | 같은 패키지 또는 상속받은 클래스에서 접근 |
| **default** | 패키지 내 | 같은 패키지 내에서만 접근 (package-private) |
| **private** | 클래스 내 | 같은 클래스 내에서만 접근 |

#### 🧩 접근 범위 순서
**public > protected > default > private**

#### 🧩 보안 관점의 중요성
- **정보 은닉**: 중요한 데이터를 외부에서 직접 접근 차단
- **캡슐화**: 객체의 내부 구현을 숨기고 인터페이스만 제공
- **무결성 보장**: 잘못된 접근을 방지하여 데이터 보호

#### 📝 기출 포맷 예시
- 접근 제어자의 목적은?
- private과 public의 차이점은?
- 다음 중 접근 범위가 가장 넓은 것은?

#### 🧠 용어 설명
- **Access Modifier**: 접근 권한을 제어하는 키워드
- **Encapsulation**: 데이터와 메서드를 하나로 묶는 캡슐화
- **Information Hiding**: 내부 구현을 숨기는 정보 은닉
- **Package-private**: 패키지 내에서만 접근 가능한 기본 접근 수준

---

## 🔹 265. 개인키 암호화 기법 (Private Key Cryptography)

#### 📘 정의
개인키 암호화 기법은 **암호화와 복호화에 동일한 키를 사용하는 암호화 방식**이다.  
**대칭키 암호화** 또는 **비밀키 암호화**라고도 불리며, **키의 기밀성이 보안의 핵심**이다.

#### 🧩 주요 특징
- **동일한 키**: 암호화와 복호화에 같은 키 사용
- **빠른 속도**: 공개키 암호화보다 처리 속도가 빠름
- **키 공유 문제**: 안전한 키 전달 방법 필요
- **대용량 데이터**: 큰 데이터 암호화에 적합

#### 🧩 암호화 방식 분류

| 분류 | 설명 | 특징 |
|------|------|------|
| **블록 암호화** | 고정된 크기의 블록 단위로 암호화 | 64비트, 128비트 등 고정 블록 크기 |
| **스트림 암호화** | 데이터를 1비트 또는 1바이트씩 연속적으로 암호화 | 실시간 처리에 적합 |

#### 🧩 주요 알고리즘

**📦 블록 암호화 알고리즘**

| 알고리즘 | 키 길이 | 블록 크기 | 특징 |
|----------|---------|-----------|------|
| **DES** | 56비트 | 64비트 | 현재는 보안 강도 부족으로 사용 중단 |
| **3DES** | 168비트 | 64비트 | DES를 3번 적용한 향상된 버전 |
| **AES** | 128/192/256비트 | 128비트 | 현재 표준 암호화 알고리즘 |
| **ARIA** | 128/192/256비트 | 128비트 | 한국 표준 암호화 알고리즘 |
| **SEED** | 128비트 | 128비트 | 한국 정보보호진흥원 개발 |
| **IDEA** | 128비트 | 64비트 | 국제 데이터 암호화 알고리즘 |
| **Skipjack** | 80비트 | 64비트 | NSA 개발, 클리퍼 칩 사용 |

**🌊 스트림 암호화 알고리즘**

| 알고리즘 | 키 길이 | 특징 |
|----------|---------|------|
| **LFSR** | 가변 | 선형 피드백 시프트 레지스터 |
| **RC4** | 40~2048비트 | 가변 길이 키, SSL/WEP에서 사용 |
| **TKIP** | 128비트 | WPA에서 사용하는 개선된 암호화 |

#### 🧩 장점과 단점

| 장점 | 단점 |
|------|------|
| • 빠른 암호화/복호화 속도 | • 키 배송 및 관리 문제 |
| • 대용량 데이터 처리 가능 | • 사용자 증가 시 키 관리 복잡 |
| • 구현이 상대적으로 간단 | • 부인 방지 기능 제공 불가 |

#### 📝 기출 포맷 예시
- 대칭키 암호화의 특징은?
- 다음 중 개인키 암호화 알고리즘은?
- 대칭키 암호화의 단점으로 옳은 것은?

#### 🧠 용어 설명
- **Symmetric Key**: 암호화와 복호화에 동일한 키 사용
- **Private Key**: 비밀리에 관리되는 개인키
- **Key Distribution**: 키를 안전하게 전달하는 문제
- **Block Cipher**: 고정된 크기의 블록 단위로 암호화하는 방식

---

## 🔹 266. 공개키 암호화 기법 (Public Key Cryptography)

#### 📘 정의
공개키 암호화 기법은 **암호화와 복호화에 서로 다른 키를 사용하는 암호화 방식**이다.  
**공개키와 개인키 한 쌍**을 사용하며, **비대칭키 암호화**라고도 불린다.

#### 🧩 핵심 구조
- **키 쌍**: 공개키(Public Key) + 개인키(Private Key)
- **공개키**: 누구나 알 수 있는 공개된 키
- **개인키**: 소유자만 알고 있는 비밀 키
- **수학적 관계**: 두 키는 수학적으로 연관되어 있음

#### 🧩 암호화 과정
```
송신자 → [공개키로 암호화] → 암호문 → [개인키로 복호화] → 수신자
```

#### 🧩 주요 알고리즘

| 알고리즘 | 키 길이 | 특징 |
|----------|---------|------|
| **RSA** | 1024/2048/4096비트 | 가장 널리 사용되는 공개키 암호화 |
| **ECC** | 160~521비트 | 타원곡선을 이용한 효율적인 암호화 |
| **ElGamal** | 1024비트 이상 | 이산 로그 문제 기반 |
| **DSA** | 1024/2048/3072비트 | 디지털 서명 전용 |

#### 🧩 장점과 단점

| 장점 | 단점 |
|------|------|
| • 키 배송 문제 해결 | • 처리 속도가 느림 |
| • 디지털 서명 가능 | • 계산 복잡도가 높음 |
| • 부인 방지 기능 제공 | • 대용량 데이터 처리 부적합 |

#### 📝 기출 포맷 예시
- 공개키 암호화의 특징은?
- RSA 알고리즘의 장점은?
- 대칭키와 비대칭키의 차이점은?

#### 🧠 용어 설명
- **Asymmetric Key**: 암호화와 복호화에 다른 키 사용
- **Public Key**: 공개적으로 배포되는 키
- **Private Key**: 개인이 비밀리에 보관하는 키
- **Digital Signature**: 공개키 암호화를 이용한 전자 서명

---

## 🔹 267. IDEA (International Data Encryption Algorithm)

#### 📘 정의
IDEA는 **스위스에서 개발된 128비트 블록 암호화 알고리즘**이다.  
**PGP(Pretty Good Privacy)**에서 사용되며, **강력한 보안성**을 제공하는 대칭키 암호화 방식이다.

#### 🧩 주요 특징
- **키 길이**: 128비트
- **블록 크기**: 64비트
- **라운드 수**: 8.5라운드
- **구조**: Feistel 네트워크가 아닌 독특한 구조
- **연산**: 덧셈, 곱셈, XOR 연산 조합

#### 🧩 IDEA의 강점
- **특허 보호**: 강력한 특허로 보호받았음 (현재는 만료)
- **효율성**: 소프트웨어 구현에 최적화
- **보안성**: 현재까지 실용적인 공격법 발견되지 않음
- **국제 표준**: 여러 국가에서 표준으로 채택

#### 🧩 활용 분야
- **PGP**: 이메일 암호화 프로그램
- **SSL/TLS**: 초기 버전에서 사용
- **VPN**: 가상 사설망 암호화
- **파일 암호화**: 개인 파일 보호

#### 📝 기출 포맷 예시
- IDEA 알고리즘의 키 길이는?
- IDEA가 사용되는 대표적인 프로그램은?
- IDEA의 특징으로 옳은 것은?

#### 🧠 용어 설명
- **IDEA**: 국제 데이터 암호화 알고리즘
- **Block Cipher**: 고정된 크기의 블록 단위로 암호화
- **PGP**: IDEA를 사용하는 이메일 암호화 프로그램
- **Feistel Network**: 암호화 알고리즘의 일반적인 구조 방식

---

## 🔹 268. Skipjack

#### 📘 정의
Skipjack은 **미국 NSA에서 개발한 80비트 대칭키 블록 암호화 알고리즘**이다.  
**클리퍼 칩(Clipper Chip)**에 사용되었으며, **정부 기관의 통신 보안**을 위해 설계되었다.

#### 🧩 주요 특징
- **키 길이**: 80비트
- **블록 크기**: 64비트
- **라운드 수**: 32라운드
- **개발 기관**: NSA (National Security Agency)
- **분류**: 기밀 해제된 정부 알고리즘

#### 🧩 클리퍼 칩과의 관계
- **하드웨어 구현**: 클리퍼 칩에 내장된 암호화 알고리즘
- **정부 정책**: 암호화 수출 통제와 관련
- **백도어 논란**: 정부 기관의 접근 가능성 논란
- **상용화 실패**: 사용자 저항으로 상용화 무산

#### 🧩 보안 평가
- **현재 평가**: 80비트 키는 현재 기준으로는 부족
- **알고리즘 강도**: 구조적으로는 안전한 것으로 평가
- **역사적 의미**: 정부 암호화 정책의 전환점

#### 📝 기출 포맷 예시
- Skipjack 알고리즘의 키 길이는?
- Skipjack이 사용된 하드웨어는?
- Skipjack 개발 기관으로 옳은 것은?

#### 🧠 용어 설명
- **Skipjack**: NSA에서 개발한 80비트 블록 암호화 알고리즘
- **Clipper Chip**: Skipjack을 내장한 하드웨어 암호화 칩
- **NSA**: 미국 국가안보국
- **Key Escrow**: 정부 기관이 암호화 키를 보관하는 정책