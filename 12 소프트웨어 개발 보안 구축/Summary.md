## 🔹 255. Secure SDLC

#### 📘 정의
Secure SDLC(Secure Software Development Life Cycle)는 **소프트웨어 개발 생명주기의 모든 단계에서 보안을 고려하여 안전한 소프트웨어를 개발하는 방법론**이다.  
기존 SDLC에 보안 요소를 통합하여 **설계 단계부터 보안 취약점을 예방**하는 것을 목적으로 한다.

#### 🧩 핵심 단계별 보안 활동

| 단계 | 보안 활동 |
|------|-----------|
| **요구사항 분석** | 보안 요구사항 정의, 위협 분석 |
| **설계** | 보안 아키텍처 설계, 위협 모델링 |
| **구현** | 시큐어 코딩, 보안 가이드라인 준수 |
| **테스트** | 보안 테스트, 취약점 진단 |
| **배포** | 보안 설정, 접근 제어 구성 |
| **유지보수** | 보안 패치, 지속적 모니터링 |

#### 🧩 주요 특징
- **예방 중심**: 개발 초기부터 보안 고려
- **비용 효율성**: 사후 보안 패치보다 개발 단계 보안이 비용 절약
- **지속적 보안**: 전 생명주기에 걸친 보안 관리

#### 📝 기출 포맷 예시
- Secure SDLC의 목적으로 옳은 것은?
- 다음 중 설계 단계의 보안 활동은?
- 기존 SDLC와 Secure SDLC의 차이점은?

#### 🧠 용어 설명
- **Secure SDLC**: 보안이 통합된 소프트웨어 개발 생명주기
- **위협 모델링**: 시스템의 보안 위협을 체계적으로 분석하는 기법
- **시큐어 코딩**: 보안 취약점을 방지하는 안전한 프로그래밍 기법

---

## 🔹 256. 소프트웨어 개발 보안 요소

#### 📘 정의
소프트웨어 개발 보안 요소는 **안전한 소프트웨어를 개발하기 위해 반드시 고려해야 할 핵심 보안 특성들**을 의미한다.  
정보보안의 3대 요소(기밀성, 무결성, 가용성)를 기반으로 **인증, 인가, 감사추적** 등의 요소가 추가된다.

#### 🧩 핵심 보안 요소

| 보안 요소 | 영어명 | 설명 |
|-----------|--------|------|
| **기밀성** | Confidentiality | 인가된 사용자만 정보에 접근할 수 있도록 보장 |
| **무결성** | Integrity | 정보가 무단으로 수정되지 않음을 보장 |
| **가용성** | Availability | 필요할 때 언제든지 시스템에 접근할 수 있음을 보장 |
| **인증** | Authentication | 사용자나 시스템의 신원을 확인하는 과정 |
| **인가** | Authorization | 인증된 사용자에게 적절한 권한을 부여하는 과정 |
| **부인방지** | Non-repudiation | 수행한 행위를 나중에 부인할 수 없도록 보장 |
| **감사추적** | Auditing | 시스템 내 모든 활동을 기록하고 추적 |

#### 🧩 CIA 삼각형 (정보보안 3대 요소)
```
       기밀성
      /      \
   무결성 ---- 가용성
```

#### 📝 기출 포맷 예시
- 정보보안의 3대 요소는?
- 다음 중 부인방지에 해당하는 것은?
- 인증과 인가의 차이점을 설명하시오.

#### 🧠 용어 설명
- **CIA**: 기밀성(Confidentiality), 무결성(Integrity), 가용성(Availability)
- **Authentication**: 신원 확인 과정 ("너는 누구인가?")
- **Authorization**: 권한 부여 과정 ("너는 무엇을 할 수 있는가?")
- **Non-repudiation**: 행위에 대한 책임을 부인할 수 없도록 하는 특성

---

## 🔹 257. 시큐어 코딩

#### 📘 정의
시큐어 코딩(Secure Coding)은 **보안 취약점을 방지하기 위해 안전한 프로그래밍 기법을 사용하여 코드를 작성하는 것**이다.  
소프트웨어 개발 단계에서 **보안 약점을 사전에 제거**하여 해킹이나 악의적 공격으로부터 시스템을 보호한다.

#### 🧩 주요 시큐어 코딩 기법

| 취약점 유형 | 대응 기법 |
|-------------|-----------|
| **입력값 검증** | 모든 외부 입력에 대한 유효성 검사, 화이트리스트 방식 사용 |
| **SQL 삽입 방지** | PreparedStatement 사용, 동적 쿼리 금지 |
| **XSS 방지** | 출력값 인코딩, HTML 태그 필터링 |
| **버퍼 오버플로 방지** | 경계값 검사, 안전한 함수 사용 |
| **인증/세션 관리** | 강력한 패스워드 정책, 세션 타임아웃 설정 |
| **에러 처리** | 민감한 정보 노출 방지, 적절한 로그 기록 |
| **암호화** | 강력한 암호화 알고리즘 사용, 키 관리 |

#### 🧩 시큐어 코딩 원칙
- **최소 권한 원칙**: 필요한 최소한의 권한만 부여
- **완전한 중재**: 모든 접근에 대한 권한 검사
- **다층 방어**: 여러 보안 계층으로 시스템 보호
- **실패시 보안**: 오류 발생 시 안전한 상태로 복구

#### 📝 기출 포맷 예시
- 시큐어 코딩의 목적으로 옳은 것은?
- 다음 중 입력값 검증 방법은?
- SQL 삽입 공격을 방지하는 방법은?

#### 🧠 용어 설명
- **Secure Coding**: 보안 취약점을 방지하는 안전한 프로그래밍 기법
- **Input Validation**: 외부에서 입력받는 모든 데이터의 유효성 검증
- **Prepared Statement**: SQL 삽입 공격을 방지하는 안전한 쿼리 실행 방법
- **White List**: 허용된 항목만을 명시한 목록 방식

---

## 🔹 258. SQL 삽입 (SQL Injection)

#### 📘 정의
SQL 삽입 공격은 **웹 애플리케이션의 입력값을 통해 악의적인 SQL 문을 데이터베이스에 전달하여 정보를 탈취하거나 조작하는 공격 기법**이다.  
입력값 검증이 부족한 애플리케이션에서 주로 발생하며, **OWASP Top 10**의 주요 취약점 중 하나이다.

#### 🧩 공격 유형

| 공격 유형 | 설명 |
|-----------|------|
| **Union SQL Injection** | UNION 구문을 이용해 다른 테이블의 데이터를 조회 |
| **Boolean-based Blind** | 참/거짓 결과를 통해 데이터베이스 정보를 추측 |
| **Time-based Blind** | 시간 지연을 이용해 데이터베이스 정보를 추측 |
| **Error-based** | 데이터베이스 오류 메시지를 통해 정보를 획득 |

#### 🧩 공격 예시
```sql
-- 정상적인 로그인 쿼리
SELECT * FROM users WHERE id='user' AND pw='pass';

-- SQL 삽입 공격 (항상 참이 되는 조건)
SELECT * FROM users WHERE id='admin'--' AND pw='';
```

#### 🧩 방어 기법
- **Prepared Statement 사용**: 쿼리와 데이터를 분리
- **입력값 검증**: 특수문자 필터링, 길이 제한
- **최소 권한 원칙**: 데이터베이스 계정 권한 최소화
- **에러 메시지 숨김**: 데이터베이스 정보 노출 방지

#### 📝 기출 포맷 예시
- SQL 삽입 공격의 정의는?
- 다음 중 SQL 삽입 방어 방법은?
- Prepared Statement의 장점은?

#### 🧠 용어 설명
- **SQL Injection**: 악의적인 SQL 문을 삽입하는 공격
- **Union Injection**: UNION 구문을 악용한 SQL 삽입
- **Blind SQL Injection**: 결과를 직접 볼 수 없는 상황에서의 SQL 삽입
- **Prepared Statement**: SQL 쿼리를 미리 컴파일하여 안전하게 실행하는 방법

---

## 🔹 259. 크로스사이트 스크립팅 (XSS: Cross-Site Scripting)

#### 📘 정의
XSS는 **웹 애플리케이션의 취약점을 이용하여 악의적인 스크립트를 다른 사용자의 브라우저에서 실행시키는 공격**이다.  
공격자가 **클라이언트 측 스크립트를 웹 페이지에 삽입**하여 사용자의 쿠키나 세션 정보를 탈취하거나 악의적인 행동을 수행한다.

#### 🧩 XSS 공격 유형

| 유형 | 설명 | 특징 |
|------|------|------|
| **Stored XSS** | 악성 스크립트가 서버에 저장되어 지속적으로 실행 | 게시판, 댓글 등에서 발생 |
| **Reflected XSS** | 입력값이 그대로 응답에 반영되어 일회성으로 실행 | URL 파라미터를 통한 공격 |
| **DOM-based XSS** | 클라이언트 측 DOM 조작을 통해 실행 | JavaScript에서 DOM 직접 조작 시 발생 |

#### 🧩 공격 예시
```html
<!-- 정상적인 입력 -->
<div>안녕하세요, 홍길동님</div>

<!-- XSS 공격 스크립트 삽입 -->
<div>안녕하세요, <script>alert('XSS 공격!')</script>님</div>
```

#### 🧩 방어 기법
- **출력값 인코딩**: HTML 특수문자를 엔티티로 변환
- **입력값 검증**: 스크립트 태그 필터링
- **CSP 적용**: Content Security Policy 설정
- **HttpOnly 쿠키**: JavaScript에서 쿠키 접근 차단

#### 📝 기출 포맷 예시
- XSS 공격의 정의는?
- Stored XSS와 Reflected XSS의 차이점은?
- XSS 방어 방법으로 옳은 것은?

#### 🧠 용어 설명
- **XSS**: 악성 스크립트를 웹 페이지에 삽입하는 공격
- **Stored XSS**: 서버에 저장되는 지속형 XSS
- **Reflected XSS**: 즉시 반사되는 반사형 XSS
- **Output Encoding**: 출력값을 안전하게 인코딩하는 방법
- **CSP**: 스크립트 실행을 제어하는 보안 정책

---

## 🔹 260. 메모리 버퍼 오버플로 (Buffer Overflow)

#### 📘 정의
버퍼 오버플로는 **프로그램이 할당된 메모리 영역을 초과하여 데이터를 입력받을 때 발생하는 취약점**이다.  
공격자가 **메모리 경계를 넘어 데이터를 덮어써서** 프로그램의 실행 흐름을 조작하거나 악성 코드를 실행시킬 수 있다.

#### 🧩 버퍼 오버플로 유형

| 유형 | 설명 |
|------|------|
| **스택 오버플로** | 스택 영역에서 발생하는 오버플로, 함수 호출과 관련 |
| **힙 오버플로** | 힙 영역에서 발생하는 오버플로, 동적 메모리 할당과 관련 |
| **BOF(Buffer Over Flow)** | 일반적인 버퍼 경계 초과 현상 |

#### 🧩 공격 메커니즘
1. **버퍼 크기 초과**: 할당된 메모리보다 큰 데이터 입력
2. **스택/힙 덮어쓰기**: 인접 메모리 영역 오염
3. **리턴 주소 조작**: 함수 반환 주소를 악성 코드 주소로 변경
4. **쉘코드 실행**: 공격자가 원하는 코드 실행

#### 🧩 방어 기법
- **경계값 검사**: 입력값 크기 제한
- **안전한 함수 사용**: strcpy 대신 strncpy 사용
- **스택 보호**: 카나리(Canary), DEP(Data Execution Prevention)
- **ASLR**: Address Space Layout Randomization

#### 📝 기출 포맷 예시
- 버퍼 오버플로 공격의 정의는?
- 스택 오버플로와 힙 오버플로의 차이점은?
- 버퍼 오버플로 방어 방법으로 옳은 것은?

#### 🧠 용어 설명
- **Buffer Overflow**: 할당된 메모리 영역을 초과하는 취약점
- **Stack Overflow**: 스택 영역에서 발생하는 메모리 오버플로
- **Heap Overflow**: 힙 영역에서 발생하는 메모리 오버플로
- **Canary**: 스택 오버플로를 탐지하는 보호 기법
- **DEP**: 데이터 영역에서 코드 실행을 방지하는 기법
- **ASLR**: 메모리 주소를 무작위로 배치하는 보안 기법

---

## 🔹 261. 보안 기능 관련 용어

#### 📘 정의
보안 기능 관련 용어는 **소프트웨어 시스템에서 보안을 구현하고 관리하기 위해 사용되는 핵심 개념들**을 포함한다.  
접근 제어, 암호화, 감사 등 **다양한 보안 메커니즘을 이해하기 위한 기본 용어**들이다.

#### 🧩 주요 보안 기능 용어

| 용어 | 영어명 | 설명 |
|------|--------|------|
| **접근 제어** | Access Control | 자원에 대한 접근을 제한하고 관리하는 기능 |
| **방화벽** | Firewall | 네트워크 트래픽을 모니터링하고 차단하는 보안 시스템 |
| **침입 탐지** | Intrusion Detection | 시스템 침입을 실시간으로 탐지하는 기능 |
| **취약점 평가** | Vulnerability Assessment | 시스템의 보안 약점을 체계적으로 분석 |
| **보안 감사** | Security Audit | 보안 정책 준수 여부를 점검하는 활동 |
| **위험 관리** | Risk Management | 보안 위험을 식별하고 관리하는 프로세스 |
| **백업/복구** | Backup & Recovery | 데이터 손실에 대비한 백업 및 복구 체계 |
| **HTTPS** | HTTP Secure | HTTP에 SSL/TLS를 적용한 보안 통신 프로토콜 |
| **SSL** | Secure Socket Layer | 네트워크 통신을 암호화하는 보안 프로토콜 |
| **하드코딩** | Hard Coding | 소스 코드에 값을 직접 입력하는 방식 (보안상 위험) |

#### 🧩 접근 제어 모델
- **DAC**: 소유자가 권한을 설정하는 임의 접근 제어
- **MAC**: 시스템이 권한을 강제하는 강제 접근 제어
- **RBAC**: 역할 기반 접근 제어

#### 📝 기출 포맷 예시
- 접근 제어의 정의는?
- DAC와 MAC의 차이점은?
- 침입 탐지 시스템의 역할은?

#### 🧠 용어 설명
- **Access Control**: 시스템 자원에 대한 접근 권한 관리
- **DAC**: 데이터 소유자가 권한을 결정하는 방식
- **MAC**: 시스템 정책에 따라 강제되는 접근 제어
- **RBAC**: 사용자의 역할에 따른 권한 부여 방식
- **IDS**: 침입을 탐지하여 경고하는 시스템
- **Firewall**: 네트워크 경계에서 트래픽을 제어하는 보안 장치

---

## 🔹 262. 하드코딩된 암호화 키 (Hard-coded Cryptographic Key)

#### 📘 정의
하드코딩된 암호화 키는 **소스 코드에 암호화 키가 직접 입력되어 있는 보안 취약점**이다.  
암호화 키가 소스 코드에 노출되면 **키의 기밀성이 훼손**되어 암호화의 효과가 무의미해진다.

#### 🧩 핵심 문제점
- **키 노출**: 소스 코드 분석 시 키가 그대로 드러남
- **키 변경 어려움**: 키 변경 시 소스 코드 수정 필요
- **보안 강도 저하**: 암호화 알고리즘이 강력해도 키 노출로 무력화

#### 🧩 취약한 코드 예시
```java
// 잘못된 방법 - 하드코딩
String encryptionKey = "MySecretKey123";
cipher.init(Cipher.ENCRYPT_MODE, encryptionKey);
```

#### 🧩 안전한 대안
- **외부 파일 저장**: 설정 파일이나 환경 변수 활용
- **키 관리 시스템**: HSM(Hardware Security Module) 사용
- **동적 키 생성**: 런타임에 키 생성 또는 파생
- **키 암호화**: 마스터 키로 실제 키를 암호화하여 저장

#### 📝 기출 포맷 예시
- 하드코딩된 암호화 키의 문제점은?
- 암호화 키를 안전하게 관리하는 방법은?
- 다음 중 키 관리 모범 사례는?

#### 🧠 용어 설명
- **Hard-coded Key**: 소스 코드에 직접 작성된 암호화 키
- **HSM**: 하드웨어 기반 키 관리 및 암호화 처리 장치
- **Key Derivation**: 마스터 키로부터 서브 키를 생성하는 기법
- **Environment Variable**: 운영체제 환경에서 관리되는 변수

---

## 🔹 263. 스택 가드 (Stack Guard)

#### 📘 정의
스택 가드는 **버퍼 오버플로 공격을 방지하기 위해 스택에 보호 메커니즘을 적용하는 보안 기법**이다.  
**카나리(Canary) 값**을 스택에 삽입하여 **스택 오버플로 공격을 탐지**하고 프로그램을 안전하게 종료시킨다.

#### 🧩 핵심 메커니즘
- **카나리 값**: 스택 프레임에 특별한 값을 삽입
- **오버플로 탐지**: 함수 종료 시 카나리 값 변경 여부 확인
- **프로그램 종료**: 공격 탐지 시 프로그램 즉시 종료

#### 🧩 동작 원리
```
[지역변수] [카나리값] [이전 프레임 포인터] [리턴 주소]
    ↓           ↓
정상 상태    공격 시 변경됨 → 탐지!
```

#### 🧩 카나리 값 종류
- **Random Canary**: 프로그램 시작 시 무작위 생성
- **Terminator Canary**: 문자열 종료 문자 포함
- **Null Canary**: 0x00 값 사용

#### 🧩 활용 분야
- **GCC 컴파일러**: -fstack-protector 옵션
- **Visual Studio**: /GS 옵션
- **운영체제**: 시스템 레벨 보호

#### 📝 기출 포맷 예시
- 스택 가드의 목적은?
- 카나리 값의 역할은?
- 스택 가드 구현 방법으로 옳은 것은?

#### 🧠 용어 설명
- **Stack Guard**: 스택 오버플로 공격 방지 기법
- **Canary**: 공격 탐지를 위한 특별한 값
- **Buffer Overflow**: 버퍼 경계를 넘어서는 공격
- **Return Address**: 함수 종료 후 돌아갈 주소

---

## 🔹 264. 접근 제어자 (Access Modifier)

#### 📘 정의
접근 제어자는 **클래스, 메서드, 변수 등에 대한 접근 권한을 제어하는 키워드**이다.  
객체지향 프로그래밍에서 **캡슐화와 정보 은닉을 구현**하기 위한 핵심 메커니즘이다.

#### 🧩 자바 접근 제어자 종류

| 접근 제어자 | 접근 범위 | 설명 |
|-------------|-----------|------|
| **public** | 모든 곳 | 어떤 클래스에서든 접근 가능 |
| **protected** | 패키지 + 상속 | 같은 패키지 또는 상속받은 클래스에서 접근 |
| **default** | 패키지 내 | 같은 패키지 내에서만 접근 (package-private) |
| **private** | 클래스 내 | 같은 클래스 내에서만 접근 |

#### 🧩 접근 범위 순서
**public > protected > default > private**

#### 🧩 보안 관점의 중요성
- **정보 은닉**: 중요한 데이터를 외부에서 직접 접근 차단
- **캡슐화**: 객체의 내부 구현을 숨기고 인터페이스만 제공
- **무결성 보장**: 잘못된 접근을 방지하여 데이터 보호

#### 📝 기출 포맷 예시
- 접근 제어자의 목적은?
- private과 public의 차이점은?
- 다음 중 접근 범위가 가장 넓은 것은?

#### 🧠 용어 설명
- **Access Modifier**: 접근 권한을 제어하는 키워드
- **Encapsulation**: 데이터와 메서드를 하나로 묶는 캡슐화
- **Information Hiding**: 내부 구현을 숨기는 정보 은닉
- **Package-private**: 패키지 내에서만 접근 가능한 기본 접근 수준

---

## 🔹 265. 개인키 암호화 기법 (Private Key Cryptography)

#### 📘 정의
개인키 암호화 기법은 **암호화와 복호화에 동일한 키를 사용하는 암호화 방식**이다.  
**대칭키 암호화** 또는 **비밀키 암호화**라고도 불리며, **키의 기밀성이 보안의 핵심**이다.

#### 🧩 주요 특징
- **동일한 키**: 암호화와 복호화에 같은 키 사용
- **빠른 속도**: 공개키 암호화보다 처리 속도가 빠름
- **키 공유 문제**: 안전한 키 전달 방법 필요
- **대용량 데이터**: 큰 데이터 암호화에 적합

#### 🧩 암호화 방식 분류

| 분류 | 설명 | 특징 |
|------|------|------|
| **블록 암호화** | 고정된 크기의 블록 단위로 암호화 | 64비트, 128비트 등 고정 블록 크기 |
| **스트림 암호화** | 데이터를 1비트 또는 1바이트씩 연속적으로 암호화 | 실시간 처리에 적합 |

#### 🧩 주요 알고리즘

**📦 블록 암호화 알고리즘**

| 알고리즘 | 키 길이 | 블록 크기 | 특징 |
|----------|---------|-----------|------|
| **DES** | 56비트 | 64비트 | 현재는 보안 강도 부족으로 사용 중단 |
| **3DES** | 168비트 | 64비트 | DES를 3번 적용한 향상된 버전 |
| **AES** | 128/192/256비트 | 128비트 | 현재 표준 암호화 알고리즘 |
| **ARIA** | 128/192/256비트 | 128비트 | 한국 표준 암호화 알고리즘 |
| **SEED** | 128비트 | 128비트 | 한국 정보보호진흥원 개발 |
| **IDEA** | 128비트 | 64비트 | 국제 데이터 암호화 알고리즘 |
| **Skipjack** | 80비트 | 64비트 | NSA 개발, 클리퍼 칩 사용 |

**🌊 스트림 암호화 알고리즘**

| 알고리즘 | 키 길이 | 특징 |
|----------|---------|------|
| **LFSR** | 가변 | 선형 피드백 시프트 레지스터 |
| **RC4** | 40~2048비트 | 가변 길이 키, SSL/WEP에서 사용 |
| **TKIP** | 128비트 | WPA에서 사용하는 개선된 암호화 |

#### 🧩 장점과 단점

| 장점 | 단점 |
|------|------|
| • 빠른 암호화/복호화 속도 | • 키 배송 및 관리 문제 |
| • 대용량 데이터 처리 가능 | • 사용자 증가 시 키 관리 복잡 |
| • 구현이 상대적으로 간단 | • 부인 방지 기능 제공 불가 |

#### 📝 기출 포맷 예시
- 대칭키 암호화의 특징은?
- 다음 중 개인키 암호화 알고리즘은?
- 대칭키 암호화의 단점으로 옳은 것은?

#### 🧠 용어 설명
- **Symmetric Key**: 암호화와 복호화에 동일한 키 사용
- **Private Key**: 비밀리에 관리되는 개인키
- **Key Distribution**: 키를 안전하게 전달하는 문제
- **Block Cipher**: 고정된 크기의 블록 단위로 암호화하는 방식

---

## 🔹 266. 공개키 암호화 기법 (Public Key Cryptography)

#### 📘 정의
공개키 암호화 기법은 **암호화와 복호화에 서로 다른 키를 사용하는 암호화 방식**이다.  
**공개키와 개인키 한 쌍**을 사용하며, **비대칭키 암호화**라고도 불린다.

#### 🧩 핵심 구조
- **키 쌍**: 공개키(Public Key) + 개인키(Private Key)
- **공개키**: 누구나 알 수 있는 공개된 키
- **개인키**: 소유자만 알고 있는 비밀 키
- **수학적 관계**: 두 키는 수학적으로 연관되어 있음

#### 🧩 암호화 과정
```
송신자 → [공개키로 암호화] → 암호문 → [개인키로 복호화] → 수신자
```

#### 🧩 주요 알고리즘

| 알고리즘 | 키 길이 | 특징 |
|----------|---------|------|
| **RSA** | 1024/2048/4096비트 | 가장 널리 사용되는 공개키 암호화 |
| **ECC** | 160~521비트 | 타원곡선을 이용한 효율적인 암호화 |
| **ElGamal** | 1024비트 이상 | 이산 로그 문제 기반 |
| **DSA** | 1024/2048/3072비트 | 디지털 서명 전용 |

#### 🧩 장점과 단점

| 장점 | 단점 |
|------|------|
| • 키 배송 문제 해결 | • 처리 속도가 느림 |
| • 디지털 서명 가능 | • 계산 복잡도가 높음 |
| • 부인 방지 기능 제공 | • 대용량 데이터 처리 부적합 |

#### 📝 기출 포맷 예시
- 공개키 암호화의 특징은?
- RSA 알고리즘의 장점은?
- 대칭키와 비대칭키의 차이점은?

#### 🧠 용어 설명
- **Asymmetric Key**: 암호화와 복호화에 다른 키 사용
- **Public Key**: 공개적으로 배포되는 키
- **Private Key**: 개인이 비밀리에 보관하는 키
- **Digital Signature**: 공개키 암호화를 이용한 전자 서명

---

## 🔹 267. IDEA (International Data Encryption Algorithm)

#### 📘 정의
IDEA는 **스위스에서 개발된 128비트 블록 암호화 알고리즘**이다.  
**PGP(Pretty Good Privacy)**에서 사용되며, **강력한 보안성**을 제공하는 대칭키 암호화 방식이다.

#### 🧩 주요 특징
- **키 길이**: 128비트
- **블록 크기**: 64비트
- **라운드 수**: 8.5라운드
- **구조**: Feistel 네트워크가 아닌 독특한 구조
- **연산**: 덧셈, 곱셈, XOR 연산 조합

#### 🧩 IDEA의 강점
- **특허 보호**: 강력한 특허로 보호받았음 (현재는 만료)
- **효율성**: 소프트웨어 구현에 최적화
- **보안성**: 현재까지 실용적인 공격법 발견되지 않음
- **국제 표준**: 여러 국가에서 표준으로 채택

#### 🧩 활용 분야
- **PGP**: 이메일 암호화 프로그램
- **SSL/TLS**: 초기 버전에서 사용
- **VPN**: 가상 사설망 암호화
- **파일 암호화**: 개인 파일 보호

#### 📝 기출 포맷 예시
- IDEA 알고리즘의 키 길이는?
- IDEA가 사용되는 대표적인 프로그램은?
- IDEA의 특징으로 옳은 것은?

#### 🧠 용어 설명
- **IDEA**: 국제 데이터 암호화 알고리즘
- **Block Cipher**: 고정된 크기의 블록 단위로 암호화
- **PGP**: IDEA를 사용하는 이메일 암호화 프로그램
- **Feistel Network**: 암호화 알고리즘의 일반적인 구조 방식

---

## 🔹 268. Skipjack

#### 📘 정의
Skipjack은 **미국 NSA에서 개발한 80비트 대칭키 블록 암호화 알고리즘**이다.  
**클리퍼 칩(Clipper Chip)**에 사용되었으며, **정부 기관의 통신 보안**을 위해 설계되었다.

#### 🧩 주요 특징
- **키 길이**: 80비트
- **블록 크기**: 64비트
- **라운드 수**: 32라운드
- **개발 기관**: NSA (National Security Agency)
- **분류**: 기밀 해제된 정부 알고리즘

#### 🧩 클리퍼 칩과의 관계
- **하드웨어 구현**: 클리퍼 칩에 내장된 암호화 알고리즘
- **정부 정책**: 암호화 수출 통제와 관련
- **백도어 논란**: 정부 기관의 접근 가능성 논란
- **상용화 실패**: 사용자 저항으로 상용화 무산

#### 🧩 보안 평가
- **현재 평가**: 80비트 키는 현재 기준으로는 부족
- **알고리즘 강도**: 구조적으로는 안전한 것으로 평가
- **역사적 의미**: 정부 암호화 정책의 전환점

#### 📝 기출 포맷 예시
- Skipjack 알고리즘의 키 길이는?
- Skipjack이 사용된 하드웨어는?
- Skipjack 개발 기관으로 옳은 것은?

#### 🧠 용어 설명
- **Skipjack**: NSA에서 개발한 80비트 블록 암호화 알고리즘
- **Clipper Chip**: Skipjack을 내장한 하드웨어 암호화 칩
- **NSA**: 미국 국가안보국
- **Key Escrow**: 정부 기관이 암호화 키를 보관하는 정책

---

## 🔹 269. DES (Data Encryption Standard)

#### 📘 정의
DES는 **1970년대 IBM에서 개발하여 미국 정부가 채택한 대칭키 블록 암호화 표준**이다.  
**56비트 키와 64비트 블록**을 사용하며, 오랫동안 상업적 암호화 표준으로 사용되었으나 현재는 보안 강도 부족으로 사용이 중단되었다.

#### 🧩 주요 특징
- **키 길이**: 56비트 (실제 64비트 중 8비트는 패리티)
- **블록 크기**: 64비트
- **라운드 수**: 16라운드
- **구조**: Feistel 네트워크 구조
- **모드**: ECB, CBC, CFB, OFB 등 지원

#### 🧩 DES 구조
```
평문 (64비트) → 초기 순열 → 16라운드 Feistel → 역순열 → 암호문
```

#### 🧩 보안 문제점
- **키 길이 부족**: 56비트는 현재 기준으로 취약
- **브루트 포스 공격**: 현대 컴퓨터로 단시간 내 해독 가능
- **차분 공격**: 1990년대 이후 효과적인 공격법 개발

#### 🧩 대안 및 발전
- **3DES**: DES를 3번 적용하여 보안 강도 향상
- **AES**: DES의 후속 표준으로 채택
- **레거시 시스템**: 기존 시스템에서 여전히 제한적 사용

#### 📝 기출 포맷 예시
- DES 알고리즘의 키 길이는?
- DES가 사용 중단된 이유는?
- DES의 구조 방식으로 옳은 것은?

#### 🧠 용어 설명
- **DES**: 데이터 암호화 표준
- **Feistel Network**: 대칭키 블록 암호의 구조 방식
- **Brute Force**: 모든 가능한 키를 시도하는 공격 방법
- **3DES**: DES를 3번 적용한 향상된 버전

---

## 🔹 270. AES (Advanced Encryption Standard)

#### 📘 정의
AES는 **2001년 미국 NIST에서 DES의 후속으로 채택한 대칭키 블록 암호화 표준**이다.  
**Rijndael 알고리즘**을 기반으로 하며, 현재 **전 세계적으로 가장 널리 사용되는 암호화 표준**이다.

#### 🧩 주요 특징
- **키 길이**: 128, 192, 256비트 (3가지 버전)
- **블록 크기**: 128비트 (고정)
- **라운드 수**: 10라운드 (AES-128), 12라운드 (AES-192), 14라운드 (AES-256)
- **구조**: SPN(Substitution-Permutation Network) 구조
- **개발자**: 벨기에의 Joan Daemen과 Vincent Rijmen

#### 🧩 AES 버전별 비교

| 버전 | 키 길이 | 라운드 수 | 보안 강도 |
|------|---------|-----------|-----------|
| **AES-128** | 128비트 | 10라운드 | 높음 |
| **AES-192** | 192비트 | 12라운드 | 매우 높음 |
| **AES-256** | 256비트 | 14라운드 | 최고 |

#### 🧩 AES 동작 과정 (각 라운드)
1. **AddRoundKey**: 라운드 키와 XOR 연산
2. **SubBytes**: S-box를 통한 바이트 치환
3. **ShiftRows**: 행 단위 순환 이동
4. **MixColumns**: 열 단위 선형 변환

#### 🧩 활용 분야
- **정부 기관**: 기밀 정보 보호
- **금융**: 온라인 뱅킹, 카드 결제
- **무선 통신**: WiFi WPA2/WPA3
- **VPN**: 터널링 암호화
- **파일 암호화**: 개인 및 기업 데이터 보호

#### 📝 기출 포맷 예시
- AES-256의 라운드 수는?
- AES의 블록 크기는?
- AES가 DES보다 안전한 이유는?

#### 🧠 용어 설명
- **AES**: 고급 암호화 표준
- **Rijndael**: AES의 원래 알고리즘 이름
- **SPN**: 치환-순열 네트워크 구조
- **S-box**: 바이트 치환을 위한 치환 상자

---

## 🔹 271. RSA (Rivest-Shamir-Adleman)

#### 📘 정의
RSA는 **1977년 MIT에서 개발된 최초의 실용적인 공개키 암호화 알고리즘**이다.  
**큰 정수의 소인수분해 어려움**을 기반으로 하며, **암호화와 디지털 서명 모두 지원**하는 가장 널리 사용되는 비대칭키 암호화 방식이다.

#### 🧩 주요 특징
- **키 길이**: 1024, 2048, 3072, 4096비트
- **수학적 기반**: 소인수분해 문제의 어려움
- **키 구조**: 공개키 (n, e), 개인키 (n, d)
- **개발자**: Ron Rivest, Adi Shamir, Leonard Adleman

#### 🧩 RSA 키 생성 과정
1. **소수 선택**: 큰 소수 p, q 선택
2. **n 계산**: n = p × q
3. **φ(n) 계산**: φ(n) = (p-1)(q-1)
4. **e 선택**: gcd(e, φ(n)) = 1인 e 선택
5. **d 계산**: ed ≡ 1 (mod φ(n))

#### 🧩 RSA 키 길이별 보안 강도

| 키 길이 | 보안 수준 | 권장 사용 |
|---------|-----------|-----------|
| **1024비트** | 낮음 | 사용 중단 권장 |
| **2048비트** | 중간 | 현재 표준 |
| **3072비트** | 높음 | 향후 10년 안전 |
| **4096비트** | 최고 | 장기간 보안 필요 시 |

#### 🧩 RSA 활용 분야
- **디지털 서명**: 문서 무결성 및 인증
- **키 교환**: 대칭키 안전 전송
- **SSL/TLS**: 웹 보안 통신
- **PKI**: 공개키 기반 구조
- **인증서**: 디지털 인증서 서명

#### 🧩 장점과 단점

| 장점 | 단점 |
|------|------|
| • 키 배송 문제 해결 | • 처리 속도 느림 |
| • 디지털 서명 지원 | • 키 크기가 큼 |
| • 표준화 및 호환성 | • 양자 컴퓨터 위험 |

#### 📝 기출 포맷 예시
- RSA 알고리즘의 수학적 기반은?
- RSA 2048비트의 보안 수준은?
- RSA의 주요 활용 분야는?

#### 🧠 용어 설명
- **RSA**: 최초의 실용적 공개키 암호화 알고리즘
- **소인수분해**: 큰 수를 소수의 곱으로 분해하는 문제
- **공개키**: 누구나 알 수 있는 암호화용 키
- **개인키**: 소유자만 알고 있는 복호화용 키

---

## 🔹 272. TKIP (Temporal Key Integrity Protocol)

#### 📘 정의
TKIP는 **WEP의 보안 취약점을 개선하기 위해 개발된 무선 네트워크 보안 프로토콜**이다.  
**WPA(Wi-Fi Protected Access)**에서 사용되며, **동적 키 생성과 무결성 검증**을 통해 무선 통신의 보안을 강화한다.

#### 🧩 주요 특징
- **키 길이**: 128비트 (WEP의 64비트에서 향상)
- **키 관리**: 동적 키 생성 및 주기적 키 변경
- **무결성 검증**: MIC(Message Integrity Check) 제공
- **암호화 방식**: RC4 스트림 암호화 기반
- **호환성**: 기존 WEP 하드웨어와 호환

#### 🧩 TKIP 보안 개선 사항

| 개선 영역 | WEP 문제점 | TKIP 해결책 |
|-----------|------------|-------------|
| **키 관리** | 정적 키 사용 | 동적 키 생성 및 갱신 |
| **키 혼합** | 키 재사용 | 패킷별 키 혼합 |
| **무결성** | CRC32 (취약) | MIC (강화된 무결성 검사) |
| **재전송 공격** | 방어 없음 | 시퀀스 번호 검증 |

#### 🧩 TKIP 동작 과정
1. **마스터 키 생성**: 인증 과정에서 생성
2. **키 혼합**: 패킷마다 고유한 키 생성
3. **암호화**: RC4로 데이터 암호화
4. **MIC 계산**: 무결성 검증 코드 생성
5. **전송**: 암호화된 데이터와 MIC 전송

#### 🧩 TKIP의 한계
- **RC4 기반**: 여전히 RC4의 취약점 존재
- **성능**: AES보다 상대적으로 느림
- **보안 강도**: WPA2/AES보다 약함
- **장기 사용**: 점진적 교체 권장

#### 📝 기출 포맷 예시
- TKIP가 개선한 WEP의 문제점은?
- TKIP에서 사용하는 암호화 방식은?
- MIC의 역할은 무엇인가?

#### 🧠 용어 설명
- **TKIP**: 임시 키 무결성 프로토콜
- **WPA**: Wi-Fi 보호 접근 (WEP 후속)
- **MIC**: 메시지 무결성 검사
- **Key Mixing**: 패킷별 고유 키 생성 기법

---

## 🔹 273. 해시 (Hash)

#### 📘 정의
해시는 **임의의 길이의 데이터를 고정된 길이의 값으로 변환하는 단방향 함수**이다.  
**입력 데이터의 무결성 검증, 디지털 서명, 패스워드 저장** 등에 사용되며, **역산이 불가능**한 특성을 가진다.

#### 🧩 해시 함수의 핵심 특성
- **결정적**: 동일한 입력은 항상 동일한 출력 생성
- **단방향**: 해시값으로부터 원본 데이터 복구 불가능
- **고정 길이**: 입력 크기에 상관없이 출력 크기 일정
- **쇄도 효과**: 입력의 작은 변화가 출력에 큰 변화 유발
- **충돌 저항**: 같은 해시값을 가지는 서로 다른 입력 찾기 어려움

#### 🧩 주요 해시 알고리즘

| 알고리즘 | 출력 크기 | 보안 상태 | 특징 |
|----------|-----------|-----------|------|
| **MD5** | 128비트 | 취약 | 빠른 속도, 현재 사용 중단 |
| **SHA-1** | 160비트 | 취약 | 과거 표준, 점진적 중단 |
| **SHA-256** | 256비트 | 안전 | 현재 표준, 비트코인 사용 |
| **SHA-512** | 512비트 | 안전 | 더 높은 보안 강도 |
| **SHA-3** | 가변 | 안전 | 최신 표준 (Keccak 기반) |

#### 🧩 해시 함수 활용 분야
- **무결성 검증**: 파일 변조 확인
- **디지털 서명**: 메시지 다이제스트 생성
- **패스워드 저장**: 원본 패스워드 대신 해시값 저장
- **블록체인**: 거래 검증 및 연결
- **데이터 구조**: 해시 테이블의 키 생성

#### 🧩 해시 공격 유형
- **충돌 공격**: 같은 해시값을 가지는 다른 입력 찾기
- **원상 공격**: 해시값으로부터 원본 데이터 찾기
- **제2 원상 공격**: 주어진 입력과 같은 해시값을 가지는 다른 입력 찾기

#### 📝 기출 포맷 예시
- 해시 함수의 특성으로 옳은 것은?
- 다음 중 안전한 해시 알고리즘은?
- 해시 함수의 활용 분야는?

#### 🧠 용어 설명
- **Hash Function**: 임의 길이 데이터를 고정 길이로 변환하는 함수
- **Message Digest**: 해시 함수의 출력값
- **Collision**: 서로 다른 입력이 같은 해시값을 가지는 현상
- **Avalanche Effect**: 입력의 작은 변화가 출력에 큰 영향을 주는 현상

---

## 🔹 274. SHA 시리즈 (Secure Hash Algorithm)

#### 📘 정의
SHA 시리즈는 **미국 NSA에서 개발하고 NIST에서 표준화한 암호화 해시 함수 집합**이다.  
**SHA-1부터 SHA-3까지** 다양한 버전이 있으며, **디지털 서명과 인증서에서 널리 사용**되는 보안 표준이다.

#### 🧩 SHA 시리즈 발전 과정

| 버전 | 개발 연도 | 출력 크기 | 보안 상태 | 특징 |
|------|-----------|-----------|-----------|------|
| **SHA-0** | 1993 | 160비트 | 취약 | 설계 결함으로 즉시 대체 |
| **SHA-1** | 1995 | 160비트 | 취약 | 2017년 충돌 공격 성공 |
| **SHA-2** | 2001 | 224/256/384/512비트 | 안전 | 현재 표준 |
| **SHA-3** | 2015 | 224/256/384/512비트 | 안전 | Keccak 기반 최신 표준 |

#### 🧩 SHA-2 세부 버전

| 알고리즘 | 출력 크기 | 블록 크기 | 라운드 수 | 주요 용도 |
|----------|-----------|-----------|-----------|-----------|
| **SHA-224** | 224비트 | 512비트 | 64 | 중간 보안 수준 |
| **SHA-256** | 256비트 | 512비트 | 64 | 표준 보안 수준 |
| **SHA-384** | 384비트 | 1024비트 | 80 | 높은 보안 수준 |
| **SHA-512** | 512비트 | 1024비트 | 80 | 최고 보안 수준 |

#### 🧩 SHA-256의 특징 (가장 널리 사용)
- **출력 크기**: 256비트 (64자리 16진수)
- **블록 크기**: 512비트
- **보안 강도**: 2^128 (매우 안전)
- **용도**: 비트코인, SSL/TLS, 디지털 서명

#### 🧩 SHA-3의 개선점
- **Keccak 구조**: 기존 SHA와 완전히 다른 내부 구조
- **스폰지 구조**: 임의 길이 출력 가능
- **양자 내성**: 양자 컴퓨터 공격에 더 강한 저항성
- **병렬 처리**: 하드웨어 구현에 최적화

#### 📝 기출 포맷 예시
- SHA-256의 출력 크기는?
- SHA-1과 SHA-2의 차이점은?
- SHA-3의 특징으로 옳은 것은?

#### 🧠 용어 설명
- **SHA**: 보안 해시 알고리즘
- **NIST**: 미국 국립표준기술연구소
- **Keccak**: SHA-3의 기반이 되는 해시 함수
- **Sponge Construction**: SHA-3에서 사용하는 구조 방식

---

## 🔹 275. MD5 (Message Digest Algorithm 5)

#### 📘 정의
MD5는 **1991년 MIT의 Ronald Rivest가 개발한 128비트 암호화 해시 함수**이다.  
**빠른 처리 속도**로 널리 사용되었으나, **충돌 공격에 취약**하여 현재는 보안 용도로 사용이 중단되었다.

#### 🧩 주요 특징
- **출력 크기**: 128비트 (32자리 16진수)
- **블록 크기**: 512비트
- **라운드 수**: 64라운드 (4개 단계 × 16라운드)
- **처리 속도**: 매우 빠름
- **개발자**: Ronald Rivest (RSA 공동 개발자)

#### 🧩 MD5 처리 과정
1. **패딩**: 메시지를 512비트 블록으로 맞춤
2. **초기화**: 4개의 32비트 상수로 초기화
3. **4단계 처리**: 각 단계마다 16라운드 수행
4. **결합**: 최종 128비트 해시값 생성

#### 🧩 MD5의 취약점
- **충돌 공격**: 2004년 중국 연구팀이 충돌 공격 성공
- **원상 공격**: 무차별 대입 공격에 취약
- **레인보우 테이블**: 미리 계산된 해시값 테이블 공격
- **MD5 해시 길이**: 128비트는 현재 기준으로 부족

#### 🧩 MD5 공격 사례
```
// 동일한 MD5 해시값을 가지는 서로 다른 파일 생성 가능
파일 A: d41d8cd98f00b204e9800998ecf8427e
파일 B: d41d8cd98f00b204e9800998ecf8427e (다른 내용)
```

#### 🧩 현재 사용 상황
- **보안 용도**: 사용 중단 (권장하지 않음)
- **비보안 용도**: 체크섬, 중복 파일 검사 등 제한적 사용
- **대안**: SHA-256, SHA-3 사용 권장

#### 📝 기출 포맷 예시
- MD5의 출력 크기는?
- MD5가 사용 중단된 이유는?
- MD5의 대안으로 권장되는 알고리즘은?

#### 🧠 용어 설명
- **MD5**: 메시지 다이제스트 알고리즘 5
- **Collision Attack**: 같은 해시값을 가지는 다른 입력을 찾는 공격
- **Rainbow Table**: 미리 계산된 해시값과 원본값의 대응 테이블
- **Checksum**: 데이터 무결성 검사를 위한 값