## 062. DBMS (Database Management System)

- [ ] **사용자와 데이터베이스 사이**에서 **데이터 효율적 관리** 소프트웨어 시스템
- [ ] **주요 기능**: 데이터 정의(DDL), 조작(DML), 제어(DCL), 트랜잭션 관리, 동시성 제어
- [ ] **무결성, 보안, 일관성, 공유성** 보장
- [ ] **데이터 독립성** 제공 (논리적/물리적)
- [ ] **ACID**: 원자성, 일관성, 고립성, 지속성

---

## 063. 스키마 (Schema)

- [ ] 데이터베이스의 **구조와 제약 조건 전반적 정의**를 나타내는 메타데이터
- [ ] **3계층 구조**: 외부 스키마(사용자 뷰) → 개념 스키마(전체 논리구조) → 내부 스키마(물리저장)
- [ ] **데이터 독립성** 제공 (구조 변경 시 응용 프로그램 영향 최소화)
- [ ] **논리적/물리적 구조** 분리하여 정의
- [ ] 하나의 개념 스키마에 **여러 외부 스키마** 매핑 가능

---

## 064. 데이터베이스 설계 순서

- [ ] **5단계**: 요구사항 분석 → 개념적 설계 → 논리적 설계 → 물리적 설계 → 구현
- [ ] **요구사항 분석**: 사용자 정보 요구 파악, 데이터 요구사항 수집
- [ ] **개념적 설계**: E-R 모델로 개체, 속성, 관계 추상화
- [ ] **논리적 설계**: 관계형 모델로 변환, 릴레이션 스키마 정의
- [ ] **물리적 설계**: 저장구조, 인덱스, 접근 경로 설계

---

## 065. 개념적 설계

- [ ] **현실 세계 데이터**를 **개체, 속성, 관계**로 추상적 표현
- [ ] **E-R 모델(E-R 다이어그램)** 작성하여 데이터 구조 정의
- [ ] **스키마 모델링과 트랜잭션 모델링** 병행 수행
- [ ] **사용자 관점 중심** 추상적 설계, **DBMS 종속되지 않는** 중립적 모델링
- [ ] 논리적 설계의 입력으로 활용

---

## 066. 논리적 설계

- [ ] **개념적 설계**를 **관계형 데이터베이스 구조**로 변환
- [ ] **릴레이션 스키마 정의**, 속성 및 키 정의, **정규화 수행**
- [ ] **무결성 제약조건 설정** (개체, 참조 무결성)
- [ ] **트랜잭션 분석 및 설계** (CRUD 기능 고려)
- [ ] **DBMS에 맞는 논리적 모델**로 구조화

---

## 067. 물리적 설계

- [ ] **논리적 설계**를 **실제 DBMS 환경**에 적합한 저장 구조로 정의
- [ ] **테이블 및 인덱스 물리 구조**, **저장소 구성**, **접근 경로 설계**
- [ ] **보안 및 권한 설정**, **백업 및 회복 전략** 정의
- [ ] **성능, 저장 효율, 보안, 회복성** 종합 고려
- [ ] DBMS 종류와 하드웨어 환경 **고려한 최적화** 설계

---

## 068. 데이터 모델 (Data Model)

- [ ] **현실 세계 데이터**를 컴퓨터에 표현하기 위한 **논리적 구조와 규칙 집합**
- [ ] **3가지 구성요소**: 구조(Structure), 연산(Operation), 제약조건(Constraint)
- [ ] **3가지 종류**: 개념적 모델(E-R), 논리적 모델(관계), 물리적 모델(파일구조)
- [ ] **단순화 추상화**하여 체계적 표현
- [ ] 데이터베이스 설계의 기반 제공

---

## 069. E-R 다이어그램 (Entity-Relationship Diagram)

- [ ] **개체, 속성, 관계**로 현실 세계 데이터 표현하는 개념적 모델링 도구
- [ ] **구성요소**: 개체(사각형), 속성(타원), 관계(마름모), 식별자(밑줄), 차수(1:1, 1:N, N:M)
- [ ] **기본키**(밑줄 친 타원), **다중값 속성**(이중 타원), **복합 속성**(분기된 타원)
- [ ] **사용자 요구**를 시각적으로 표현, **논리적 설계로 변환** 용이
- [ ] 개념적 설계의 대표 모델

---

## 070. 관계형 데이터베이스의 릴레이션 구조

- [ ] 데이터를 **릴레이션(테이블) 형태**로 저장, **행(튜플)과 열(속성)**으로 구성
- [ ] **구성요소**: 릴레이션, 튜플(행), 속성(열), 도메인, 카디널리티(행 수), 차수(열 수)
- [ ] **릴레이션 스키마**(구조) + **릴레이션 인스턴스**(실제 값)
- [ ] **튜플 중복 불가**, **순서 의미 없음**, **속성 값은 원자값**
- [ ] 릴레이션 간 관계는 **외래키(FK)**로 표현

---

## 071. 튜플 (Tuple)

- [ ] **릴레이션의 한 행(Row)**에 해당하는 데이터 단위, **하나의 레코드**
- [ ] **속성 집합**으로 구성, **릴레이션의 카디널리티** 결정
- [ ] **중복 불가**, **순서 무의미**, **원자값(Atomic Value)**으로 구성
- [ ] 하나의 튜플은 **한 개체나 사건에 대한 정보** 표현
- [ ] 릴레이션의 레코드 수 = **카디널리티**

---

## 072. 속성 (Attribute)

- [ ] **데이터베이스 구성하는 가장 작은 논리적 단위**, 릴레이션의 **열(Column)**
- [ ] **종류**: 단일값/다중값, 원자값/복합, 기본/유도, 기본키/외래키 속성
- [ ] **개체의 특성을 기술**하는 요소
- [ ] 속성의 수 = **디그리(Degree, 차수)**
- [ ] 각 속성은 **고유한 도메인** 가짐

---

## 073. 도메인 (Domain)

- [ ] **속성이 가질 수 있는 값들의 논리적 집합** 또는 범위
- [ ] **원자값의 타입과 제약조건** 정의, **속성의 유효값 제한**
- [ ] **하나의 속성 = 하나의 도메인** 원칙
- [ ] **데이터 무결성 보장**에 필수, **유효성 검사 기준**
- [ ] SQL에서 CHECK 제약조건 등으로 표현

---

## 074. 후보키 (Candidate Key)

- [ ] **튜플을 유일하게 식별**할 수 있는 속성 집합 중 **유일성과 최소성** 만족
- [ ] **기본키가 될 수 있는 후보**들
- [ ] **유일성**(모든 튜플 구분 가능) + **최소성**(불필요한 속성 포함 없음)
- [ ] 하나의 릴레이션에 **여러 개 존재** 가능
- [ ] 후보키 중 **1개 선택 → 기본키**, 나머지 → 대체키

---

## 075. 기본키 (Primary Key)

- [ ] **후보키 중 선택된 대표 키**, 각 튜플을 **유일하게 식별**
- [ ] **중복 불가 + NULL 불가** (무결성 보장)
- [ ] **1개 릴레이션에 기본키는 반드시 1개** 존재
- [ ] **기본적으로 인덱스 생성**됨
- [ ] **복합 기본키**(속성 2개 이상 조합) 가능

---

## 077. 슈퍼키 (Super Key)

- [ ] **튜플을 유일하게 식별**할 수 있는 하나 이상의 **속성 집합**
- [ ] **유일성 O**, **최소성 X** (중복 속성 포함해도 가능)
- [ ] **가장 넓은 키의 개념**, 후보키·기본키를 포함하는 상위 집합
- [ ] **슈퍼키 ⊇ 후보키 ⊇ 기본키** 관계
- [ ] 여러 개 존재 가능

---

## 078. 외래키 (Foreign Key)

- [ ] **다른 릴레이션의 기본키를 참조**하는 속성
- [ ] **릴레이션 간 관계 표현**, **참조 무결성** 유지
- [ ] **중복 허용**, **NULL 허용** 가능 (상황에 따라)
- [ ] **ON DELETE/ON UPDATE** 제약조건 활용 가능
- [ ] 하위 릴레이션(자식)이 상위 릴레이션(부모) 기본키 참조

---

## 079. 무결성 (Integrity)

- [ ] **데이터의 정확성, 일관성, 신뢰성** 유지하기 위한 제약조건
- [ ] **4가지 유형**: 개체(기본키 NULL/중복 금지), 참조(외래키 존재), 도메인(값 범위), 사용자 정의
- [ ] **제약조건을 통해 데이터 오류 예방**
- [ ] 설계 단계에서 정의 → DBMS가 자동 검사
- [ ] SQL의 PRIMARY KEY, FOREIGN KEY, CHECK, NOT NULL로 구현

---

## 080. 관계대수 (Relational Algebra)

- [ ] **연산자를 이용하여 릴레이션 조작**하는 **절차적 질의 언어**
- [ ] **입력 릴레이션에 연산 적용**하여 **새로운 릴레이션 생성**
- [ ] **순수 관계 연산자**: SELECT(σ), PROJECT(π), RENAME(ρ)
- [ ] **파생 관계 연산자**: JOIN(⨝), UNION(∪), INTERSECTION(∩), DIFFERENCE(-)
- [ ] **어떤 순서로** 데이터를 추출할지 명시하는 절차적 언어

---

## 081. 관계대수 연산자 분류

- [ ] **순수 관계 연산자**(기본): SELECT(σ), PROJECT(π), RENAME(ρ) - **1개 릴레이션**에 적용
- [ ] **파생 관계 연산자**(응용): JOIN(⨝), DIVISION(÷), UNION(∪), INTERSECTION(∩), DIFFERENCE(-), CARTESIAN PRODUCT(×)
- [ ] **파생 연산자는 2개 이상 릴레이션** 필요 (이항 연산)
- [ ] **DIVISION은 파생 연산자**, 순수 관계 연산자 아님
- [ ] SELECT는 **수평적 선택**(행), PROJECT는 **수직적 선택**(열)

---

## 082. 일반 집합 연산자 (합집합, 교집합, 차집합, 교차곱)

- [ ] **합집합(∪)**: 모든 튜플 포함하되 **중복 제거**
- [ ] **교집합(∩)**: **공통으로 존재하는 튜플**만 반환
- [ ] **차집합(-)**: 첫 번째 릴레이션에만 존재하는 튜플
- [ ] **교차곱(×)**: **모든 튜플 쌍을 조합**하여 결과 생성
- [ ] **합집합 호환 조건**: 디그리 같고, 각 속성의 **도메인 동일**해야 함

---

## 083. 관계해석 (Relational Calculus)

- [ ] **무엇을 추출할지** 선언적으로 기술하는 **비절차적 질의 언어**
- [ ] **2가지 종류**: 튜플 관계해석(TRC), 도메인 관계해석(DRC)
- [ ] **조건 기반으로 결과 기술**, 절차 명시하지 않음
- [ ] **관계대수와 동일한 표현 능력** (튜링 등가)
- [ ] 원하는 정보의 조건만 명시, **시스템이 수행 방법 결정**

---

## 084. 이상 (Anomaly)

- [ ] **데이터 중복/종속성**으로 인한 **비정상적 현상**
- [ ] **삽입 이상**: 불필요한 다른 정보도 함께 저장해야 하는 문제
- [ ] **삭제 이상**: 의도치 않은 다른 정보까지 함께 삭제되는 문제
- [ ] **갱신 이상**: 중복 데이터의 **일관성 유지 어려운** 문제
- [ ] **정규화를 통해 이상 제거** 가능

---

## 085. 함수적 종속 (Functional Dependency)

- [ ] **하나의 속성 값이 다른 속성 값을 유일하게 결정**하는 관계 (X → Y)
- [ ] **완전 함수적 종속**: 기본키 전체에 종속
- [ ] **부분 함수적 종속**: 기본키 일부에만 종속
- [ ] **이행적 함수적 종속**: 중간 속성 통해 간접 종속
- [ ] **암스트롱 공리**: 반사성, 증강성, 이행성

---

## 086. 정규화 (Normalization)

- [ ] **데이터 중복 제거**, **삽입·삭제·갱신 이상 방지**를 위한 릴레이션 구조 개선
- [ ] **1NF**: 원자값 → **2NF**: 부분 함수적 종속 제거 → **3NF**: 이행적 함수적 종속 제거
- [ ] **BCNF**: 모든 결정자가 후보키 → **4NF**: 다치 종속 제거 → **5NF**: 조인 종속 제거
- [ ] **중복 제거 및 이상 현상 방지**
- [ ] **데이터 정합성, 무결성 향상**

---

## 087. 정규화 과정 (1NF ~ 5NF)

- [ ] **1NF**: 모든 속성값이 **원자값**, 반복 그룹 제거
- [ ] **2NF**: 1NF + **부분 함수 종속 제거** (복합키 일부 종속 해결)
- [ ] **3NF**: 2NF + **이행적 함수 종속 제거** (기본키↔속성 구조 단순화)
- [ ] **BCNF**: 3NF + **모든 결정자가 후보키**
- [ ] **4NF**: BCNF + **다치 종속 제거**, **5NF**: 4NF + **조인 종속 제거**

---

## 088. 정규화 과정 정리

- [ ] **중복 제거와 이상 현상 방지**로 **데이터 일관성과 무결성** 보장
- [ ] **1NF**(원자값) → **2NF**(부분 종속) → **3NF**(이행 종속) → **BCNF**(결정자) → **4NF**(다치) → **5NF**(조인)
- [ ] **각 단계는 이전 단계 포함**하면서 상위 수준으로 발전
- [ ] **부분/이행/다치/조인 종속성**을 단계적으로 제거
- [ ] 정규형이 높아질수록 **설계 복잡성 증가**

---

## 089. 반정규화 (Denormalization)

- [ ] **정규화된 릴레이션을 의도적으로 통합**하여 **성능 향상**시키는 과정
- [ ] **목적**: 조인 연산 최소화, 검색 성능 향상, 응답 시간 단축
- [ ] **유형**: 테이블 병합, 중복 속성 추가, 중복 테이블 추가, 파티셔닝
- [ ] **적용 시점**: 응답 속도 느림, 과도한 조인 발생, 실시간 집계 많음
- [ ] **복잡한 조인, 조회 성능 저하** 해결

---

## 090. 중복 테이블 추가

- [ ] **반정규화 기법**으로 **자주 사용되는 조회 결과나 통계 데이터**를 별도 저장
- [ ] **3가지 방법**: 집계 테이블 추가, 진행 테이블 추가, 특정 부분만 포함 테이블 추가
- [ ] **목적**: 복잡한 조인 제거, 조회 성능 향상, 집계 정보 제공 용이
- [ ] **예시**: 매출 요약, 회원 현황, 조회수 테이블
- [ ] **데이터 중복을 통해 조인 연산 줄이고** 성능 향상

---

## 091. 시스템 카탈로그 (System Catalog)

- [ ] **DBMS가 내부적으로 유지하는 메타데이터 저장소**, **데이터 사전**이라고도 함
- [ ] **저장 정보**: 객체 정의, 접근 권한, 구조 정보, 사용 통계, DB 구성 정보
- [ ] **DBMS가 자동 생성하고 관리**, 일반 사용자는 **조회만 가능**
- [ ] **DB 관리, 질의 최적화, 보안 처리**에 사용
- [ ] **시스템 테이블**로 구현, SELECT문으로 확인 가능

---

## 092. 트랜잭션 (Transaction)

- [ ] **데이터베이스에서 하나의 논리적 작업 단위**
- [ ] **모두 성공하거나 전부 실패**해야 하는 최소 단위
- [ ] **주요 명령**: BEGIN(시작), COMMIT(완료 반영), ROLLBACK(취소 복구)
- [ ] **목적**: 데이터 정합성 유지, 원자적 처리 보장, 시스템 장애 대비
- [ ] **동시성 환경**에서 데이터 불일치 방지

---

## 093. 트랜잭션의 특성 (ACID)

- [ ] **원자성(Atomicity)**: 모두 실행되거나 전혀 실행되지 않음
- [ ] **일관성(Consistency)**: 트랜잭션 전후 데이터베이스 상태 일관성 유지
- [ ] **독립성/격리성(Isolation)**: 동시 실행되는 트랜잭션들이 서로 간섭하지 않음
- [ ] **지속성(Durability)**: 완료된 결과는 **영구적으로 저장**
- [ ] **트랜잭션 상태**: 활동 → 부분완료 → 완료 또는 실패 → 철회

---

## 094. CRUD 분석

- [ ] **Create, Read, Update, Delete** 연산을 분석하여 **트랜잭션 흐름** 파악
- [ ] **프로세스와 테이블 간 CRUD 매트릭스** 작성
- [ ] **목적**: 업무 기능별 데이터 사용 현황, 테이블별 사용 빈도 분석
- [ ] **업무 기능**(행) × **테이블**(열) 교차점에 CRUD 연산 표시
- [ ] **데이터 중심 트랜잭션 설계** 근거 확보

---

## 095. 인덱스 (Index)

- [ ] **데이터 검색 속도 향상**을 위한 **보조적 데이터 구조**
- [ ] **구성**: 인덱스 키(기준 컬럼) + 포인터(실제 데이터 위치)
- [ ] **종류**: 단일/복합, 고유/비고유, 클러스터드/넌클러스터드
- [ ] **클러스터드**: 실제 데이터가 인덱스 순서대로 정렬 저장
- [ ] **장점**: 검색 성능 향상, **단점**: 삽입·삭제·갱신 시 오버헤드