### 062. DBMS (Database Management System)

#### 📘 정의
DBMS는 **사용자와 데이터베이스 사이에서 데이터를 효율적으로 관리하고 접근할 수 있도록 지원하는 소프트웨어 시스템**이다.  
데이터의 **정의, 저장, 검색, 갱신, 삭제** 등의 작업을 수행하며, **데이터 무결성, 보안, 동시성, 회복 기능**을 제공한다.

#### 🧩 주요 기능

| 기능 | 설명 |
|------|------|
| **데이터 정의 기능 (DDL)** | 데이터 구조를 정의 (테이블, 인덱스 등) |
| **데이터 조작 기능 (DML)** | 데이터 조회, 삽입, 삭제, 갱신 |
| **데이터 제어 기능 (DCL)** | 사용자 권한 제어 및 보안 관리 |
| **트랜잭션 관리** | 여러 작업을 하나의 논리적 단위로 처리, 장애 발생 시 복구 지원 |
| **동시성 제어** | 다중 사용자 환경에서 데이터 일관성 유지 |
| **무결성 유지** | 데이터 정확성과 일관성 보장 (제약조건 등) |

#### 🧩 특징 요약

- **데이터 독립성** 제공 (논리적/물리적 독립성)
- **중복 최소화**, **일관성 유지**
- **보안 및 권한 관리** 기능 내장
- **표준화된 질의어(SQL)** 사용

#### 📝 기출 포맷 예시

- DBMS의 **주요 기능이 아닌 것**은?
- 다음 중 DBMS가 제공하는 **데이터 제어 기능(DCL)**에 해당하는 것은?
- DBMS의 **장점 또는 특징**으로 적절한 것은?

#### 🧠 용어 설명

- **DBMS**: 데이터베이스 관리 시스템
- **DDL/DML/DCL**: 정의/조작/제어 언어
- **데이터 독립성**: 응용 프로그램이 데이터 구조 변경의 영향을 받지 않는 성질
- **트랜잭션**: 하나의 논리적 작업 단위 (ACID 보장)
- **ACID**: 트랜잭션의 4가지 특성으로, 데이터베이스의 신뢰성과 일관성을 보장하기 위한 기준
    - **Atomicity (원자성)**: 트랜잭션의 작업이 모두 수행되거나 전혀 수행되지 않아야 함
    - **Consistency (일관성)**: 트랜잭션 수행 전후 데이터베이스가 항상 일관된 상태 유지
    - **Isolation (고립성)**: 동시에 실행되는 트랜잭션들이 서로 간섭하지 않도록 보장
    - **Durability (지속성)**: 트랜잭션 완료 후 그 결과는 영구적으로 반영되어야 함

---

### 063. 스키마 (Schema)

#### 📘 정의
스키마는 **데이터베이스의 구조와 제약 조건에 대한 전반적인 정의를 나타내는 메타데이터**이다.  
즉, 데이터베이스에 저장될 데이터의 **논리적 구조를 정의한 설계도**로,  
데이터의 타입, 제약조건, 관계 등을 명세한다.

#### 🧩 스키마 3계층 구조

| 계층 | 설명 |
|------|------|
| **외부 스키마 (External Schema)** | 사용자 또는 응용 프로그램 관점의 개별 뷰(뷰 스키마) |
| **개념 스키마 (Conceptual Schema)** | 전체 데이터베이스의 논리적 구조를 정의 (중앙 설계도) |
| **내부 스키마 (Internal Schema)** | 물리적 저장 장치에 데이터가 실제 저장되는 방식 정의 |

#### 🧩 특징 요약

- 데이터베이스의 **논리적/물리적 구조를 구분하여 정의**
- **사용자 관점과 시스템 관점을 분리**하여 데이터 독립성 제공
- 하나의 개념 스키마에 여러 외부 스키마가 매핑될 수 있음
- 내부 구조 변경 시 외부 사용자에 영향을 주지 않음 (물리적 데이터 독립성)

#### 📝 기출 포맷 예시

- 스키마의 **3계층 구조에 대한 설명**으로 옳은 것은?
- 다음 중 **외부 스키마의 특징**으로 적절한 것은?
- **개념 스키마와 내부 스키마**의 역할로 옳은 것은?

#### 🧠 용어 설명

- **스키마(Schema)**: 데이터베이스 구조와 제약 조건의 정의
- **외부 스키마**: 사용자 맞춤 뷰 정의
- **개념 스키마**: 전체 데이터의 논리적 설계
- **내부 스키마**: 데이터 저장 방식 정의
- **데이터 독립성**: 구조 변경 시 응용 프로그램 영향 최소화

---

### 064. 데이터베이스 설계 순서

#### 📘 정의
데이터베이스 설계는 **현실 세계의 데이터를 체계적이고 구조적으로 표현하기 위해 단계적으로 수행되는 과정**이다.  
요구사항 분석부터 시작하여 개념적 → 논리적 → 물리적 설계로 이어지는 일련의 과정을 따른다.

#### 🧩 설계 순서

| 단계 | 설명 |
|------|------|
| **요구사항 분석** | 사용자의 정보 요구를 파악하고 데이터 요구사항 수집 |
| **개념적 설계** | E-R 모델 등을 사용해 개체, 속성, 관계 등을 추상화 |
| **논리적 설계** | 개념적 설계를 관계형 모델로 변환 (릴레이션 스키마 정의 등) |
| **물리적 설계** | 실제 저장구조, 인덱스, 접근 경로 등을 고려한 저장 방식 설계 |
| **구현** | 설계 내용을 DBMS에 적용하여 실제 데이터베이스로 구축 |

#### 🧩 특징 요약

- **사용자 요구사항 → 시스템 구현**까지 구조적으로 설계
- 상위 설계 결과가 **하위 설계 단계의 입력**이 됨
- **정규화, 무결성, 성능 고려 사항**이 논리/물리 단계에 반영됨

#### 📝 기출 포맷 예시

- 데이터베이스 설계 순서로 **가장 올바른 것은?**
- 다음 중 **논리적 설계 단계에서 수행하는 작업**은?
- 물리적 설계에서 고려할 요소로 **적절하지 않은 것**은?

#### 🧠 용어 설명

- **개념적 설계**: 현실 세계의 데이터를 개념 모델로 추상화
- **논리적 설계**: 관계형 모델로 변환하고 정규화 수행
- **물리적 설계**: 저장 구조 및 성능을 고려한 물리적 구현

---


### 065. 개념적 설계

#### 📘 정의
개념적 설계는 **현실 세계의 데이터를 개체(Entity), 속성(Attribute), 관계(Relationship) 등의 추상적 개념으로 표현**하는 단계이다.  
사용자 요구사항을 바탕으로 **E-R 모델(E-R 다이어그램)**을 작성하여 데이터 구조를 정의한다.

#### 🧩 주요 작업

| 작업 | 설명 |
|------|------|
| **개체 추출** | 관리 대상 실체(사람, 사물, 개념 등)를 개체로 식별 |
| **속성 정의** | 개체가 가지는 특성(이름, 번호, 날짜 등)을 속성으로 정의 |
| **관계 정의** | 개체 간 상호 연관성을 관계로 표현 |
| **식별자 설정** | 각 개체를 구분하기 위한 기본키 후보 결정 |
| **제약 조건 명세** | 관계의 수(1:1, 1:N 등), 참여 조건 등 제약 설정 |

#### 🧩 특징 요약

- **사용자 관점 중심의 추상적 설계**
- DBMS 종류에 **종속되지 않는 중립적 모델링**
- **E-R 모델 기반 시각적 표현 가능**
- 논리적 설계의 입력으로 활용됨

#### 📝 기출 포맷 예시

- 개념적 설계에서 수행되는 **주요 활동**으로 옳은 것은?
- 개념적 설계의 **산출물로 가장 적절한 것**은?
- 다음 중 **개체와 관계의 정의 예**로 알맞은 것은?

#### 🧠 용어 설명

- **개념적 설계**: 추상적 데이터 구조 정의 단계
- **E-R 모델**: 개체-관계 모델, 개념적 설계의 핵심 도구
- **개체(Entity)**: 관리 대상 실체
- **속성(Attribute)**: 개체의 특성 정보
- **관계(Relationship)**: 개체 간 연관성

---

### 065. 개념적 설계

#### 📘 정의
개념적 설계는 **현실 세계의 데이터를 개체(Entity), 속성(Attribute), 관계(Relationship) 등의 추상적 개념으로 표현**하는 단계이다.  
사용자 요구사항을 바탕으로 **E-R 모델(E-R 다이어그램)**을 작성하여 데이터 구조를 정의한다.
스키마 모델링과 트랜잭션 모델링을 병행 수행한다
#### 🧩 주요 작업

| 작업 | 설명 |
|------|------|
| **개체 추출** | 관리 대상 실체(사람, 사물, 개념 등)를 개체로 식별 |
| **속성 정의** | 개체가 가지는 특성(이름, 번호, 날짜 등)을 속성으로 정의 |
| **관계 정의** | 개체 간 상호 연관성을 관계로 표현 |
| **식별자 설정** | 각 개체를 구분하기 위한 기본키 후보 결정 |
| **제약 조건 명세** | 관계의 수(1:1, 1:N 등), 참여 조건 등 제약 설정 |

#### 🧩 특징 요약

- **사용자 관점 중심의 추상적 설계**
- DBMS 종류에 **종속되지 않는 중립적 모델링**
- **E-R 모델 기반 시각적 표현 가능**
- 논리적 설계의 입력으로 활용됨

#### 📝 기출 포맷 예시

- 개념적 설계에서 수행되는 **주요 활동**으로 옳은 것은?
- 개념적 설계의 **산출물로 가장 적절한 것**은?
- 다음 중 **개체와 관계의 정의 예**로 알맞은 것은?

#### 🧠 용어 설명

- **개념적 설계**: 추상적 데이터 구조 정의 단계
- **E-R 모델**: 개체-관계 모델, 개념적 설계의 핵심 도구
- **개체(Entity)**: 관리 대상 실체
- **속성(Attribute)**: 개체의 특성 정보
- **관계(Relationship)**: 개체 간 연관성

---

### 066. 논리적 설계

#### 📘 정의
논리적 설계는 **개념적 설계를 바탕으로 관계형 데이터베이스 구조로 변환**하는 단계이다.  
개체와 관계를 **릴레이션(Relation) 형태로 표현**하고, **정규화, 무결성 제약조건 설정, 키 정의** 등을 수행한다.

#### 🧩 주요 작업

| 작업 | 설명 |
|------|------|
| **릴레이션 스키마 정의** | 개체 및 관계를 테이블 형태로 전환 |
| **속성 및 키 정의** | 기본키, 외래키, 후보키 등을 식별 |
| **정규화 수행** | 데이터 중복 제거 및 이상 현상 방지를 위한 구조 개선 |
| **무결성 제약조건 설정** | 개체 무결성, 참조 무결성 등 제약조건 정의 |
| **트랜잭션 분석 및 설계** | CRUD 기능을 고려한 데이터 연산 구조 설계 |

#### 🧩 특징 요약

- **DBMS에 맞는 논리적 모델**로 구조화
- **데이터 정합성과 무결성 확보**
- 개념적 설계와 **물리적 설계 사이의 중간 단계**
- 정규화를 통해 **중복 최소화, 이상 제거**

#### 📝 기출 포맷 예시

- 논리적 설계 단계에서 **수행되는 작업**으로 옳은 것은?
- 다음 중 **정규화의 목적**으로 적절한 것은?
- 논리적 설계에서 고려되는 **제약조건 종류**는?

#### 🧠 용어 설명

- **논리적 설계**: 데이터 구조를 릴레이션으로 논리 변환하는 설계
- **릴레이션(Relation)**: 테이블 형식의 데이터 구조
- **정규화(Normalization)**: 데이터 구조를 정제하여 중복과 이상 방지
- **무결성 제약조건**: 데이터의 정확성과 일관성 보장 규칙

---

### 067. 물리적 설계

#### 📘 정의
물리적 설계는 **논리적 설계 결과를 기반으로 실제 DBMS 환경에 적합한 저장 구조와 접근 경로를 정의하는 단계**이다.  
성능, 저장 효율, 보안, 회복성 등을 고려하여 **데이터의 물리적 저장 방식**을 구체적으로 결정한다.

#### 🧩 주요 작업

| 작업 | 설명 |
|------|------|
| **테이블 및 인덱스 물리 구조 정의** | 데이터 유형, 길이, 저장 형식 등 설정 |
| **저장소 구성** | 테이블스페이스, 파일 구성, 파티셔닝 등 물리적 저장 위치 정의 |
| **접근 경로 설계** | 인덱스, 뷰 등을 통한 빠른 데이터 검색 경로 설정 |
| **보안 및 권한 설정** | 사용자별 접근 권한 및 암호화 적용 |
| **백업 및 회복 전략 정의** | 장애 대비 데이터 백업 및 복구 방식 설계 |

#### 🧩 특징 요약

- DBMS 종류와 하드웨어 환경을 **고려한 최적화 설계**
- 성능, 보안, 회복성 등을 종합적으로 반영
- **논리적 설계의 구현 가능성 확보**
- 실제 데이터 저장 구조 결정

#### 📝 기출 포맷 예시

- 물리적 설계 단계에서 **수행하는 작업**으로 적절한 것은?
- 다음 중 **접근 경로(인덱스) 설계의 목적**으로 옳은 것은?
- 물리적 설계에서 고려할 요소가 **아닌 것**은?

#### 🧠 용어 설명

- **물리적 설계**: 데이터를 실제로 어떻게 저장하고 접근할지 정의하는 설계
- **접근 경로**: 데이터를 빠르게 찾기 위한 인덱스 등의 구조
- **테이블스페이스**: DBMS가 데이터를 저장하는 물리적 공간 단위
- **백업/회복**: 장애 발생 시 데이터를 복원하는 기능

---

### 068. 데이터 모델 (Data Model)

#### 📘 정의
데이터 모델은 **현실 세계의 데이터를 컴퓨터에 표현하기 위한 논리적 구조와 규칙의 집합**이다.  
데이터의 구조, 연산, 제약조건 등을 정의하여  
**데이터베이스 설계의 기반을 제공**하고, **일관성 있고 정확한 데이터 표현**을 가능하게 한다.
- 단순화 추상화하여 체계적으로 표현

#### 🧩 구성 요소

| 구성 요소 | 설명 |
|-----------|------|
| **구조 (Structure)** | 데이터 간의 논리적 연결 형태 (예: 테이블, 필드, 관계 등) |
| **연산 (Operation)** | 데이터 검색, 삽입, 삭제, 갱신 등 허용되는 조작 |
| **제약조건 (Constraint)** | 데이터 정확성과 일관성 유지를 위한 규칙 (예: 도메인 제약, 키 제약 등) |

#### 🧩 종류

| 모델 유형 | 설명 |
|-----------|------|
| **개념적 모델** | 사용자 관점에서 데이터 요구를 추상화 (예: E-R 모델) |
| **논리적 모델** | 개념적 모델을 DBMS 독립적인 구조로 표현 (예: 관계 모델) |
| **물리적 모델** | 실제 데이터 저장 및 접근 방법 정의 (예: 파일 구조, 인덱스) |

#### 🧩 특징 요약

- **데이터 구조와 관계를 체계적으로 정의**
- 설계 전 단계에서 **일관된 데이터 표현 가능**
- **개념 → 논리 → 물리**로 이어지는 설계 흐름의 기반
- 데이터 무결성과 정확성을 보장하는 제약조건 포함

#### 📝 기출 포맷 예시

- 데이터 모델의 **구성 요소**로 적절하지 않은 것은?
- 다음 중 **개념적/논리적/물리적 모델의 설명**으로 옳은 것은?
- 데이터 모델에서 **제약조건의 역할**로 알맞은 것은?

#### 🧠 용어 설명

- **데이터 모델**: 데이터 표현을 위한 구조, 연산, 제약의 체계
- **개념적 모델**: 현실 세계를 추상화한 사용자 관점 모델
- **논리적 모델**: 개념 모델을 논리적 구조로 정제
- **물리적 모델**: 실제 저장과 접근 방식 정의
- **제약조건**: 데이터의 정확성과 일관성을 위한 규칙

---

### 069. E-R 다이어그램 (Entity-Relationship Diagram)

#### 📘 정의
E-R 다이어그램은 **현실 세계의 데이터를 개체(Entity), 속성(Attribute), 관계(Relationship)로 표현하는 개념적 모델링 도구**이다.  
시각적으로 데이터 구조를 표현하여 **데이터베이스 설계의 기반이 되는 개념적 구조**를 명확히 파악할 수 있게 한다.

#### 🧩 주요 구성 요소

| 요소 | 설명 |
|------|------|
| **개체(Entity)** | 독립적으로 존재하는 객체 (사람, 사물 등) |
| **속성(Attribute)** | 개체가 가지는 특성 (예: 이름, 생년월일 등) |
| **관계(Relationship)** | 개체 간의 연관성 (예: 수강, 소속 등) |
| **식별자(Key)** | 개체를 유일하게 식별하는 속성 |
| **차수(Degree)** | 관계에 참여하는 개체 수 (1:1, 1:N, N:M) |

#### 🧩 표현 기호

| 구성 요소       | 기호       |
|-------------|----------|
| **개체**      | 사각형      |
| **속성**      | 타원       |
| **관계**      | 마름모      |
| **연결선**     | 선(Line)  |
| **기본키**     | 밑줄 친 타원  |
| **다중값 속성**  | 이중 타원    |
| **복합 속성**   | 분기된 타원 구조 |
| **관계 대응 수** | 관계 N : M |

#### 🧩 특징 요약

- **사용자 요구를 시각적으로 표현**하여 데이터 구조 설계에 도움
- **논리적 설계로 변환이 용이**
- 데이터 간의 **연관성 파악이 직관적**

#### 📝 기출 포맷 예시

- E-R 다이어그램에서 **개체와 관계의 표현 기호**로 옳은 것은?
- 다음 중 **E-R 모델의 구성 요소**가 아닌 것은?
- E-R 다이어그램에서 **차수(Degree)** 의미로 적절한 것은?

#### 🧠 용어 설명

- **E-R 모델**: 개체-관계 모델, 개념적 설계의 대표 모델
- **개체(Entity)**: 현실 세계의 객체
- **속성(Attribute)**: 개체의 특성
- **관계(Relationship)**: 개체 간의 연관
- **차수(Degree)**: 관계에 참여하는 개체 수

---

### 070. 관계형 데이터베이스의 릴레이션 구조

#### 📘 정의
관계형 데이터베이스는 데이터를 **릴레이션(Relation, 관계)** 형태로 저장하며,  
릴레이션은 **행(Row, 튜플)과 열(Column, 속성)**로 구성된 **2차원 테이블 구조**를 가진다.  
데이터 간 관계는 **공통 속성(외래키 등)을 통해 표현**된다.
-> 아무튼 구조를 나타내는 릴레이션 스키마와 값들인 릴레이션 인스턴트로 구정

#### 🧩 릴레이션 구성 요소

| 구성 요소                  | 설명                        |
|------------------------|---------------------------|
| **릴레이션(Relation)**     | 테이블 형태의 데이터 구조 (관계)       |
| **튜플(Tuple)**          | 릴레이션의 한 행(Row), 하나의 레코드   |
| **속성(Attribute)**      | 릴레이션의 한 열(Column), 하나의 필드 |
| **도메인(Domain)**        | 속성이 가질 수 있는 값의 범위         |
| **카디널리티(Cardinality)** | 튜플의 개수 (Row 수)            |
| **차수(Degree)**         | 속성의 개수 (Column 수)         |
| **릴레이션 인스턴스**          | 타입이 정의되어 구체적인 값은 가진 것    |

#### 🧩 특징 요약

- **모든 데이터는 테이블(릴레이션) 형태로 저장**
- **한 릴레이션 내 튜플은 중복될 수 없음**
- **튜플의 순서는 의미 없음**
- **속성 값은 원자값(Atomic Value)**을 가짐
- **릴레이션 간 관계는 외래키(FK)로 표현**

#### 📝 기출 포맷 예시

- 관계형 데이터베이스에서 **튜플과 속성**의 정의로 적절한 것은?
- 릴레이션의 구성 요소 중 **도메인**에 대한 설명으로 옳은 것은?
- 다음 중 **릴레이션의 특징**으로 맞는 것을 모두 고른 것은?

#### 🧠 용어 설명

- **릴레이션**: 관계형 모델의 기본 단위인 2차원 테이블
- **튜플**: 릴레이션의 각 행, 데이터 한 건
- **속성**: 릴레이션의 각 열, 데이터 항목
- **도메인**: 속성이 가질 수 있는 값의 범위
- **카디널리티**: 릴레이션에 포함된 튜플의 수
- **차수**: 릴레이션에 정의된 속성의 수

---

### 071. 튜플 (Tuple)

#### 📘 정의
튜플은 **릴레이션(테이블)의 한 행(Row)에 해당하는 데이터 단위**로,  
**하나의 레코드(Record)를 의미**한다.  
각 튜플은 **속성(Attribute)의 집합으로 구성**되며, **릴레이션의 카디널리티(Cardinality)를 결정**한다.

#### 🧩 특징

- 하나의 튜플은 **한 개체나 사건에 대한 정보를 표현**
- 릴레이션 내 **튜플은 중복되지 않음**
- 튜플의 **순서는 의미 없음**
- 튜플의 각 항목은 해당 속성의 **도메인에 속한 원자값(Atomic Value)**을 가짐

#### 🧩 예시

| 학번 | 이름 | 전공 |
|------|------|------|
| 1001 | 김철수 | 컴퓨터공학 |
| 1002 | 이영희 | 정보통신 |

- 위 표에서 각 행(Row)은 하나의 튜플

#### 🧩 특징 요약

- **릴레이션의 행(Row)** = 튜플
- **중복 불가**, **순서 무의미**, **원자값으로 구성**
- **릴레이션의 레코드 수 = 카디널리티**

#### 📝 기출 포맷 예시

- 튜플에 대한 설명으로 **옳지 않은 것**은?
- 다음 중 튜플의 **특성으로 알맞은 것**은?
- 튜플은 무엇을 의미하는가?

#### 🧠 용어 설명

- **튜플(Tuple)**: 릴레이션의 한 행, 하나의 레코드
- **카디널리티(Cardinality)**: 튜플의 개수
- **원자값(Atomic Value)**: 더 이상 나눌 수 없는 단일 값

---

### 072. 속성 (Attribute)

#### 📘 정의
속성은 **데이터베이스를 구성하는 가장 작은 논리적 단위**로,  
**데이터 항목 또는 데이터 필드에 해당**한다.  
릴레이션(테이블)에서는 **열(Column)**에 해당하며,  
**각 튜플이 가지는 데이터 항목의 이름과 의미를 정의**한다.  
즉, **개체(Entity)의 특성을 기술**하는 요소이며,  
속성의 수는 **디그리(Degree) 또는 차수**라고 한다.

#### 🧩 속성의 종류

| 분류 기준 | 속성 종류 | 설명 |
|-----------|-----------|------|
| **값의 구성** | **단일값 속성** | 하나의 값만 가지는 속성 (예: 이름) |
|             | **다중값 속성** | 여러 개의 값을 가질 수 있는 속성 (예: 연락처) |
| **값의 구성 방식** | **원자값 속성** | 더 이상 나눌 수 없는 값 |
|             | **복합 속성** | 하위 속성으로 분해 가능한 속성 (예: 주소 → 시/군/구) |
| **특성에 따른 역할** | **기본 속성** | 실질적인 데이터를 표현하는 속성 |
|             | **유도 속성** | 다른 속성에 의해 계산되어 나오는 속성 (예: 나이 = 현재년도 - 생년월일) |
| **키 관련성** | **기본키 속성** | 튜플을 식별하기 위한 주요 속성 |
|             | **외래키 속성** | 다른 릴레이션의 기본키를 참조하는 속성 |

#### 🧩 특징 요약

- **릴레이션의 열(Column)**을 구성하는 요소
- 각 속성은 **고유한 도메인**을 가짐
- **개체의 특성을 기술**하는 최소 단위
- **데이터베이스를 구성하는 가장 작은 논리 단위**
- 속성의 수 = **디그리(Degree, 차수)**
- **속성의 조합으로 튜플이 완성**됨

#### 📝 기출 포맷 예시

- 속성의 **종류에 따른 분류**로 옳지 않은 것은?
- 다음 중 **복합 속성의 예**로 적절한 것은?
- 유도 속성에 대한 설명으로 옳은 것은?
- **속성은 무엇에 해당하는가?**

#### 🧠 용어 설명

- **속성(Attribute)**: 개체나 릴레이션의 특성, 테이블의 열
- **도메인(Domain)**: 속성이 가질 수 있는 값의 집합
- **다중값/복합 속성**: 복수 개 값 또는 하위 구성으로 이루어진 속성
- **유도 속성**: 계산 등을 통해 도출되는 속성
- **디그리(Degree)**: 릴레이션에 정의된 속성(열)의 개수

---

### 073. 도메인 (Domain)

#### 📘 정의
도메인은 **릴레이션의 속성이 가질 수 있는 값들의 논리적 집합 또는 범위**를 의미한다.  
즉, **하나의 속성이 가질 수 있는 원자값(Atomic Value)의 타입과 제약조건**을 정의하며,  
**속성의 유효값을 제한**하여 데이터의 무결성을 유지한다.

#### 🧩 특징

- 각 속성은 **하나의 도메인에만 속함**
- 도메인 내 값들은 **동일한 데이터 타입을 가짐**
- 도메인은 **데이터 입력값의 유효성 검사 기준**이 됨
- **제약조건(무결성)**으로도 활용됨 (예: CHECK 조건)
- 도메인은 일반적으로 **정의된 자료형 + 제약조건**의 형태

#### 🧩 예시

| 속성 | 도메인 예시 |
|------|-------------|
| 나이 | 정수형(0~120) |
| 성별 | '남', '여' |
| 학점 | 'A', 'B', 'C', 'D', 'F' |

#### 🧩 특징 요약

- **속성의 값이 가질 수 있는 합법적 범위**를 정의
- **데이터 무결성 보장**에 필수
- **하나의 속성 = 하나의 도메인** 원칙
- SQL에서 CHECK 제약조건 등으로 표현 가능

#### 📝 기출 포맷 예시

- 다음 중 **도메인(Domain)**의 정의로 가장 적절한 것은?
- 속성의 **값의 범위를 제한**하는 요소는?
- 도메인을 이용한 **무결성 제약** 예로 적절한 것은?

#### 🧠 용어 설명

- **도메인(Domain)**: 속성이 가질 수 있는 값의 논리적 집합
- **원자값(Atomic Value)**: 더 이상 나눌 수 없는 단일한 값
- **무결성 제약조건**: 데이터 정확성과 일관성을 보장하는 규칙

---

### 074. 후보키 (Candidate Key)

#### 📘 정의
후보키는 **릴레이션에서 각 튜플을 유일하게 식별할 수 있는 속성 또는 속성들의 집합 중 유일성과 최소성을 만족하는 키**이다.  
즉, **유일하게 식별 가능한 키들 중에서 기본키가 될 수 있는 후보들**이다.
-> 유일성과 최소성을 모두 만족시켜야 한다
#### 🧩 특징

- **유일성(Unique)**: 릴레이션 내 튜플을 유일하게 식별 가능
- **최소성(Minimality)**: 더 이상 속성을 제거하면 유일성 성립 X
- 하나의 릴레이션에는 **여러 개의 후보키**가 존재할 수 있음
- 후보키 중 **하나를 기본키(Primary Key)로 선정**함
- **후보키 간에는 중복되는 튜플이 없어야 함**

#### 🧩 예시

| 학번 | 이메일           | 전화번호     |
|------|------------------|--------------|
| 1001 | kim@abc.com      | 010-1234-5678 |

- 위 테이블에서 `학번`, `이메일`, `전화번호` 모두 후보키 가능  
  → 이 중 하나를 기본키로 선정하고 나머지는 대체키가 됨

#### 🧩 특징 요약

- **유일성과 최소성을 동시에 만족**
- **기본키의 후보**가 되는 키 집합
- **후보키 중 1개 선택 → 기본키**, 나머지 → 대체키

#### 📝 기출 포맷 예시

- 후보키의 **정의 또는 조건**으로 옳은 것은?
- 후보키와 **기본키/대체키의 관계**로 적절한 것은?
- 다음 중 **후보키로 적절하지 않은 속성 조합**은?

#### 🧠 용어 설명

- **후보키(Candidate Key)**: 기본키가 될 수 있는 유일·최소 키
- **유일성**: 모든 튜플을 구분 가능
- **최소성**: 불필요한 속성 포함 없이 최소 구성
- **기본키(Primary Key)**: 후보키 중 선정된 대표 키
- **대체키(Alternate Key)**: 후보키 중 기본키로 선택되지 않은 키
---

### 075. 기본키 (Primary Key)

#### 📘 정의
기본키는 **릴레이션에서 각 튜플을 유일하게 식별하기 위해 후보키 중에서 선택된 대표 키**이다.  
**중복을 허용하지 않고, NULL 값을 가질 수 없는 속성 또는 속성들의 조합**이다.

#### 🧩 특징

- **후보키 중 하나를 선택하여 기본키로 지정**
- **중복 불가 + NULL 불가** → 반드시 유일한 값 존재
- 하나의 릴레이션에는 **기본키가 반드시 1개 존재**
- 기본키는 **기본적으로 인덱스가 생성**됨
- 복합 기본키(composite key)도 가능 (속성 2개 이상 조합)

#### 🧩 예시

| 학번 (기본키) | 이름   | 학과     |
|--------------|--------|----------|
| 1001         | 홍길동 | 전산학과  |
| 1002         | 김철수 | 통계학과  |

- `학번`이 기본키로 지정되어 각 학생을 식별

#### 🧩 특징 요약

- **후보키 중 대표로 지정된 유일 식별자**
- **중복과 NULL 불가 (무결성 보장)**
- **1개의 릴레이션에 기본키는 반드시 1개**

#### 📝 기출 포맷 예시

- 기본키의 **조건**으로 적절하지 않은 것은?
- 다음 중 기본키의 **특징**으로 옳은 것은?
- 후보키와 기본키의 **차이점**으로 옳은 것은?

#### 🧠 용어 설명

- **기본키(Primary Key)**: 후보키 중 릴레이션의 대표 식별자로 지정된 키
- **후보키**: 유일성과 최소성을 만족하는 기본키 후보
- **NULL 금지**: 기본키는 항상 값이 존재해야 함
- **중복 금지**: 동일한 값의 기본키는 존재할 수 없음

---

### 077. 슈퍼키 (Super Key)

#### 📘 정의
슈퍼키는 **릴레이션에서 튜플을 유일하게 식별할 수 있는 하나 이상의 속성 집합**이다.  
후보키와 달리 **최소성 조건을 만족할 필요는 없으며**,  
**중복 속성을 포함해도 유일성만 유지되면 슈퍼키로 인정**된다.

#### 🧩 특징

- **튜플을 유일하게 식별**할 수 있어야 함 (유일성 만족)
- **최소성 조건 없음** → 만족하지 못한다
- 릴레이션에는 **여러 개의 슈퍼키** 존재 가능
- 모든 **후보키와 기본키는 슈퍼키에 포함됨**
- **속성 조합이 많을수록 슈퍼키 수는 증가**

#### 🧩 예시

| 학번 | 이메일        | 이름   |
|------|---------------|--------|
| 1001 | kim@abc.com   | 김철수 |

- `학번`, `이메일`, `(학번, 이메일)`은 모두 **슈퍼키**
- 단, `(학번, 이메일)`은 **최소성 만족 X** → **후보키는 아님**

#### 🧩 슈퍼키 ⊇ 후보키 ⊇ 기본키

- 슈퍼키: 유일성만 만족
- 후보키: 유일성 + 최소성 만족
- 기본키: 후보키 중 1개 선택

#### 🧩 특징 요약

- **유일성 O**, **최소성 X**
- **가장 넓은 키의 개념**
- **후보키, 기본키를 포함하는 상위 집합**

#### 📝 기출 포맷 예시

- 슈퍼키에 대한 설명으로 **옳지 않은 것**은?
- 다음 중 **슈퍼키에는 해당하지만 후보키에는 해당하지 않는 것**은?
- **슈퍼키, 후보키, 기본키의 포함 관계**로 옳은 것은?

#### 🧠 용어 설명

- **슈퍼키(Super Key)**: 튜플을 유일하게 식별 가능한 속성 집합
- **후보키(Candidate Key)**: 유일성 + 최소성 만족
- **기본키(Primary Key)**: 후보키 중 대표로 지정된 키

---

### 078. 외래키 (Foreign Key)

#### 📘 정의
외래키는 **다른 릴레이션의 기본키를 참조하는 속성 또는 속성들의 집합**이다.  
두 릴레이션 간의 **관계를 표현**하고, 참조 무결성을 유지하기 위해 사용된다.  
즉, **하위 릴레이션(자식 테이블)**의 외래키는 **상위 릴레이션(부모 테이블)**의 기본키 값을 참조한다.

#### 🧩 특징

- **한 릴레이션의 속성이 다른 릴레이션의 기본키를 참조**
- 두 릴레이션 간 **데이터 종속 관계(1:N 관계 등)** 표현
- 외래키는 참조 대상이 존재해야 하므로 **참조 무결성 제약조건**이 적용됨
- 외래키는 **중복 허용**, **NULL 허용** 가능 (상황에 따라 다름)
- 외래키 설정 시 **ON DELETE / ON UPDATE 제약조건** 활용 가능

#### 🧩 예시

- `학생(학번, 이름, 학과코드)`
- `학과(학과코드(PK), 학과명)`  
  → `학생.학과코드`는 `학과.학과코드`를 참조하는 **외래키**

#### 🧩 특징 요약

- **릴레이션 간 관계 설정**에 사용
- **참조 무결성 제약조건** 적용 가능
- **기본키를 참조**하며, **중복 및 NULL 가능**
- 외래키 제약조건 설정 시 **삭제/갱신 동작 제어 가능**

#### 📝 기출 포맷 예시

- 외래키(Foreign Key)의 **역할 또는 특징**으로 옳은 것은?
- 다음 중 **참조 무결성 위반 사례**로 적절한 것은?
- 외래키 설정 시 사용할 수 있는 **ON DELETE 옵션**은?

#### 🧠 용어 설명

- **외래키(Foreign Key)**: 다른 릴레이션의 기본키를 참조하는 속성
- **참조 무결성(Referential Integrity)**: 참조 대상이 반드시 존재해야 하는 제약조건
- **ON DELETE / ON UPDATE**: 참조 행 변경/삭제 시 동작 정의 (CASCADE, SET NULL 등)

### 079. 무결성 (Integrity)

#### 📘 정의
무결성은 **데이터의 정확성, 일관성, 신뢰성을 유지하기 위한 제약조건의 총칭**이다.  
데이터베이스에 저장된 데이터가 **정해진 규칙을 항상 만족, 실제 값이 일치하도록 보장**하며,  
오류나 불일치가 발생하지 않도록 한다.

#### 🧩 주요 무결성 제약조건

| 구분 | 설명 |
|------|------|
| **개체 무결성 (Entity Integrity)** | 기본키는 **NULL이 될 수 없고**, **중복되지 않아야 함** |
| **참조 무결성 (Referential Integrity)** | 외래키는 **참조하는 기본키 값이 존재해야 함** |
| **도메인 무결성 (Domain Integrity)** | 속성 값은 **정의된 도메인 범위 내의 값**이어야 함 |
| **사용자 정의 무결성 (User-Defined Integrity)** | 사용자가 정의한 **업무 규칙 기반 조건** (예: 나이는 0 이상 등) |

#### 🧩 특징 요약

- **데이터 정확성과 일관성을 보장**
- **제약조건을 통해 데이터 오류 예방**
- 설계 단계에서 정의 → DBMS가 자동 검사
- SQL의 `PRIMARY KEY`, `FOREIGN KEY`, `CHECK`, `NOT NULL` 등으로 구현

#### 🧩 예시

- `학번(PK)`은 NULL일 수 없음 → 개체 무결성
- `학생.학과코드`가 `학과.학과코드`에 없으면 → 참조 무결성 위반
- `성별` 값은 '남' 또는 '여'만 허용 → 도메인 무결성

#### 📝 기출 포맷 예시

- 다음 중 **개체 무결성의 정의**로 가장 적절한 것은?
- 외래키 설정 시 **참조 무결성 위반 사례**로 알맞은 것은?
- 도메인 무결성을 위반한 예로 옳은 것은?

#### 🧠 용어 설명

- **무결성(Integrity)**: 데이터의 정확성, 일관성, 신뢰성을 보장하는 제약조건
- **개체 무결성**: 기본키는 NULL과 중복을 허용하지 않음
- **참조 무결성**: 외래키는 참조하는 기본키가 존재해야 함
- **도메인 무결성**: 속성 값은 정해진 타입/범위 내여야 함
- **사용자 정의 무결성**: 업무 규칙 기반의 맞춤형 제약조건

---

### 080. 관계대수 (Relational Algebra)

#### 📘 정의
관계대수는 **관계형 데이터베이스에서 원하는 데이터를 얻기 위해 연산자(연산 기호)를 이용하여 릴레이션을 조작하는 절차적 질의 언어**이다.  
즉, **입력 릴레이션에 연산을 적용하여 새로운 릴레이션을 생성하는 방법**이다.
원하는 정보와 그 정보를 검색하기 위해서 어떻게 유도하는가를 기술하는 절차적인 언어이다.

#### 🧩 특징

- **절차적 언어**: 어떤 순서로 데이터를 추출할 것인지 명시
- 연산의 결과는 **항상 새로운 릴레이션** (테이블)로 생성됨
- 관계형 모델의 **기초 수학 이론 중 하나**
- **관계해석과 대비되는 개념** (관계해석은 비절차적)

#### 🧩 관계대수 연산 분류

| 연산 유형 | 연산자 | 설명 |
|-----------|--------|------|
| **순수 관계 연산자** | **SELECT(σ)** | 조건에 맞는 튜플(행) 선택 |
|                        | **PROJECT(π)** | 원하는 속성(열) 추출 |
|                        | **RENAME(ρ)** | 릴레이션 이름 또는 속성 이름 변경 |
| **집합 연산자** | **UNION(∪)** | 두 릴레이션의 합집합 |
|                  | **INTERSECTION(∩)** | 두 릴레이션의 교집합 |
|                  | **DIFFERENCE(-)** | 차집합 (왼쪽에만 있는 튜플) |
| **조인 연산자** | **JOIN(⨝)** | 두 릴레이션을 조건에 따라 연결 |
| **카티션 곱** | **Cartesian Product(×)** | 모든 튜플 간 조합 생성 |

#### 🧩 특징 요약

- **관계형 모델의 수학적 질의 처리 기반**
- **절차적** 접근 방식 (연산 순서 명시)
- 결과는 항상 **새로운 릴레이션**
- **SELECT + PROJECT + JOIN**이 핵심

#### 📝 기출 포맷 예시

- 관계대수에서 **SELECT(σ)** 연산의 의미는?
- 다음 중 **관계대수 연산자가 아닌 것**은?
- 관계대수의 **특징으로 옳은 것**은?

#### 🧠 용어 설명

- **관계대수(Relational Algebra)**: 릴레이션을 처리하기 위한 절차적 질의 언어
- **절차적 언어**: 연산 순서를 명확히 지시하는 질의 방식
- **SELECT(σ)**: 조건에 맞는 행 선택
- **PROJECT(π)**: 원하는 열(속성)만 선택
- **JOIN(⨝)**: 릴레이션 간 연결

---

### 081. 관계대수 연산자 분류

#### 📘 정의
관계대수(Relational Algebra)는 **관계형 데이터베이스에서 릴레이션(테이블)에 적용할 수 있는 연산 체계**를 말한다.  
데이터를 검색하고 조작하기 위한 **비절차적 질의 언어의 기반**이 된다.

관계대수 연산자는 크게 **순수 관계 연산자(기본 연산)**와 **파생 관계 연산자(응용 연산)**로 나뉜다.

#### 🧩 순수 관계 연산자 (기본 연산자)

| 연산자 | 기호 | 설명 |
|--------|------|------|
| **SELECT** | σ (시그마) | 조건에 맞는 튜플(행)을 **수평적으로 선택** |
| **PROJECT** | π (파이) | 특정 속성(열)을 **수직적으로 선택** |
| **RENAME** | ρ (로우) | 릴레이션 또는 속성 이름을 변경 |

- 🔸 **1개의 릴레이션에만 적용**
- 🔸 **기본적인 질의 기능 수행**
- 🔸 **정처기에서 "순수 관계 연산자"를 묻는 문제에 출제**

#### 🧩 파생 관계 연산자 (응용 연산자)

| 연산자 | 기호 | 설명 |
|--------|------|------|
| **JOIN** | ⨝ | 조건에 따라 두 릴레이션을 연결 |
| **DIVISION** | ÷ | 조건에 따라 **모든 값을 포함한 튜플**을 추출 |
| **UNION** | ∪ | 두 릴레이션의 합집합 |
| **INTERSECTION** | ∩ | 두 릴레이션의 교집합 |
| **DIFFERENCE** | − | 한 릴레이션에서 다른 릴레이션을 뺌 |
| **CARTESIAN PRODUCT** | × | 두 릴레이션의 모든 조합 생성 |

- 🔸 **2개 이상의 릴레이션 필요 (이항 연산)**
- 🔸 **SELECT, PROJECT 등을 조합해 구현 가능**
- 🔸 **DIVISION은 파생 연산자이며, 순수 관계 연산자 아님**

#### 🧩 특징 요약

- **순수 관계 연산자**는 단순 질의(검색)에 사용되는 기본 도구
- **파생 관계 연산자**는 고급 질의 처리를 위해 기본 연산 조합으로 정의됨
- 정처기 시험에서는 “순수 관계 연산자에 해당하지 않는 것” 형태로 자주 출제됨

#### 📝 기출 포맷 예시

- 다음 중 **순수 관계 연산자**에 해당하지 않는 것은?
- 다음 중 **DIVISION 연산자**의 역할로 옳은 것은?
- 관계대수에서 **π (파이)** 연산의 기능은?

#### 🧠 용어 설명

- **관계대수(Relational Algebra)**: 릴레이션 기반 질의 연산 체계
- **순수 관계 연산자**: SELECT, PROJECT, RENAME
- **파생 관계 연산자**: JOIN, DIVISION, UNION 등
- **수평적 선택**: 행 기준 추출 (SELECT)
- **수직적 선택**: 열 기준 추출 (PROJECT)

---

### 082. 일반 집합 연산자 (합집합, 교집합, 차집합, 교차곱)

#### 📘 정의
관계 대수에서 **집합 연산자**는 두 개의 릴레이션(테이블) 간에  
**데이터의 포함 관계나 조합을 정의**하는 연산자이다.  
→ 합집합(∪), 교집합(∩), 차집합(−), 교차곱(×)이 대표적이다.

#### 🧩 주요 연산 종류 및 설명

| 연산자 | 설명 | 디그리(Degree) | 카디널리티(Cardinality) |
|--------|------|----------------|--------------------------|
| **합집합 (∪)** | 두 릴레이션에 존재하는 **모든 튜플**을 포함하되 중복은 제거 | 동일 | 두 릴레이션의 카디널리티 합보다 작거나 같음 |
| **교집합 (∩)** | 두 릴레이션에 **공통으로 존재하는 튜플만** 반환 | 동일 | 더 작은 릴레이션의 카디널리티 이하 |
| **차집합 (−)** | 첫 번째 릴레이션에만 존재하고 두 번째에는 없는 튜플 반환 | 동일 | 첫 번째 릴레이션의 카디널리티 이하 |
| **교차곱 (×)** | 두 릴레이션의 **모든 튜플 쌍을 조합**하여 결과 생성 | 합계 | 두 릴레이션의 카디널리티 곱 |

※ 집합 연산은 **합집합 호환(Union Compatible)** 조건을 만족해야 수행 가능  
→ **디그리가 같고, 각 속성의 도메인이 동일해야 함**

#### 🧩 특징 요약

- **합집합/교집합/차집합**은 디그리와 도메인이 동일해야 연산 가능
- **교차곱**은 조인 전 단계로, 모든 조합을 만드는 연산
- **교차곱 결과는 튜플 수가 많아질 수 있어 주의 필요**
- 릴레이션 간 **집합 연산의 결과도 릴레이션**

#### 📝 기출 포맷 예시

- 다음 중 **교차곱(Cartesian Product)의 결과**에 대한 설명으로 옳은 것은?
- 관계 대수의 **합집합 조건**으로 올바른 것은?
- 두 릴레이션 간 **차집합 결과의 카디널리티**에 대한 설명으로 맞는 것은?

#### 🧠 용어 설명

- **합집합 (∪)**: A 또는 B에 포함된 모든 튜플
- **교집합 (∩)**: A와 B에 **모두 포함된** 튜플
- **차집합 (−)**: A에만 포함되고 B에는 없는 튜플
- **교차곱 (×)**: A의 각 튜플과 B의 각 튜플을 **모든 조합**으로 생성
- **디그리 (Degree)**: 릴레이션의 속성 개수 (열 수)
- **카디널리티 (Cardinality)**: 릴레이션의 튜플 개수 (행 수)
- **합집합 호환 (Union Compatible)**: 집합 연산을 위한 조건, **디그리와 도메인 동일**

---

### 083. 관계해석 (Relational Calculus)

#### 📘 정의
관계해석은 **원하는 결과를 얻기 위해 “무엇을” 추출할지를 선언적으로 기술**하는 관계형 데이터베이스의 질의 언어이다.  
→ 절차를 명시하지 않고 **조건 기반으로 결과를 기술**하며, 관계대수와는 **대립되는 개념(절차 vs 선언)**이다.
관계 데이터의 연산을 표현하는 방법

#### 🧩 종류 및 형식

| 종류 | 설명 | 예시 |
|------|------|------|
| **튜플 관계해석 (TRC)** | 튜플 변수를 사용하여 조건을 지정 | `{ t | EMPLOYEE(t) ∧ t.salary > 3000 }` |
| **도메인 관계해석 (DRC)** | 속성(도메인) 변수로 조건을 표현 | `{ <n, s> | ∃d(EMPLOYEE(n, d, s) ∧ s > 3000) }` |

※ 두 관계해석 모두 **비절차적 질의 언어**이며, **조건식을 만족하는 결과만 반환**함

#### 🧩 특징 요약

- **비절차적(선언형) 질의 언어**
- 사용자가 **원하는 정보의 조건만 명시**, 어떻게 추출할지는 시스템이 결정
- **관계대수(Relational Algebra)**와 **동일한 표현 능력**을 가짐 (튜링 등가)
- **튜플 변수 / 도메인 변수**에 따라 표현 방식 달라짐

#### 📝 기출 포맷 예시

- 다음 중 **관계해석(Relational Calculus)**에 대한 설명으로 옳은 것은?
- 관계해석은 어떤 특성을 갖는가? → **비절차적 언어**
- TRC와 DRC의 **차이점**을 묻는 문제

#### 🧠 용어 설명

- **관계해석(Relational Calculus)**: 선언형 질의 언어
- **TRC (Tuple Relational Calculus)**: 튜플을 변수로 사용
- **DRC (Domain Relational Calculus)**: 속성 값을 변수로 사용
- **비절차적 언어**: 결과 조건만 기술, 수행 절차는 시스템이 처리

---

### 084. 이상 (Anomaly)

#### 📘 정의
이상(Anomaly)은 **릴레이션에서 데이터 중복 또는 종속성으로 인해 발생하는 비정상적인 현상**으로,  
데이터 삽입, 삭제, 갱신 시 **일관성 저해, 무결성 위반, 중복 발생** 등의 문제를 유발한다.  
→ **정규화를 통해 이상 현상을 제거**할 수 있다.

#### 🧩 이상 종류 및 예시

| 이상 종류 | 설명 | 예시 |
|-----------|------|------|
| **삽입 이상 (Insertion Anomaly)** | 특정 정보를 저장하려면 **불필요한 다른 정보도 함께 저장**해야 하는 문제 | 새로운 부서를 추가하려면 직원 정보도 입력해야 함 |
| **삭제 이상 (Deletion Anomaly)** | 한 정보 삭제 시 **의도치 않은 다른 정보까지 함께 삭제**되는 문제 | 특정 직원이 퇴사하면 부서 정보까지 사라짐 |
| **갱신 이상 (Update Anomaly)** | **중복된 데이터의 일관성 유지가 어려운** 문제 | 같은 부서명이 여러 행에 있어 변경 시 누락 가능 |

#### 🧩 특징 요약

- 이상 현상은 **중복 데이터**와 **함수 종속성**에서 발생
- **제1정규형~제3정규형 이상**에서 이상 발생 가능
- **정규화를 통해 삽입/삭제/갱신 이상을 방지**함
- **비정규 릴레이션일수록 이상 발생 확률이 높음**

#### 📝 기출 포맷 예시

- 다음 중 **삽입 이상(Insertion Anomaly)**에 대한 설명으로 적절한 것은?
- 이상(Anomaly)이 발생하는 **원인으로 옳은 것**은?
- **갱신 이상**이 발생하는 대표적인 사례는?

#### 🧠 용어 설명

- **삽입 이상**: 일부 정보를 넣기 위해 불필요한 다른 정보도 넣어야 하는 문제
- **삭제 이상**: 하나의 정보 삭제가 의도치 않은 다른 정보 손실로 이어지는 문제
- **갱신 이상**: 중복된 값들 중 일부만 수정되어 **데이터 불일치가 발생하는 문제**
- **정규화**: 이상을 제거하고 데이터 구조를 정제하는 과정

---

### 085. 함수적 종속 (Functional Dependency)

#### 📘 정의
함수적 종속은 **릴레이션에서 하나의 속성 값이 다른 속성 값을 유일하게 결정하는 관계**를 의미한다.  
속성 X와 Y에 대해, X의 값이 결정되면 Y의 값이 **항상 유일하게 정해질 때**,  
“Y는 X에 함수적으로 종속된다( X → Y )”고 표현한다.

#### 🧩 표기와 의미

- **X → Y** : X가 주어지면 Y는 유일하게 결정된다.
- **X → Y, Z** : X가 주어지면 Y와 Z 모두 결정된다.

예: 학번 → 이름, 학과  
→ 같은 학번이면 이름과 학과도 반드시 같다.

#### 🧩 함수적 종속의 유형

| 유형 | 정의 | 예시 |
|------|------|------|
| **완전 함수적 종속** | **어떤 속성이 기본키 전체에 종속되고**, 기본키의 어느 한 부분에도 종속되지 않을 때 | (학번, 과목) → 성적<br>→ 학번이나 과목 하나만으로는 성적 결정 불가 |
| **부분 함수적 종속** | 어떤 속성이 **기본키의 일부분에만 종속**될 때 | (학번, 과목) → 이름<br>→ 이름이 학번에만 종속된다면 부분 종속 |
| **이행적 함수적 종속** | A → B, B → C일 때, A → C가 성립하고 **B는 기본키가 아닐 때** | 학번 → 학과코드, 학과코드 → 학과명<br>→ 학번 → 학과명은 이행 종속 |

> ✅ **부분 함수적 종속**과 **이행적 함수적 종속**은 **비정규형 → 정규형 변환 시 제거 대상**으로 자주 출제됩니다.


#### 🧩 함수적 종속의 성질 (암스트롱 공리)

| 성질 | 설명 |
|------|------|
| **반사성 (Reflexivity)** | Y ⊆ X → X → Y |
| **증강성 (Augmentation)** | X → Y 이면, XZ → YZ |
| **이행성 (Transitivity)** | X → Y, Y → Z 이면 X → Z |

#### 🧩 기타 성질

| 성질 | 설명 |
|------|------|
| **결합 (Union)** | X → Y, X → Z 이면 X → YZ |
| **분해 (Decomposition)** | X → YZ 이면 X → Y, X → Z |
| **합집합 규칙** | X → Y, WZ → V 이면 XWZ → YV |

#### 🧩 특징 요약

- **정규화의 핵심 개념**
- **속성 간 결정 관계**를 나타냄
- **기본키는 모든 속성을 함수적으로 결정**
- **부분/이행적 종속**은 정규화 과정에서 제거

#### 📝 기출 포맷 예시

- 다음 중 **부분 함수적 종속**의 예로 적절한 것은?
- 이행적 함수적 종속이 존재할 때 발생 가능한 이상은?
- 함수적 종속의 **암스트롱 공리**에 포함되지 않는 것은?

#### 🧠 용어 설명

- **함수적 종속 (X → Y)**: X값이 Y값을 유일하게 결정하는 관계
- **완전 함수적 종속**: 기본키 전체에 종속
- **부분 함수적 종속**: 기본키 일부에만 종속
- **이행적 함수적 종속**: 중간 속성을 통해 간접 종속된 상태
- **암스트롱 공리**: 함수적 종속 유도에 사용되는 3가지 기본 성질

---

### 086. 정규화 (Normalization)

#### 📘 정의
정규화는 **데이터의 중복을 제거하고, 삽입·삭제·갱신 이상(Anomaly)을 방지하기 위해 릴레이션을 구조적으로 분해하는 과정**이다.  
→ 데이터의 **일관성, 무결성, 저장 효율성**을 높이기 위한 릴레이션 무손실 구조 개선 방법이다.

#### 🧩 정규형 단계 요약

| 정규형 | 정의 조건 | 제거 대상 |
|--------|-----------|------------|
| **제1정규형 (1NF)** | 모든 속성값이 **원자값(Atomic Value)** | 반복 속성 |
| **제2정규형 (2NF)** | 1NF 만족 + **부분 함수적 종속 제거** | 부분 함수적 종속 |
| **제3정규형 (3NF)** | 2NF 만족 + **이행적 함수적 종속 제거** | 이행적 함수적 종속 |
| **BCNF** | 3NF 만족 + **모든 결정자가 후보키** | 후보키가 아닌 결정자 |
| **제4정규형 (4NF)** | BCNF 만족 + **다치 종속 제거** | 다치 종속(MVD) |
| **제5정규형 (5NF)** | 4NF 만족 + **조인 종속이 후보키를 통해서만 분해 가능** | 조인 종속 |

> 4NF는 **하나의 속성이 여러 독립적 다치값을 가질 때** 분해 필요  
> 5NF는 **조인 후 재결합 시 데이터 손실이 발생하는 경우 분해**

#### 🧩 특징 요약

- **중복 제거 및 이상 현상 방지**
- **데이터 정합성, 무결성 향상**
- 정규형이 높아질수록 **설계 복잡성 증가**
- **4NF 이상은 고급 정규화로 실기에서 간단 정의나 제거 대상 위주로 출제**

#### 📝 기출 포맷 예시

- 다음 중 **제4정규형의 제거 대상**으로 옳은 것은?
- **BCNF와 3NF의 차이점**은 무엇인가?
- **5NF의 분해 기준**으로 알맞은 설명은?

#### 🧠 용어 설명

- **정규화**: 데이터 중복과 이상을 제거하는 구조 개선 기법
- **부분/이행/다치/조인 종속**: 각 정규형에서 제거해야 할 종속 관계
- **결정자(Determinant)**: 다른 속성을 결정하는 속성
- **조인 종속**: 릴레이션이 분해된 후 조인해야만 원래 데이터 복원이 가능한 상태

---

### 087. 정규화 과정 (1NF ~ 5NF)

#### 📘 정의
정규화(Normalization)는 **데이터 중복 제거 및 이상 현상 방지를 위해 릴레이션을 구조적으로 분해하는 과정**이다.  
삽입·삭제·갱신 이상(Anomaly)을 방지하고 **데이터의 무결성**을 유지하기 위한 필수 과정이다.  
정규화는 **1NF → 2NF → 3NF → BCNF → 4NF → 5NF** 순으로 진행되며, 각 단계는 상위 정규형보다 더 강력한 조건을 가진다.

---

### 🥇 1NF (제1정규형)

#### 🔹 정의
- **모든 속성의 도메인은 원자값(Atomic Value)**으로 구성되어야 한다.
- 즉, **반복되는 그룹이나 집합 값 제거**, **속성에 하나의 값만 존재**해야 한다.

#### 🔹 예제 (비정규 릴레이션)

| 학번 | 이름   | 수강과목           |
|------|--------|---------------------|
| 1001 | 홍길동 | DB, 운영체제        |
| 1002 | 이영희 | 자료구조             |

→ 수강과목은 **복합값**, 즉 원자값이 아님

#### 🔹 정규화 후 (1NF 적용)

| 학번 | 이름   | 수강과목   |
|------|--------|------------|
| 1001 | 홍길동 | DB         |
| 1001 | 홍길동 | 운영체제   |
| 1002 | 이영희 | 자료구조   |

#### 🔹 특징 요약
- 반복 그룹 제거, 속성의 원자성 확보
- 릴레이션의 **모든 속성은 원자값**
- 가장 기본적인 정규형

---

### 🥈 2NF (제2정규형)

#### 🔹 정의
- **1NF 만족 + 부분 함수 종속 제거**
- 기본키가 **복합키**일 경우, 기본키의 일부분에만 종속되는 속성을 제거해야 함

#### 🔹 예제

| 학번 | 수강과목 | 교수명  |
|------|----------|----------|
| 1001 | DB       | 이교수   |
| 1001 | 운영체제 | 김교수   |

→ 기본키: (학번, 수강과목)  
→ 교수명은 수강과목에만 종속 ⇒ **부분 함수 종속**

#### 🔹 정규화 후 (2NF 적용)

① 수강 정보  
| 학번 | 수강과목   |
|------|------------|
| 1001 | DB         |
| 1001 | 운영체제   |

② 교수 정보  
| 수강과목 | 교수명  |
|----------|----------|
| DB       | 이교수   |
| 운영체제 | 김교수   |

#### 🔹 특징 요약
- **부분 함수 종속 제거**
- **복합키 테이블**에서 종속성 분리
- 단일키인 경우 1NF = 2NF

---

### 🥉 3NF (제3정규형)

#### 🔹 정의
- **2NF 만족 + 이행적 함수 종속 제거**
- 기본키가 아닌 속성이 또 다른 기본키가 아닌 속성에 종속되면 안 됨

#### 🔹 예제

| 학번 | 이름   | 학과번호 | 학과명     |
|------|--------|----------|------------|
| 1001 | 홍길동 | 10       | 컴퓨터공학 |
| 1002 | 이영희 | 20       | 정보통신   |

→ 학과명은 학과번호에 종속되고, 학과번호는 학번에 종속 ⇒ 이행적 종속

#### 🔹 정규화 후 (3NF 적용)

① 학생  
| 학번 | 이름   | 학과번호 |
|------|--------|----------|
| 1001 | 홍길동 | 10       |
| 1002 | 이영희 | 20       |

② 학과  
| 학과번호 | 학과명     |
|----------|------------|
| 10       | 컴퓨터공학 |
| 20       | 정보통신   |

#### 🔹 특징 요약
- **이행적 함수 종속 제거**
- 기본키 ↔ 속성 구조 단순화
- 데이터 일관성 확보

---

### 🏅 BCNF (보이스-코드 정규형)

#### 🔹 정의
- **3NF 만족 + 모든 결정자가 후보키**
- 후보키가 아닌 속성이 결정자 역할을 하는 경우 → 분해 필요

#### 🔹 예제

| 교수명 | 강의실 | 과목     |
|--------|--------|----------|
| 이교수 | 101호  | DB       |
| 이교수 | 101호  | 자료구조 |

→ {교수명, 강의실}이 후보키지만  
→ 교수명 → 강의실 ⇒ 교수명이 결정자이지만 후보키가 아님 ⇒ BCNF 위배

#### 🔹 정규화 후 (BCNF 적용)

① 교수-강의실  
| 교수명 | 강의실 |
|--------|--------|
| 이교수 | 101호  |

② 교수-과목  
| 교수명 | 과목     |
|--------|----------|
| 이교수 | DB       |
| 이교수 | 자료구조 |

#### 🔹 특징 요약
- 결정자가 후보키인지 반드시 검증
- **함수 종속 문제의 근본 해결**
- 실무 적용에는 조인 비용 고려 필요

---

### 🎖 4NF (제4정규형)

#### 🔹 정의
- **BCNF 만족 + 다치 종속(MVD, Multivalued Dependency) 제거**
- 하나의 속성이 두 개 이상의 독립적인 다치 값에 영향을 주는 경우 → 분리 필요

#### 🔹 예제 (4NF 위배)

| 학생 | 동아리     | 자격증     |
|------|------------|------------|
| 철수 | 축구동아리 | 정보처리기사 |
| 철수 | 축구동아리 | 컴활       |
| 철수 | 농구동아리 | 정보처리기사 |
| 철수 | 농구동아리 | 컴활       |

→ 학생 →→ 동아리, 학생 →→ 자격증  
→ 독립적인 다치 종속이 존재 ⇒ 4NF 위배

#### 🔹 정규화 후 (4NF 적용)

① 학생-동아리  
| 학생 | 동아리     |
|------|------------|
| 철수 | 축구동아리 |
| 철수 | 농구동아리 |

② 학생-자격증  
| 학생 | 자격증     |
|------|------------|
| 철수 | 정보처리기사 |
| 철수 | 컴활       |

#### 🔹 특징 요약
- **다치 종속 → 릴레이션 분리**
- 복잡한 중복 제거, 구조 단순화
- 실무에서는 드물게 직접 적용됨

### 🏆 5NF (제5정규형, PJ/NF)

#### 🔹 정의
- **4NF 만족 + 조인 종속(Join Dependency) 제거**
- 릴레이션이 **모든 의미 있는 정보를 손실 없이 분해 가능**해야 함

#### 🔹 예제 (5NF 위배)

| 공급자 | 부품 | 프로젝트 |
|--------|------|-----------|
| A회사   | X부품 | Alpha     |
| A회사   | X부품 | Beta      |
| A회사   | Y부품 | Alpha     |

→ 공급자와 부품, 공급자와 프로젝트, 부품과 프로젝트 간에 **개별 관계는 있으나** 전체 릴레이션은 분해 불가

#### 🔹 정규화 후 (5NF 적용)

① 공급자-부품  

| 공급자 | 부품 |
|--------|------|
| A회사   | X부품 |
| A회사   | Y부품 |

② 공급자-프로젝트  

| 공급자 | 프로젝트 |
|--------|-----------|
| A회사   | Alpha     |
| A회사   | Beta      |

③ 부품-프로젝트  

| 부품 | 프로젝트 |
|------|-----------|
| X부품 | Alpha     |
| X부품 | Beta      |

→ 세 릴레이션을 **조인하여 원래 테이블 복원 가능**

#### 🔹 특징 요약
- **조인 종속성 분리**
- 정보 손실 없이 분해 가능해야 함
- 매우 복잡한 경우로 실무에서 드물게 발생

### 🧠 용어 정리 요약

| 용어 | 설명 |
|------|------|
| **함수 종속** | X → Y: X 값이 결정되면 Y 값도 유일하게 결정됨 |
| **부분 함수 종속** | 복합키의 일부분만으로 결정됨 |
| **이행 함수 종속** | A → B, B → C → A → C와 같은 간접 종속 |
| **다치 종속** | X →→ Y: X에 따라 Y 값이 여러 개 결정되는 종속 |
| **조인 종속** | 릴레이션을 복원 가능한 여러 릴레이션으로 분해할 수 있는 관계 |

### 🧩 전체 정규화 단계 요약

| 단계 | 제거 대상 | 특징 |
|------|-----------|------|
| 1NF  | 반복 속성  | 원자값 사용 |
| 2NF  | 부분 함수 종속 | 복합키의 일부만 의존 제거 |
| 3NF  | 이행 함수 종속 | 기본키가 아닌 속성 간 종속 제거 |
| BCNF | 결정자 → 후보키 아닌 경우 | 모든 결정자는 후보키 |
| 4NF  | 다치 종속  | 하나의 속성이 여러 독립적 속성에 영향 |
| 5NF  | 조인 종속  | 분해 후 정보 손실 없도록 |

---

### 088. 정규화 과정 정리

#### 📘 정의
정규화는 **릴레이션에서 중복을 제거하고 이상 현상을 방지**하여  
**데이터의 일관성과 무결성을 보장**하기 위한 과정이다.  
일반적으로 1NF부터 시작하여 5NF 또는 BCNF까지 단계적으로 수행한다.

#### 🧩 정규화 단계 요약표

| 정규형 | 조건 / 제거 대상 | 특징 | 주요 종속성 |
|--------|------------------|------|-------------|
| **1NF** | 반복 속성 제거 (원자값) | 속성값은 더 이상 나눌 수 없는 원자값으로 구성 | 없음 (구조적 제약만 존재) |
| **2NF** | 부분 함수 종속 제거 | 기본키의 일부에만 종속된 속성 제거 | 부분 함수 종속 |
| **3NF** | 이행적 함수 종속 제거 | 비주요 속성이 다른 비주요 속성에 종속되면 제거 | 이행 함수 종속 |
| **BCNF** | 결정자가 후보키가 아닌 함수 종속 제거 | 모든 결정자가 후보키인 상태 | 함수 종속 (결정자 조건 강화) |
| **4NF** | 다치 종속 제거 | 한 속성이 여러 속성에 독립적으로 다치 종속될 경우 분해 | 다치 종속 |
| **5NF** | 조인 종속 제거 | 분해된 릴레이션이 조인될 때 정보 손실 없이 복원 | 조인 종속 |

#### 🧠 용어 설명

- **부분 함수 종속**: 기본키의 일부 속성에만 종속된 경우
- **이행 함수 종속**: A → B, B → C이면 A → C가 성립하는 종속성
- **다치 종속(MVD)**: 하나의 속성이 두 개 이상의 속성에 독립적으로 영향을 줄 때
- **조인 종속**: 릴레이션을 분해 후 조인하여 원래 릴레이션을 복원할 수 있는 종속성

#### 📝 기출 포맷 예시

- 정규화 단계 중 **이행적 함수 종속을 제거**하는 단계는?
- 다음 중 **BCNF의 조건**으로 가장 적절한 것은?
- **다치 종속 제거를 위한 정규형**은?

---

### 089. 반정규화 (Denormalization)

#### 📘 정의
반정규화는 **정규화된 릴레이션을 의도적으로 통합하거나 중복 분리를 허용하여 성능을 향상**시키는 과정이다.  
**복잡한 조인, 조회 성능 저하, 처리 비용 증가**를 해결하기 위해 적용된다.

#### 🧩 목적
- 조인(JOIN) 연산 최소화
- 검색 성능 향상
- 응답 시간 단축
- 트랜잭션 처리 효율화

#### 🧩 반정규화 적용 시점
- 시스템 응답 속도가 느릴 때
- 과도한 조인이 발생하는 경우
- 정규화로 인해 데이터 접근이 비효율적인 경우
- 실시간 집계나 반복 조회가 많은 경우

#### 🧩 반정규화 유형

| 유형 | 설명 |
|------|------|
| **테이블 병합** | 자주 조인되는 두 테이블을 하나로 통합 |
| **중복 속성 추가** | 자주 조회되는 속성을 다른 테이블에 복사 저장 |
| **중복 테이블 추가** | 통계용 집계 데이터를 별도 테이블로 생성 |
| **파티셔닝** | 테이블을 논리적으로 수평 또는 수직 분할 |
| **역정규화 뷰 구성** | 정규화된 테이블을 하나로 결합한 뷰 생성 |

#### 🧠 용어 설명
- **반정규화**: 성능 향상을 위해 일부 정규형을 해제하고 데이터 중복을 허용하는 설계
- **병합**: 릴레이션 간 조인을 줄이기 위한 테이블 통합
- **중복 저장**: 읽기 성능을 위해 데이터를 여러 테이블에 중복 저장하는 방식

#### 📝 기출 포맷 예시
- 반정규화를 **적용해야 하는 상황**으로 적절한 것은?
- 다음 중 **반정규화의 목적**으로 옳지 않은 것은?
- 반정규화 적용 시 **고려사항**으로 가장 적절한 것은?

---
### 090. 중복 테이블 추가

#### 📘 정의
중복 테이블 추가는 **반정규화의 대표적인 기법**으로,  
**자주 사용되는 조회 결과나 통계 데이터를 별도로 저장한 테이블을 생성**하는 방식이다.  
데이터 중복을 통해 **조인 연산을 줄이고 조회 성능을 향상**시킨다.

#### 🧩 목적
- **자주 조회되는 정보**를 빠르게 응답하기 위함
- **복잡한 조인 제거 및 속도 개선**
- **집계 또는 요약 정보 제공 용이**

#### 🧩 중복 테이블 추가 방법

| 방법 | 설명                                                   |
|------|------------------------------------------------------|
| **집계 테이블 추가** | 집계 데이터를 위한 테이블을 생성하고 각 원본 테이블에 트리거를 성정해 사용           |
| **진행 테이블 추가** | 이력 관리 등의 목적으로 추가하는 테이블                               |
| **특정 부분만을 포함하는 테이블 추가** | 데이터가 많은 테이블의 특정 부분만을 사용하는 경우 해당 부분만으로 새로운 테이블 생성 

#### 🧩 적용 예시

| 상황 | 설명 |
|------|------|
| **매출 요약 테이블** | 매일 총 매출을 미리 계산해 저장하여 통계 요청 시 즉시 조회 |
| **회원 현황 테이블** | 이름, 등급, 최근 주문일 등을 요약하여 빠르게 화면 출력 |
| **조회수 테이블** | 상품별 조회수를 별도로 저장하여 목록 표시 시 빠른 응답 가능 |

#### 🧠 용어 설명
- **중복 테이블**: 유도 가능한 정보를 중복 저장한 테이블
- **반정규화**: 성능 향상을 위한 설계 기법, 정규형 일부 해제

#### 📝 기출 포맷 예시
- 중복 테이블 추가의 **적절한 사용 사례**는?
- 반정규화 시 중복 테이블을 사용하는 **이유**는 무엇인가?
- 중복 테이블이 **불필요한 경우**는?

---

### 091. 시스템 카탈로그 (System Catalog)

#### 📘 정의
시스템 카탈로그는 **DBMS가 데이터베이스를 관리하기 위해 내부적으로 유지하는 메타데이터 저장소**이다.  
**데이터 사전(Data Dictionary)**이라고도 하며,  
데이터베이스에 존재하는 **모든 객체(테이블, 뷰, 인덱스 등)의 정의 정보 및 상태**를 저장하고 관리한다.

#### 🧩 저장 정보

| 구분 | 예시 |
|------|------|
| **객체 정의 정보** | 테이블, 인덱스, 뷰, 도메인, 트리거, 제약조건 등 |
| **접근 권한 정보** | 사용자, 역할, 권한 등 |
| **구조 정보** | 속성명, 데이터 타입, 길이, 키 정보 등 |
| **사용 통계 정보** | 데이터 접근 빈도, 사용량 등 |
| **DB 구성 정보** | 저장공간 구조, 스키마 정보 등 |

#### 🧩 특징 요약

- **DBMS가 자동으로 생성하고 관리**
- **일반 사용자는 조회만 가능, 수정은 불가능**
- **데이터베이스 객체의 정의 및 상태를 확인**할 수 있는 내부 테이블
- **DB 관리, 질의 최적화, 보안 처리** 등에 사용
- RDBMS에서 **시스템 테이블로 구현**되며, 사용자가 SELECT 문으로 확인 가능

#### 📝 기출 포맷 예시

- 시스템 카탈로그에 **저장되지 않는 정보**는?
- 시스템 카탈로그에 저장되는 **객체 정보**로 옳은 것은?
- 다음 중 시스템 카탈로그의 **특징 또는 역할**으로 적절하지 않은 것은?
- 시스템 카탈로그는 일반 사용자에게 어떤 **권한**이 부여되는가?

#### 🧠 용어 설명

- **시스템 카탈로그(System Catalog)**: DB 객체 및 구조 정보를 저장하는 시스템 테이블
- **데이터 사전(Data Dictionary)**: 시스템 카탈로그의 또 다른 명칭
- **메타데이터(Metadata)**: 데이터를 설명하는 데이터 (예: 구조, 속성, 제약 등)
- **DB 객체**: 테이블, 뷰, 인덱스 등 데이터베이스를 구성하는 요소

---

### 092. 트랜잭션 (Transaction)

#### 📘 정의
트랜잭션은 **데이터베이스에서 하나의 논리적인 작업 단위**를 의미한다.  
여러 개의 연산(삽입, 갱신, 삭제 등)을 묶어서 **모두 성공하거나, 전부 실패해야 하는 최소 단위**이다.  
→ 트랜잭션은 **데이터 무결성 및 일관성 유지**를 위한 기본 단위로, DBMS가 지원하는 핵심 개념이다.

#### 🧩 주요 목적

- 데이터 **정합성 유지**: 작업 중간에 오류가 나도 데이터의 상태가 망가지지 않도록 함
- **원자적 처리 보장**: 작업이 분할되지 않고 하나의 단위로 처리되도록 보장
- **시스템 장애 대비**: 복구 기능(Rollback)을 통해 신뢰성 확보
- **동시성 환경 지원**: 여러 사용자 요청에도 데이터 불일치가 없도록 보장

#### 🧩 주요 동작 명령

| 명령어 | 설명 |
|--------|------|
| **BEGIN** | 트랜잭션의 시작 |
| **COMMIT** | 트랜잭션 내 작업을 모두 성공적으로 반영 |
| **ROLLBACK** | 트랜잭션 내 작업을 모두 취소하고 이전 상태로 복구 |

#### 🧩 특징 요약

- 트랜잭션은 **논리적 작업 단위**로 데이터 안정성을 보장
- **모든 연산은 성공 또는 실패의 두 가지 결과 중 하나**로 끝나야 함
- 트랜잭션 수행 중 장애 발생 시 **복구 메커니즘을 통해 데이터 일관성 유지**

#### 📝 기출 포맷 예시

- 트랜잭션의 **정의 또는 목적**으로 옳은 것은?
- 트랜잭션 수행 중 오류 발생 시 **올바른 조치**는?
- 트랜잭션에서 사용되는 **명령어 설명**으로 적절하지 않은 것은?

#### 🧠 용어 설명

- **트랜잭션(Transaction)**: 하나의 논리적 작업 단위
- **COMMIT**: 트랜잭션 완료 후 결과를 데이터베이스에 확정 반영
- **ROLLBACK**: 트랜잭션 실패 시 작업을 취소하고 이전 상태로 복원
- **정합성**: 데이터의 논리적 일관성과 정확성

### 093. 트랜잭션의 특성 (ACID)

#### 📘 정의
트랜잭션(Transaction)은 **데이터베이스에서 하나의 논리적 단위로 처리되는 작업의 집합**이다.  
트랜잭션은 반드시 **모두 성공하거나, 전혀 수행되지 않아야 하며**, 데이터의 **정확성과 일관성 유지**를 위해 아래 네 가지 특성을 만족해야 한다.

#### 🧩 트랜잭션의 4대 특성 (ACID)

| 특성 | 설명 |
|------|------|
| **원자성 (Atomicity)** | 트랜잭션의 작업은 모두 실행되거나 전혀 실행되지 않아야 함. 중간 실패 시 전체 작업을 취소하고 원상 복구함. |
| **일관성 (Consistency)** | 트랜잭션 전후의 데이터베이스 상태는 항상 일관성을 유지해야 함. 제약조건 위반 없이 무결성 보장. |
| **독립성 / 격리성 / 순차성 (Isolation)** | 여러 트랜잭션이 동시에 수행될 때, 각 트랜잭션은 독립적으로 실행되어야 하며, 서로의 중간 결과에 간섭하지 않아야 함. <br>→ 결과는 마치 순차적으로 처리된 것처럼 보여야 함. |
| **지속성 (Durability)** | 트랜잭션이 완료되면 그 결과는 시스템 장애와 무관하게 **영구적으로 저장**되어야 함. |

#### 🧩 트랜잭션 상태 변화

트랜잭션은 실행 도중 여러 상태를 거치며, 아래와 같은 흐름으로 진행된다:

| 상태 | 설명 |
|------|------|
| **활동(Active)** | 트랜잭션이 실행 중인 상태 |
| **부분 완료(Partially Committed)** | 마지막 명령문까지 실행된 상태 (아직 완전 반영 전) |
| **완료(Committed)** | 모든 작업이 성공적으로 끝나고 DB에 영구 반영된 상태 |
| **실패(Failed)** | 실행 도중 오류 발생으로 중단된 상태 |
| **철회(Aborted)** | 트랜잭션이 취소되어 Rollback된 상태 (되돌리기 완료) |

✅ 트랜잭션은 **활동 → 부분 완료 → 완료** 또는  
**활동 → 실패 → 철회 → 재시도 또는 종료** 경로로 상태 전이가 발생함


#### 🧩 특징 요약

- 트랜잭션은 **데이터의 무결성과 일관성**을 위한 핵심 단위
- **장애 발생 시 회복**을 통해 데이터 복구 가능
- 동시성과 보안성 측면에서도 **트랜잭션 제어**가 중요

#### 📝 기출 포맷 예시

- 트랜잭션의 **ACID 특성 중 올바르지 않은 것**은?
- 다음 중 **Isolation(고립성)의 설명**으로 옳은 것은?
- 트랜잭션에서 **원자성과 지속성**의 의미를 고른 것은?

#### 🧠 용어 설명

- **트랜잭션(Transaction)**: 하나의 논리적 작업 단위
- **ACID**: 트랜잭션이 만족해야 할 네 가지 속성
- **격리성(독립성, 순차성)**: 동시에 실행해도 간섭 없이 수행되도록 보장
- **지속성(Durability)**: 트랜잭션 종료 후 결과는 영구 반영

---

### 094. CRUD 분석

#### 📘 정의
CRUD 분석은 **데이터베이스 내 각 개체(Entity)에 대해 수행되는 주요 연산(Create, Read, Update, Delete)**를  
분석하여 **트랜잭션 흐름과 데이터 처리 구조를 명확히 파악**하는 기법이다.  
업무 기능과 데이터 간의 연관성을 분석해 **테이블 설계, 트랜잭션 정의, 역할 분담 등에 활용**된다.
-> 프로세스와 테이블 간에 CRUD 매트릭스를 만들어서 트랜잭션을 분석

#### 🧩 CRUD의 구성

| 연산 | 설명 |
|------|------|
| **C(Create)** | 새로운 데이터를 생성 (삽입, 입력 등) |
| **R(Read)**    | 기존 데이터를 조회 (검색, 참조 등) |
| **U(Update)**  | 기존 데이터를 수정 (갱신, 변경 등) |
| **D(Delete)**  | 기존 데이터를 삭제 (제거, 폐기 등) |

#### 🧩 분석 목적

- **업무 기능별 데이터 사용 현황 파악**
- **테이블별 사용 빈도 및 역할 분석**
- **데이터 중심 트랜잭션 설계 근거 확보**
- **이상 현상 방지 및 설계 오류 예방**

#### 🧩 CRUD 매트릭스 (CRUD Matrix)

| 업무 기능 ↓ / 테이블 → | 사원 | 부서 | 프로젝트 |
|------------------------|------|------|----------|
| 사원 등록              | C    |      |          |
| 사원 조회              | R    |      |          |
| 부서 이동              | U    | R    |          |
| 퇴사 처리              | D    |      |          |

- **행 = 업무 기능**, **열 = 테이블 또는 엔터티**
- 각 교차점에 해당 작업이 어떤 CRUD 연산인지 표시

#### 🧩 특징 요약

- **업무 중심으로 데이터 흐름 분석 가능**
- 트랜잭션 정의 및 **데이터 무결성 확보에 기여**
- **CRUD 행렬로 시각화 가능**하여 설계 검증에 유용

#### 📝 기출 포맷 예시

- CRUD 분석의 **목적 또는 활용**으로 옳은 것은?
- 다음 중 CRUD 매트릭스에서 **정확히 매칭되지 않는 예**는?
- CRUD 분석을 통해 **얻을 수 있는 효과**로 옳지 않은 것은?

#### 🧠 용어 설명

- **CRUD**: 데이터 생성(Create), 조회(Read), 수정(Update), 삭제(Delete) 연산의 약어
- **CRUD 매트릭스**: 업무 기능과 데이터 테이블 간의 CRUD 관계를 표로 나타낸 분석 도구

---

### 095. 인덱스 (Index)

#### 📘 정의
인덱스는 **데이터 검색 속도를 향상시키기 위해 사용하는 보조적인 데이터 구조**이다.  
책의 목차처럼, 원하는 데이터를 빠르게 찾을 수 있도록 **테이블의 특정 열(속성)에 대한 정보를 미리 구성**해 놓는다.  
→ **WHERE 절, 조인, 정렬, 그룹핑 등에서 성능 개선**에 효과적이다.

#### 🧩 인덱스의 구성

| 구성 요소 | 설명 |
|-----------|------|
| **인덱스 키(Key)** | 인덱스를 생성할 기준이 되는 컬럼 |
| **포인터** | 인덱스 키가 가리키는 실제 데이터 위치를 저장 |

#### 🧩 인덱스의 종류

| 종류 | 설명 |
|------|------|
| **단일 인덱스** | 하나의 열을 기준으로 생성 |
| **복합 인덱스** | 둘 이상의 열을 결합하여 생성 |
| **고유 인덱스** | 중복이 허용되지 않는 키에 생성 (예: 기본키) |
| **비고유 인덱스** | 중복 허용 컬럼에 생성 가능 |
| **클러스터드 인덱스 (Clustered)** | 실제 데이터가 인덱스 순서대로 정렬되어 저장됨 |
| **넌클러스터드 인덱스 (Non-Clustered)** | 인덱스와 실제 데이터가 분리되어 존재 |

#### 🧩 인덱스 사용 시 고려사항

- **검색 속도는 향상되지만**, 인덱스 유지 비용이 발생함 (삽입·삭제·갱신 시 성능 저하)
- **자주 조회되거나 정렬되는 컬럼**에 적용하는 것이 효과적
- **인덱스 남용 시 오히려 성능 저하** 가능성 있음

#### 🧩 특징 요약

- **검색, 정렬, 집계 성능 향상**
- **테이블 변경 연산 시 오버헤드 존재**
- **적절한 컬럼 선택이 핵심**

#### 📝 기출 포맷 예시

- 인덱스의 **주요 기능 또는 장점**으로 옳지 않은 것은?
- 인덱스가 **효과적으로 적용되는 상황**은?
- **클러스터드 인덱스와 넌클러스터드 인덱스의 차이점**은?

#### 🧠 용어 설명

- **인덱스(Index)**: 검색 성능을 향상시키는 보조 데이터 구조
- **클러스터드 인덱스**: 인덱스 순서대로 실제 데이터가 정렬되어 저장되는 구조
- **넌클러스터드 인덱스**: 인덱스와 실제 데이터가 분리되어 존재하는 구조
- **복합 인덱스**: 여러 열을 기준으로 구성된 인덱스
