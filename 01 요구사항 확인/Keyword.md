## 001. 소프트웨어 생명 주기 (SDLC)

- [ ] **SDLC** = Software Development Life Cycle = 소프트웨어 생명 주기
- [ ] **6단계**: 계획 → 분석 → 설계 → 구현 → 테스트 → 유지보수
- [ ] 각 단계의 **산출물**: 요구사항 명세서, 설계서, 테스트 계획서 등
- [ ] **폭포수 모형**이 대표적인 SDLC 구조
- [ ] 목적: **품질 관리**와 **체계적 개발**

---

## 002. 나선형 모형 (Spiral Model)

- [ ] **프로토타입 개발** + **위험 분석** 강화한 반복적 개발 모델
- [ ] **4단계 반복**: 계획 수립 → 위험 분석 → 개발 및 검증 → 고객 평가
- [ ] **Risk Analysis(위험 분석)**이 중심
- [ ] **점진적 개발**, 변화에 유연 대응
- [ ] **반복(iteration)**마다 기능과 범위 확장

---

## 003. 폭포수 모형 (Waterfall Model)

- [ ] **순차적 진행**, **이전 단계로 되돌아갈 수 없음**
- [ ] **문서화 중심** 관리, 요구사항이 명확한 프로젝트에 적합
- [ ] **장점**: 단계별 문서화, 일정/비용 예측 쉬움, 이해 쉬움
- [ ] **단점**: 변경에 비유연, 사용자 피드백 반영 어려움
- [ ] 각 단계 종료 후 **승인**하고 다음 단계 진행

---

## 004. 애자일 모형 (Agile Model)

- [ ] **민첩하게 대응**, **반복적이고 점진적** 개발
- [ ] **변화 수용**, **빠른 피드백**, **지속적 개선**
- [ ] **작동하는 소프트웨어** > 문서, **변화 대응** > 계획
- [ ] **대표 기법**: 스크럼(Scrum), XP, 칸반(Kanban), Lean, FDD
- [ ] 고객과의 소통, 피드백, 빠른 납품 중심

---

## 005. 애자일 개발 4가지 핵심 가치

- [ ] **애자일 선언문**(Agile Manifesto) 2001년 발표
- [ ] **개인과 상호작용** > 프로세스와 도구
- [ ] **작동하는 소프트웨어** > 포괄적인 문서
- [ ] **고객과의 협업** > 계약 협상
- [ ] **변화에의 대응** > 계획을 따르기

---

## 006. 소프트웨어 공학 (Software Engineering)

- [ ] **체계적이고 공학적 접근**으로 효율적 개발/운영/유지보수
- [ ] 목표: **품질 향상**과 **생산성 증대**
- [ ] **현대적 기술** 지속 적용
- [ ] **품질 지속 검증**
- [ ] **개발 결과와 활동** 명확히 기록

---

## 007. 스크럼 개발 프로세스

- [ ] **반복적이고 점진적** 애자일 방법론
- [ ] **스프린트(Sprint)**: 고정 기간(2~4주) 개발 단위
- [ ] **5단계**: 스프린트 계획 → 스프린트 → 일일 스크럼 → 스프린트 검토 → 스프린트 회고
- [ ] **일일 스크럼**: 매일 15분, 진행상황과 장애요인 공유
- [ ] **자율적 팀 협력**, 고정 기간 내 목표 달성

---

## 008. XP (eXtreme Programming)

- [ ] **극단적 개발 모범 사례** 실천하는 애자일 방법론
- [ ] **5가지 핵심 가치**: 의사소통, 단순성, 용기, 존중, 피드백
- [ ] 소규모 팀, **빠른 릴리즈**와 **지속적 통합** 중시
- [ ] **요구사항 변화**에 유연 대응
- [ ] **고객 요구사항** 변화에 민첩하게 대응

---

## 009. XP의 주요 실천 방법 (Practice)

- [ ] **Pair Programming(짝 프로그래밍)**: 두 명이 한 컴퓨터로 함께 코딩
- [ ] **Test-Driven Development(TDD)**: 테스트 먼저 작성, 그다음 실제 코드
- [ ] **Continuous Integration(지속적 통합)**: 코드 변경시마다 통합 및 자동 테스트
- [ ] **Refactoring(리팩토링)**: 기능 변화 없이 구조 개선
- [ ] **Small Releases(소규모 릴리즈)**: 빠르고 자주 릴리즈
- [ ] **Collective Ownership(공동 코드 소유)**: 모든 팀원이 모든 코드에 책임

---

## 010. 데이터베이스 관리 시스템 (DBMS)

- [ ] **DBMS** = DataBase Management System
- [ ] 사용자와 DB 사이에서 **데이터 효율적 관리** 소프트웨어
- [ ] **무결성, 보안, 일관성, 공유성** 보장
- [ ] **선정 고려사항**: 가용성, 성능, 기술 지원, 상호 호환성, 구축 비용
- [ ] **데이터 저장, 질의 처리, 트랜잭션 관리** 수행

---

## 011. 기능 요구사항

- [ ] **Functional Requirements**: 시스템이 **무엇을 해야 하는지**
- [ ] **사용자가 수행할 수 있어야 하는 기능** 명시
- [ ] **입력/출력 흐름, 처리 방식, 저장/검색/연산 기능** 포함
- [ ] **명확하게 정의 가능**하고 **테스트 가능**
- [ ] 사용자가 제공받기 원하는 기능

---

## 012. 비기능 요구사항

- [ ] **Non-functional Requirements**: 시스템이 **어떻게 동작해야 하는지**
- [ ] **품질 특성** 정의: 성능, 보안, 가용성, 호환성 등
- [ ] **성능**: 응답시간, 처리량, 자원 효율성
- [ ] **보안**: 접근 제어, 데이터 보호
- [ ] **가용성, 사용성, 이식성, 유지보수성, 제약사항** 포함

---

## 013. 요구사항 명세 기법

- [ ] 사용자 요구를 **문서화하고 개발자가 이해**할 수 있도록 표현
- [ ] **정형 기법**: 수학적 기반, 명확하고 일관성 (VDM, Z, Petri-net, CSP)
- [ ] **비정형 기법**: 자연어 기반, 직관적 (FSM, ERD, 상태 다이어그램, SADT)
- [ ] **정형**: 오류 예방, 자동 분석 가능 vs **비정형**: 이해 쉬움, 작성 간편
- [ ] 사용 목적과 상황에 따라 선택

---

## 014. 요구사항 개발 프로세스

- [ ] **요구공학**(Requirement Engineering): 요구사항을 다루는 전체 활동
- [ ] **타당성 조사**(Feasibility Study)가 먼저 선행
- [ ] **4단계**: 도출(Elicitation) → 분석(Analysis) → 명세화(Specification) → 확인(Validation)
- [ ] **도출**: 사용자 인터뷰, 회의 등으로 요구 수집
- [ ] **분석**: 충돌·중복·누락 검토, **명세화**: 문서화, **확인**: 실제 의도 충족 검토

---

## 015. 요구사항 분석

- [ ] **Requirement Analysis**: 사용자 요구를 이해하고 **실현 가능성·비용·일정** 고려해 문서화
- [ ] **구체적이고 명확하게 추출**, 요구사항 간 **충돌, 중복, 누락** 분석
- [ ] **비용/일정/기술 가능성 평가** 포함
- [ ] **기능 목록과 우선순위** 정의
- [ ] 개발 대상 시스템의 **범위와 목적** 명확화

---

## 016. 자료 흐름도 (DFD: Data Flow Diagram)

- [ ] **DFD** = Data Flow Diagram = 자료 흐름도
- [ ] **처리 과정, 데이터 흐름, 저장소, 외부 개체** 간 관계를 시각적 표현
- [ ] **구조적 분석 기법**에 이용, **논리적 흐름** 표현
- [ ] **물리적 DFD**: 실제 시스템 구성요소 중심
- [ ] **논리적 DFD**: 처리 기능과 데이터 흐름 중심, 구현 독립적

---

## 017. 자료 흐름도의 구성 요소

- [ ] **4가지 구성 요소**: 프로세스, 자료 흐름, 자료 저장소, 단말
- [ ] **프로세스**: 원(○) 또는 사각형, **입력을 처리하여 출력**으로 변환
- [ ] **자료 흐름**: 화살표(→), **데이터 이동 방향**
- [ ] **자료 저장소**: 이중선(=) 또는 열린 사각형, **데이터 저장 장소**
- [ ] **단말**: 사각형, **외부 개체**(External Entity, Terminator)

---

## 018. 자료 사전 (DD: Data Dictionary)

- [ ] **Data Dictionary**: DFD에서 사용되는 **데이터 상세 정보** 구조적 정의
- [ ] **자료명, 구성, 형식, 단위, 출처** 명시
- [ ] **표현 기호**: `=`(정의), `+`(순차연결), `[]`(선택), `{}`(반복), `()`(생략가능)
- [ ] **데이터 일관성 유지, 중복 방지, 용어 통일**
- [ ] 자료 흐름, 자료 저장소, 프로세스 입출력 설명

---

## 019. 구조적 분석 기법 - SADT

- [ ] **SADT** = Structured Analysis and Design Technique
- [ ] **기능과 데이터 흐름**을 **계층적으로 분해**하여 표현
- [ ] **IDEF0 다이어그램** 형태로 표현
- [ ] **ICOM 구성요소**: Input(입력), Control(제어), Output(출력), Mechanism(기법)
- [ ] **DFD 기반** 상위 분석 기법, **기능 중심 분석**

---

## 020. 구조적 분석 기법 - HIPO

- [ ] **HIPO** = Hierarchy Input Process Output
- [ ] **계층적 다이어그램** 기반으로 **입력, 처리, 출력** 과정 구조화
- [ ] **히포 차트** + **IPO 차트** 함께 사용
- [ ] **H**: 계층 구조, **I**: 입력, **P**: 처리, **O**: 출력
- [ ] **상위 → 하위**로 분해하면서 시각화

---

## 021. UML (Unified Modeling Language)

- [ ] **UML** = Unified Modeling Language = 통합 모델링 언어
- [ ] **객체지향 모델링 언어**, 시스템 분석·설계·구현 전 과정에서 **시각적 모델링**
- [ ] **3대 구성요소**: 사물(Things), 관계(Relationships), 다이어그램(Diagram)
- [ ] **정적 모델링**(구조 중심) vs **동적 모델링**(상호작용·동작 흐름 중심)
- [ ] Rumbaugh(OMT), Booch, Jacobson 방법론 통합

---

## 022. 연관 관계 (Association)

- [ ] **Association**: 두 개 이상 클래스가 **서로 관련**되어 있는 기본 관계
- [ ] **실선(—)** 으로 표현, **방향성** 있거나 없을 수 있음
- [ ] **다중도(Multiplicity)** 표기: `1`, `0..1`, `*`, `1..*` 등
- [ ] **메시지 교환**, 실제 연결 나타냄
- [ ] 예: "사람 — 집" (사람은 집을 소유함)

---

## 023. 집합 관계 (Aggregation)

- [ ] **Aggregation**: **전체(Whole)와 부분(Part)** 포함 관계
- [ ] **빈 마름모(◇)** 기호를 **전체 객체** 쪽에 표현
- [ ] **포함(Has-a) 관계**, 부분 객체는 **전체와 독립적** 존재 가능
- [ ] **생명주기 독립**: 전체가 사라져도 부분은 존재
- [ ] 예: 컴퓨터 ◇── 프린터

---

## 024. 포함 관계 (Composition)

- [ ] **Composition**: **전체가 사라지면 부분도 함께 사라지는** 강한 관계
- [ ] **채워진 마름모(◆)** 기호를 **전체 객체** 쪽에 표현
- [ ] **생명주기 종속**: 전체의 생명주기에 따라 존재 여부 결정
- [ ] **생성과 소멸**이 전체와 완전히 일치
- [ ] 예: 집 ◆── 방

---

## 025. 일반화 관계 (Generalization)

- [ ] **Generalization**: **상위 클래스(부모)와 하위 클래스(자식)** 계층적 관계
- [ ] **속이 빈 삼각형(△)** 기호를 **상위 클래스** 쪽에 표현
- [ ] **상속(Inheritance)**: 상위 클래스의 **속성과 연산** 물려받음
- [ ] **"is-a" 관계**: "고양이는 동물이다"
- [ ] 객체지향 설계의 핵심 개념

---

## 026. 의존 관계 (Dependency)

- [ ] **Dependency**: 한 클래스가 다른 클래스에 **일시적으로 의존**
- [ ] **점선 화살표(---▶)** 로 표현
- [ ] **"사용한다(uses)" 관계**, **약한 결합**(Loose Coupling)
- [ ] **오퍼레이션의 매개변수**나 **지역 변수**로 사용할 때 발생
- [ ] 예: `등급 ---▶ 할인율`

---

## 027. 실체화 관계 (Realization)

- [ ] **Realization**: **인터페이스(기능 선언)**와 **구현 클래스(기능 실체)** 관계
- [ ] **점선 + 속이 빈 삼각형 (---▷)** 으로 표현
- [ ] **기능적 연결 관계**, 구현 클래스 ---▷ 인터페이스
- [ ] **추상적 기능**을 구현 클래스가 **실제로 실현**
- [ ] 예: `새 ---▷ 날 수 있다(Flyable)`

---

## 028. 다이어그램 (Diagram)

- [ ] **시스템을 다양한 관점**에서 **시각적으로 표현**하는 도구
- [ ] **2가지 대분류**: 구조적 다이어그램 vs 행위 다이어그램
- [ ] **구조적**: 정적 구조(클래스, 객체, 배치 등) - "무엇이 존재하는가"
- [ ] **행위**: 동적 행위나 흐름 - "어떻게 동작하는가"
- [ ] 개발자·분석가·디자이너 간 **의사소통** 도구

---

## 029. 구조적 다이어그램의 종류

- [ ] **정적 구조** 표현, 실행 시간과 관계없이 존재하는 **고정된 구조**
- [ ] **클래스**: 클래스 간 관계, 속성, 연산 (객체지향 설계 핵심)
- [ ] **객체**: 클래스 인스턴스 간 구조 (클래스 다이어그램의 구체화)
- [ ] **컴포넌트**: 소프트웨어 모듈 (파일, 라이브러리 등) 간 의존 관계
- [ ] **배치**: 물리적 실행 환경 (노드, 장치 등)
- [ ] **복합 구조, 패키지** 포함

---

## 030. 행위 다이어그램의 종류

- [ ] **동작, 이벤트, 상태 변화, 객체 간 상호작용** 표현
- [ ] **2가지 하위 분류**: 인터랙션(상호작용) vs 행위(Behavior)
- [ ] **유스케이스**: 사용자 ↔ 시스템, 기능(시나리오) 정의
- [ ] **시퀀스**: 객체 간 **메시지 전송 순서**(시간 흐름)
- [ ] **커뮤니케이션**: 객체 간 메시지 교환, **연결 관계** 기반
- [ ] **상태**: 객체 **상태 전이**, **활동**: 작업 흐름(절차)

---

## 031. 스테레오타입 (Stereotype)

- [ ] **기존 모델 요소의 의미를 확장**하거나 구체화하는 **메타데이터 태그**
- [ ] `«스테레오타입명»` 형태로 표현 (예: `«entity»`, `«controller»`)
- [ ] **특정 역할, 목적, 성격** 추가 명시
- [ ] **UML 확장 메커니즘**(Extension Mechanism)의 한 종류
- [ ] **사용자 정의 스테레오타입** 가능