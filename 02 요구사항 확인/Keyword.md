# 키워드 암기카드 - 요구사항 확인1 (032-061번)

## 032. 유스케이스 다이어그램 (Use Case Diagram)

- [ ] **사용자(액터)와 시스템**이 상호작용하는 **기능(유스케이스)** 관계 시각화
- [ ] **4가지 구성요소**: 액터(사람 아이콘), 유스케이스(타원○), 시스템 경계(사각형), 관계(선)
- [ ] **주액터**: 시스템 **주요 목표 달성**을 위한 상호작용 주체
- [ ] **부액터**: 시스템 동작의 **보조 역할** 수행하는 외부 주체
- [ ] **요구사항 분석**과 **시스템 범위 정의**에 사용

---

## 033. 유스케이스에서 나타날 수 있는 관계

- [ ] **연관(Association)**: 실선(—), 액터와 유스케이스 간 기본 상호작용
- [ ] **포함(Include)**: `<<include>>`, **무조건 실행**되는 공통 기능 분리
- [ ] **확장(Extend)**: `<<extend>>`, **조건부 실행**되는 선택 기능 추가
- [ ] **일반화(Generalization)**: 속 빈 삼각형(▷), 액터/유스케이스 간 **상속 관계**
- [ ] **Include는 필수**, **Extend는 선택적**

---

## 034. 활동 다이어그램 (Activity Diagram)

- [ ] **처리 흐름(로직)**을 시각적으로 표현하는 UML 행위 다이어그램
- [ ] **시작 노드**(●), **종료 노드**(●○), **액션**(둥근 사각형)
- [ ] **조건 노드**(◆): 입력 1 → 출력 N, **병합 노드**(◆): 입력 N → 출력 1
- [ ] **포크 노드**(굵은 실선): 병렬 분기, **조인 노드**(굵은 실선): 병렬 병합
- [ ] **스윔레인**: 역할/부서별 책임 구분 영역

---

## 035. 클래스 다이어그램 (Class Diagram)

- [ ] **클래스 간 구조적 관계**를 표현하는 정적 다이어그램
- [ ] **클래스**(사각형 3단): 클래스명/속성/연산
- [ ] **연관**(실선), **일반화**(속 빈 △), **집합**(빈 ◇), **합성**(채운 ◆), **의존**(점선 →)
- [ ] **속성**: 클래스가 가지는 데이터, **연산**: 클래스가 수행하는 기능
- [ ] 객체지향 설계의 핵심 도구

---

## 036. 연관 클래스 (Association Class)

- [ ] **연관 관계 자체에 속성이나 연산**이 필요한 경우 사용
- [ ] **점선으로 연관 관계와 연결**된 사각형으로 표현
- [ ] 관계에 **부가적인 의미, 이력, 상태** 등을 표현
- [ ] 예: 학생-과목 간 **수강** 관계(학점, 수강년도 등)
- [ ] **속성과 연산**을 가질 수 있음

---

## 037. 순차 다이어그램 (Sequence Diagram)

- [ ] **시간 흐름**에 따라 **객체 간 메시지 교환 순서** 표현
- [ ] **생명선**(세로 점선): 객체 존재 시간, **실행 상자**: 객체 동작 중 구간
- [ ] **메시지**(→): 객체 간 명령/요청/응답, **객체 소멸**(X)
- [ ] **액터**(:Actor), **객체**(객체명:), **프레임**(sd, alt 등)
- [ ] **시나리오 흐름 분석**에 유용

---

## 038. 커뮤니케이션 다이어그램 (Communication Diagram)

- [ ] **객체 간 상호작용 구조** + **메시지 순서**를 함께 표현
- [ ] **링크**(실선): 객체 간 연결 관계
- [ ] **메시지**에 **번호를 붙여 흐름 순서** 표현 (1:, 2: 등)
- [ ] **순차 다이어그램과 동일한 표현 대상**, 구조 중심 시각화
- [ ] **정보 흐름 + 객체 간 네트워크** 파악에 유리

---

## 039. 상태 다이어그램 (State Diagram)

- [ ] **이벤트 발생**에 따른 **상태 전이** 시각적 표현
- [ ] **상태**(둥근 사각형), **시작**(●), **종료**(●○), **전이**(→)
- [ ] **이벤트**가 상태 전이를 유발하는 트리거
- [ ] 객체의 **생명 주기(Life Cycle)** 표현
- [ ] **상태 기반 로직**을 시각화

---

## 040. 패키지 다이어그램 (Package Diagram)

- [ ] **패키지** 단위로 시스템을 나누고 **패키지 간 의존 관계** 표현
- [ ] **패키지**(폴더 모양), **의존 관계**(점선 화살표)
- [ ] **<<import>>**: 다른 패키지 **객체를 직접 가져와** 사용
- [ ] **<<access>>**: 다른 패키지에 **인터페이스를 통해 접근**
- [ ] **객체 간 의존 → 패키지 간 의존** 유도 (시험 출제 포인트)

---

## 041. 구조적 방법론 (Structured Methodology)

- [ ] **처리(Process) 중심**으로 분석·설계하는 전통적 절차적 개발 방법론
- [ ] **7단계**: 타당성 검토 → 계획 → 요구사항 분석 → 설계 → 구현 → 시험 → 운용 및 유지보수
- [ ] **DFD**(자료흐름도), **자료사전** 도구 활용
- [ ] **기능 흐름 분석** 포함
- [ ] **처리 중심 방법론**으로 시험에서 표현

---

## 042. 컴포넌트 기반 방법론 (Component-Based Methodology)

- [ ] **재사용 가능한 컴포넌트** 단위로 분리하고 **조립하여 시스템 완성**
- [ ] **7단계**: 개발준비 → 분석 → 설계 → 구현 → 테스트 → 전개 → 인도
- [ ] **독립적인 소프트웨어 모듈**, **인터페이스를 통해 통신**
- [ ] **결합도 낮고, 응집도 높음** → 변경 영향 최소화
- [ ] **재사용성, 확장성, 유지보수성** 향상

---

## 043. 소프트웨어 재사용 (Software Reuse)

- [ ] **검증된 소프트웨어 자산**을 새로운 시스템에 **재활용**하는 개발 기법
- [ ] **사전적 재사용**: 처음부터 재사용 염두에 두고 개발
- [ ] **사후적 재사용**: 기존 시스템에서 재사용 가능 요소 추출
- [ ] **코드/설계/문서 재사용** 가능
- [ ] **응집도 높고, 결합도 낮아야** 재사용 가능

---

## 044. CASE (Computer-Aided Software Engineering)

- [ ] **소프트웨어 개발 전 과정**을 **컴퓨터 기반 도구**로 지원하는 시스템
- [ ] **전방 CASE**: 요구사항 분석~설계, **후방 CASE**: 구현~테스트·유지보수
- [ ] **통합 CASE**: 전방+후방 기능 통합
- [ ] **도구/워크벤치/환경** 수준으로 분류
- [ ] **개발 생산성 향상**, **표준화**, **품질 향상**

---

## 045. LOC 기법 (Lines of Code)

- [ ] **소스코드 라인 수**로 소프트웨어 규모 측정하여 **비용 산정**
- [ ] **명령문 라인 수** 기준 (주석, 공백 제외)
- [ ] **정량적 비용 산정 기법**, 계산 간단하고 직관적
- [ ] **단점**: 언어·코딩 스타일·개발자 능력에 따라 편차 큼
- [ ] 중소 규모 프로젝트나 초기 견적에 자주 사용

---

## 046. 수학적 산정 기법 (Mathematical Estimation Techniques)

- [ ] **수학적 모델과 공식**으로 **노력·비용·일정** 정량적 산정
- [ ] **대표 기법**: LOC, FP(기능점수), COCOMO, Putnam, 델파이
- [ ] **정량적 산정 기법**에 해당
- [ ] 과거 데이터와 통계 기반
- [ ] **정확한 산정 근거**와 **객관적 비용 예측** 가능

---

## 047. COCOMO 모델 (Constructive Cost Model)

- [ ] **배리 보엠**(Barry Boehm)이 제안한 **LOC 기반 비용 산정 모델**
- [ ] **기본 공식**: `Effort(PM) = a × (KLOC)^b`
- [ ] **KLOC**: 천 줄(1000 LOC) 단위
- [ ] **a, b**: 개발 유형별 계수 (조직형, 반분리형, 내장형)
- [ ] **노력(Person-Month), 비용, 개발 기간** 추정

---

## 048. 소프트웨어 개발 유형 (COCOMO 개발 유형)

- [ ] **조직형(Organic)**: 소규모, 단순, 경험 많은 소수 팀
- [ ] **반분리형(Semi-Detached)**: 중간 규모, 보통 복잡도, 기능별 팀
- [ ] **내장형(Embedded)**: 대규모, 복잡, 제약 多, 실시간 시스템
- [ ] **계수(a, b)**: 조직형(작음) → 반분리형(중간) → 내장형(큼)
- [ ] 프로젝트 특성에 따라 COCOMO 계수 달라짐

---

## 049. Putnam 모델 (Putnam Model, SLIM)

- [ ] **Rayleigh-Norden 곡선** 기반 **노력 분포와 개발 기간** 예측
- [ ] **공식**: `E = (Size)^3 / (P × T^4)`
- [ ] **생산성 지수(P)** 활용, **일정(T)이 늘어나면 노력(E) 줄어듦**
- [ ] **인력 투입 곡선** 모델링 (시작 시 적고, 중후반 최대)
- [ ] **COCOMO보다 일정 중심 예측**에 강점

---

## 050. 기능 점수 모형 (Function Point, FP)

- [ ] **사용자 관점**에서 **기능적 요구사항** 기반으로 규모 정량화
- [ ] **5가지 구성**: 입력(I), 출력(O), 조회(IQ), 내부논리파일(ILF), 외부인터페이스파일(EIF)
- [ ] **산정 절차**: 기능 수 식별 → 기초 FP → 보정계수(VAF) → 최종 FP
- [ ] **공식**: `FP = 기초 FP × (0.65 + 0.01 × 총 보정계수)`
- [ ] **언어·환경 무관**, 초기 견적에 적합

---

## 051. 비용 산정 자동화 추정 도구

- [ ] **소프트웨어 개발 비용·일정·인력** 자동으로 예측하는 도구
- [ ] **COCOMO II**: LOC 기반, 객체지향·반복 개발 지원
- [ ] **SLIM**: Putnam 모델 기반, 생산성 지수(P) 활용
- [ ] **CheckPoint**: 위험 분석, **ESTIMACS**: FP 기반, **SEER-SEM**: AI 기술 적용
- [ ] **정확도 향상**, 경험적 데이터 기반

---

## 052. PERT (Program Evaluation and Review Technique)

- [ ] **불확실성**을 고려한 **네트워크 기반 일정 관리 기법**
- [ ] **3점 추정**: 낙관적(O), 비관적(P), 기대시간(M)
- [ ] **기대시간 공식**: `TE = (O + 4M + P) / 6`
- [ ] **확률 기반** (CPM은 확정적 시간)
- [ ] 작업 간 **의존 관계** 표현 가능

---

## 053. CPM (Critical Path Method)

- [ ] **주 경로(Critical Path)** 식별하는 일정 관리 기법
- [ ] **주 경로**: 전체 일정 중 가장 긴 경로, **여유 시간 0**
- [ ] **네트워크 다이어그램**으로 표현
- [ ] **총 여유 시간**: 작업 지연되어도 전체 일정에 영향 없는 시간
- [ ] **확정적 시간** 기반 (PERT는 확률적)

---

## 054. 간트 차트 (Gantt Chart)

- [ ] **작업 일정**을 **막대 그래프**로 표현한 프로젝트 관리 도구
- [ ] **구성**: 작업(Task), 시간축, 막대(Bar), 진척도
- [ ] **막대**: 왼쪽(시작일), 오른쪽(종료일)
- [ ] **시각적으로 직관적**, 진행 상황 모니터링 효과적
- [ ] **작업 간 선후 관계 표현은 제한적**

---

## 055. ISO/IEC 12207

- [ ] **소프트웨어 생명주기** 표준 절차와 활동 정의한 **국제 표준**
- [ ] **3가지 프로세스**: 기본 생명주기, 지원 생명주기, 조직 생명주기
- [ ] **기본**: 개발·운영·유지보수, **지원**: 문서화·검증·품질보증·형상관리
- [ ] **조직**: 관리·인프라·개선·교육·재사용
- [ ] **프로세스 기반 품질 관리** 체계 수립

---

## 056. CMMI (Capability Maturity Model Integration)

- [ ] **조직의 프로세스 성숙도** 평가하고 개선하는 국제 표준 모델
- [ ] **5단계**: 초기(1) → 관리(2) → 정의(3) → 정량적 관리(4) → 최적화(5)
- [ ] **Level 1**: 비정형적, **Level 2**: 프로젝트 단위 관리
- [ ] **Level 3**: 조직 표준 프로세스, **Level 4**: 정량적 측정·통제, **Level 5**: 지속적 개선
- [ ] **프로세스 중심** 조직 개선 프레임워크

---

## 057. SPICE (Software Process Improvement and Capability dEtermination)

- [ ] **ISO/IEC 15504**, **프로세스 성숙도와 수행 능력** 평가·개선 국제 표준
- [ ] **PAM**(프로세스 평가 모델), **PRM**(프로세스 참조 모델)
- [ ] **측정 프레임워크**: 수행 능력을 **0~5단계**로 계량화
- [ ] **조직 맞춤 적용(Tailoring)** 가능한 유연한 구조
- [ ] CMMI와 유사하지만 **개별 프로세스 기준 평가** 가능

---

## 058. SPICE의 수행 능력 단계

- [ ] **6단계**: 0(불완전) → 1(수행됨) → 2(관리됨) → 3(확립됨) → 4(예측됨) → 5(최적화됨)
- [ ] **Level 0**: 목적 달성 못함, **Level 1**: 최소 산출물 생성
- [ ] **Level 2**: 계획·모니터링·문서화, **Level 3**: 조직 표준 프로세스 기반
- [ ] **Level 4**: 정량적 측정·통제, **Level 5**: 지속적 개선·혁신
- [ ] 각 프로세스마다 **개별 수행 수준** 부여 가능

---

## 059. 소프트웨어 개발 방법론 테일러링

- [ ] **조직/프로젝트 특성**에 맞게 개발 방법론을 **선택·수정·재구성**
- [ ] **내부적 기준**: 목표환경, 요구사항, 프로젝트 규모, 보유 기술·자원
- [ ] **외부적 기준**: 법적 제약사항, 표준 및 품질 기준
- [ ] **조정 항목**: 활동, 산출물, 역할, 절차
- [ ] **효율성과 실용성** 높이기 위한 맞춤형 적용

---

## 060. 소프트웨어 개발 프레임워크

- [ ] **소프트웨어 생명주기** 전반에 **표준화된 절차·도구·산출물·역할** 통합 제공
- [ ] **구성**: 개발 절차, 산출물 템플릿, 역할·책임, 지원 도구, 개발 방법론
- [ ] **목적**: 개발 표준 일관성, 생산성·품질 향상, 절차 체계화
- [ ] **일관된 개발 환경** 제공
- [ ] 산출물 자동 생성 등 **도구 지원** 통한 효율화

---

## 061. 소프트웨어 개발 프레임워크의 특성

- [ ] **모듈화(Modularity)**: 인터페이스 기반 캡슐화, 변경 영향 최소화
- [ ] **재사용성(Reusability)**: 템플릿·모듈·컴포넌트 반복 활용 가능
- [ ] **확장성(Extensibility)**: 다형성 기반 인터페이스 확장 가능
- [ ] **제어의 역흐름(IoC)**: 프레임워크가 전체 흐름 제어, 필요 지점에서 사용자 코드 호출
- [ ] **4가지 핵심 특성**으로 개발 효율성 향상