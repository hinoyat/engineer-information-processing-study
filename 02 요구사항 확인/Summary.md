### 032. 유스케이스 다이어그램 (Use Case Diagram)

#### 📘 정의
유스케이스 다이어그램은 **사용자(액터)와 시스템이 상호작용하는 기능(유스케이스)의 관계를 시각화**한 UML 행위 다이어그램이다.  
시스템이 제공해야 할 **기능 단위의 요구사항을 분석하고 표현**하는 데 사용된다.

#### 🧩 핵심 개념 요약
- **사용자(Actor)**와 **유스케이스(Use Case)** 간 상호작용 관계를 표현
- 시스템의 **기능 요구사항 도출과 범위 정의**에 적합
- **Include / Extend / Generalization** 관계로 유스케이스 간 구조화 가능
- **주액터 / 부액터**를 구분하여 **시스템 목표 중심 분석** 가능

#### 🧩 주요 구성 요소

| 구성 요소 | 기호 | 설명 |
|-----------|------|------|
| **액터(Actor)** | 사람 아이콘 / `:Actor` | 시스템 외부에서 상호작용하는 사용자 또는 시스템 |
| **유스케이스(Use Case)** | 타원 `○` | 사용자가 수행할 수 있는 기능 또는 서비스 |
| **시스템 경계(System Boundary)** | 사각형 | 유스케이스가 포함된 시스템의 범위를 나타냄 |
| **관계(Relationship)** | 선 + 키워드 | 연관(—), 포함(<<include>>), 확장(<<extend>>), 일반화(▷) |

#### 🧩 액터 유형

| 구분 | 설명 |
|------|------|
| **주액터 (Primary Actor)** | 시스템의 **주요 목표를 달성하기 위해 상호작용**하는 주체 |
| **부액터 (Secondary Actor)** | 시스템이 동작하는 데 **보조 역할을 수행**하는 외부 주체 |

#### 🖼️ 유스케이스 다이어그램 예시
![유스케이스 다이어그램 예시](./images/UML_use_case_example-800x707.png)

#### 🧩 유스케이스 관계 설명

| 관계 유형 | 표기 | 의미 |
|-----------|------|------|
| **연관 (Association)** | 실선 `—` | 액터와 유스케이스 간의 기본적인 호출 관계 |
| **포함 (Include)** | `<<include>>` | 공통 유스케이스를 여러 유스케이스에 포함시킬 때 사용 |
| **확장 (Extend)** | `<<extend>>` | 조건에 따라 선택적으로 실행되는 유스케이스 표현 |
| **일반화 (Generalization)** | 속 빈 삼각형 `▷` | 상속 관계, 액터 또는 유스케이스 간 계층 구조 표현 |

#### 📝 기출 포맷 예시
- 유스케이스 다이어그램에서 `<<include>>` 관계의 의미는?
- 다음 중 유스케이스 다이어그램의 구성 요소가 아닌 것은?
- 유스케이스 다이어그램에서 일반화 관계를 사용할 수 있는 대상은?

#### 🧠 용어 설명
- **유스케이스(Use Case)**: 사용자의 관점에서 시스템이 제공해야 하는 기능
- **액터(Actor)**: 시스템 외부에서 유스케이스를 수행하는 주체
- **주액터**: 시스템의 목표 달성을 위한 주요 사용자
- **부액터**: 보조 기능을 수행하거나 시스템에 간접적으로 연결된 주체
- **<<include>> / <<extend>>**: 유스케이스 간 필수/선택적 관계
- **일반화(Generalization)**: 상속 관계를 표현

---

### 033. 유스케이스에서 나타날 수 있는 관계

#### 📘 정의
유스케이스 다이어그램에서는 유스케이스와 유스케이스 간, 액터 간 관계를 통해 **기능 구조를 세분화하고 재사용성, 선택 흐름을 표현**할 수 있다.

#### 🧩 관계 유형 요약

| 관계 유형 | 표기 | 의미 |
|-----------|------|------|
| **연관 (Association)** | 실선 `—` | 액터와 유스케이스 간 상호작용 관계 |
| **포함 (Include)** | `<<include>>` | 여러 유스케이스에서 **공통으로 수행되는 기능**을 분리하여 재사용 |
| **확장 (Extend)** | `<<extend>>` | 유스케이스의 **기본 흐름에서 조건에 따라 추가 동작이 수행**될 때 사용 |
| **일반화 (Generalization)** | 속 빈 삼각형 `▷` | 액터 또는 유스케이스 간 **상속 관계**, 상위 개념의 기능을 하위에서 재사용 |

#### ✅ 관계 간 비교

| 구분 | Include | Extend |
|------|---------|--------|
| 실행 조건 | **무조건 실행** | **조건부 실행** |
| 방향 | 기본 → 포함 | 기본 → 확장 |
| 목적 | 공통 기능 분리 | 선택 기능 추가 |
| 예시 | 로그인 시 감사 로그 기록 | 결제 시 할인 적용 (조건부) |

#### 📝 기출 포맷 예시
- 다음 중 `<<include>>` 관계에 대한 설명으로 옳은 것은?
- 유스케이스 관계 중 조건부 흐름을 나타내는 것은?
- 유스케이스 간 재사용을 위해 사용하는 관계는?

#### 🧠 용어 설명
- **Include**: 반드시 포함되어야 하는 공통 기능
- **Extend**: 조건에 따라 선택적으로 실행되는 추가 기능
- **Generalization**: 공통 기능을 상속해 하위 유스케이스가 재사용
- **Association**: 액터와 유스케이스 간의 기본 연결 관계

---

### 034. 활동 다이어그램 (Activity Diagram)

#### 📘 정의
활동 다이어그램은 시스템이나 객체의 **처리 흐름(로직)** 을 시각적으로 표현하는 UML 행위 다이어그램입니다.  
**업무 절차, 조건 분기, 병렬 처리** 등을 표현하며, **요구사항 분석과 상세 설계 단계**에서 자주 활용됩니다.
#### 🖼️ 활동 다이어그램

![활동 다이어그램](./images/)

#### 🧩 핵심 개념 요약
- 액티비티 중심의 제어 흐름 표현
- 조건 분기, 반복, 병렬 처리 구조에 적합
- 흐름도와 유사하지만 UML의 표준 표현 도구
- 비즈니스 로직, 알고리즘 흐름 등 기술에 활용

#### 🧩 주요 구성 요소

| 구성 요소            | 설명 |
|---------------------|------|
| **액션 / 액티비티**   | 흐름 안에서 실제 수행되는 작업 단위. 둥근 사각형 안에 작업 이름이 들어감. |
| **시작 노드**         | 다이어그램 시작점. 검은 원(●) 하나로 표현. |
| **종료 노드**         | 흐름의 종료점. 이중 원(● 안에 ○)으로 표현. |
| **조건(판단) 노드**    | 조건에 따라 흐름이 분기되는 지점. 마름모(◆)에서 **화살표가 여러 개 나감** (출력 ≥ 2, 입력 1). |
| **병합 노드**         | 분기된 흐름이 다시 하나로 합쳐지는 지점. 마름모(◆)에서 **화살표가 여러 개 들어옴** (입력 ≥ 2, 출력 1). |
| **포크 노드**         | 하나의 흐름을 동시에 여러 개로 나누는 분기점. **가로로 된 굵은 실선**에서 **입력 1 → 출력 N (N ≥ 2)** |
| **조인 노드**         | 여러 흐름을 하나로 합치는 병합점. **가로 굵은 실선**에서 **입력 N (N ≥ 2) → 출력 1** |
| **스윔레인 노드**      | 역할, 부서 등 책임 단위별로 흐름을 구분하는 영역. 세로 또는 가로 칸막이 구획으로 나눔. |

#### 📝 기출 포맷 예시
- 활동 다이어그램에서 **병렬 흐름**을 나타내는 노드는?
- 다음 중 **조건 분기**를 표현하는 구성 요소는?
- **시작 노드와 종료 노드**를 나타내는 기호로 옳은 것은?

#### 🧠 용어 설명
- **액티비티(Activity)**: 작업 단위 또는 상태
- **전이(Transition)**: 흐름 제어를 위한 화살표
- **결정 노드(Decision Node)**: 조건 분기
- **병합 노드(Merge Node)**: 흐름 합류
- **포크/조인(Fork/Join)**: 병렬 처리 분기와 병합
- **시작/종료 노드**: 흐름의 출발점과 종착점
- **스윔레인(Swimlane)**: 역할이나 담당 주체별 구분

---

### 035. 클래스 다이어그램 (Class Diagram)

#### 📘 정의
클래스 다이어그램은 객체지향 시스템에서 **클래스 간의 구조적 관계**를 표현하는 정적 다이어그램이다.  
시스템이 어떤 **데이터 구조와 관계로 구성되어 있는지 시각적으로 표현**하며,  
주로 **설계 단계에서 사용**된다.

#### 🧩 핵심 개념 요약
- 클래스와 클래스 간의 **속성, 메서드, 관계**를 표현
- 객체지향의 **상속, 연관, 집합, 포함 관계**를 도식화
- 시스템의 **정적 구조 설계**를 위한 기본 UML 도구

#### 🧩 주요 구성 요소

| 구성 요소                      | 설명 |
|----------------------------|------|
| **클래스(Class)**             | 속성과 연산(메서드)으로 구성된 틀. 사각형 3단 구성으로 표현됨 (클래스명 / 속성 / 연산) |
| **속성(Attribute)**          | 클래스가 가지는 데이터 값. ex) 이름, 나이 |
| **연산 or 오퍼레이션(Operation)** | 클래스가 수행할 수 있는 기능 또는 메서드 |
| **관계(Relationship)**       | 클래스 간 연결 구조. 다음과 같은 관계가 존재함 |
| **제약조건(Constraint)** | 클래스나 관계에 부가적인 조건이나 규칙을 붙일 때 사용. 중괄호 `{}` 안에 표현함. 예: `{ordered}`, `{readOnly}` |

#### 🧩 클래스 간 관계 종류

| 관계 유형 | 기호 | 설명 |
|-----------|------|------|
| **연관 (Association)** | 실선 | 두 클래스가 서로 알고 있는 관계 |
| **일반화 (Generalization)** | 속 빈 삼각형 화살표 `▷` | 상위 클래스가 하위 클래스에 속성/연산을 물려줌 (상속) |
| **집합 (Aggregation)** | 속 빈 마름모 | 전체-부분 관계. 부분은 독립 생존 가능 |
| **합성 (Composition)** | 속 채운 마름모 | 전체-부분 관계. 부분은 전체가 없으면 존재 불가 |
| **의존 (Dependency)** | 점선 화살표 | 한 클래스가 다른 클래스를 잠깐 참조하는 약한 관계 |

#### 🖼️ 클래스 다이어그램

![클래스 다이어그램](./images/)

#### 📝 기출 포맷 예시
- 클래스 간에 강한 전체-부분 관계를 나타내는 관계는?
- 일반화 관계에 사용되는 기호는?
- 집합 관계와 합성 관계의 차이점은?

#### 🧠 용어 설명
- **클래스(Class)**: 객체의 속성과 연산을 정의한 설계도
- **속성(Attribute)**: 객체가 가지는 값(데이터 필드)
- **연산(Operation)**: 객체가 수행할 수 있는 동작
- **연관 / 의존 / 상속 / 집합 / 합성**: 클래스 간 구조적 관계

---

### 036. 연관 클래스 (Association Class)

#### 📘 정의
연관 클래스는 **클래스 간의 연관 관계 자체에 속성이나 연산이 필요한 경우**, 그 관계를 별도로 클래스처럼 표현한 것이다.  
즉, 두 클래스 사이의 연결선(Association)에 **추가 정보를 부여**할 때 사용한다.

#### 🧩 특징
- 일반적인 연관 관계는 단순 연결만 표현하지만, 연관 클래스는 **그 관계를 객체처럼 다룸**
- **연관선 위에 사각형으로 표현되며**, 점선으로 연관 관계와 연결됨
- **속성(attribute)** 과 **연산(operation)** 을 가질 수 있음
- 관계에 부가적인 의미, 이력, 상태 등을 담고 싶을 때 사용

#### 🧩 예시 상황
- 학생과 과목 간 관계에서, **수강 정보(학점, 수강년도 등)** 가 필요한 경우  
  → 학생 — 수강 — 과목 구조  
  → 여기서 ‘수강’이 연관 클래스

#### 🖼️ 연관 클래스 예시

![연관 클래스 예시](./images/)

#### 📝 기출 포맷 예시
- 클래스 다이어그램에서 연관 관계에 속성과 연산을 부여하려면 어떤 구조를 사용하는가?
- 연관 클래스는 어느 경우에 필요한가?

#### 🧠 용어 설명
- **연관 클래스 (Association Class)**: 두 클래스 간 연관 자체에 정보를 담기 위한 클래스
- **연관 관계 (Association)**: 클래스 간 연결을 나타내는 기본 구조
- **속성 / 연산**: 연관 클래스도 일반 클래스처럼 가질 수 있음

---

### 037. 순차 다이어그램 (Sequence Diagram)

#### 📘 정의
순차 다이어그램은 시스템이나 객체들이 **메시지를 주고받으며 상호작용하는 순서를 시간의 흐름에 따라 표현**하는 UML 행위 다이어그램이다.  
요구사항 분석 단계에서 사용되며, **객체 간 메시지 흐름과 상호작용의 순서**를 명확히 시각화할 수 있다.

#### 🧩 핵심 개념 요약
- 시간 흐름에 따라 **객체 간 메시지 교환 순서**를 표현
- 사용자 또는 시스템의 **시나리오 흐름 분석에 유용**
- 복잡한 프로세스를 **메시지 흐름 중심으로 단순화**해 표현 가능

#### 🧩 주요 구성 요소

| 구성 요소 | 기호 | 설명 |
|-----------|------|------|
| **액터(Actor)** | `:Actor` | 시스템 외부의 사용자 또는 외부 시스템 |
| **객체(Object)** | `객체명:` | 메시지를 주고받는 내부 주체 |
| **생명선(Lifeline)** | `│` (세로 점선) | 객체가 존재하는 시간 구간을 나타냄 |
| **실행 상자(Activation Box)** | `▭` | 객체가 동작 중인 구간 (메시지 처리 중) |
| **메시지(Message)** | `→` | 객체 간에 전송되는 명령, 요청, 응답 등 |
| **객체 소멸** | `X` | 객체의 생명이 종료되는 시점 |
| **프레임(Frame)** | `sd`, `alt` 등 키워드 박스 | 다이어그램 일부 시나리오를 묶는 구간 |

#### 🖼️ 순차 다이어그램 예시
> ※ 시험에선 주로 프레임 + 메시지 흐름 + 생명선 중심으로 출제됨

![순차 다이어그램 예시](./images/)

#### 📝 기출 포맷 예시
- 순차 다이어그램에서 **생명선은 무엇을 의미하는가?**
- **객체가 동작 중임을 나타내는 요소**는?
- 다음 중 **객체 소멸 시점**을 나타내는 기호는?

#### 🧠 용어 설명
- **Lifeline**: 객체가 메모리에 존재하는 시간 구간
- **Activation Box**: 메시지를 주고받는 동안 객체가 동작 중임을 나타내는 영역
- **Message**: 상호작용을 위해 전달되는 명령/데이터
- **Frame**: 시나리오 흐름의 구조적 구획
- **X 기호**: 객체 소멸 표현

---
### 038. 커뮤니케이션 다이어그램 (Communication Diagram)

#### 📘 정의
커뮤니케이션 다이어그램은 객체 간의 **상호작용 구조**를 중심으로 표현하는 UML 행위 다이어그램이다.  
**객체들이 어떻게 연결(Link)** 되어 있으며, **어떤 순서로 메시지를 주고받는지**를 함께 표현한다.

#### 🧩 핵심 개념 요약
- **객체 간 연결 구조 + 메시지 순서**를 함께 표현
- 메시지에 **번호를 붙여 흐름 순서**를 나타냄
- **순차 다이어그램과 동일한 표현 대상**이지만, 구조 중심 시각화
- **정보 흐름 + 객체 간 네트워크** 파악에 유리

#### 🧩 주요 구성 요소

| 구성 요소 | 기호 | 설명 |
|-----------|------|------|
| **액터(Actor)** | `:Actor` | 시스템 외부 사용자 또는 외부 시스템 |
| **객체(Object)** | `객체명:` | 메시지를 주고받는 내부 주체 |
| **링크(Link)** | `—` (실선) | 객체 간의 연결 관계 |
| **메시지(Message)** | `1:`, `2:` 등 번호 + 화살표 | 메시지 전달 순서 및 내용 |
| **프레임(Frame)** | `sd`, `ref` 등 키워드 박스 | 다이어그램의 전체 또는 일부 묶음 단위 |

#### 🖼️ 커뮤니케이션 다이어그램 예시
> ※ 객체 간 구조 + 메시지 흐름을 함께 표현함

![커뮤니케이션 다이어그램 예시](./images/)

#### 📝 기출 포맷 예시
- 커뮤니케이션 다이어그램에서 **링크의 의미**는?
- 다음 중 **메시지 순서를 함께 나타낼 수 있는 다이어그램**은?
- 커뮤니케이션 다이어그램에서 **프레임은 어떤 역할을 하는가?**

#### 🧠 용어 설명
- **Actor**: 시스템 외부의 사용자 또는 외부 시스템
- **Link**: 객체 간의 연결 관계
- **Message**: 객체 간 전달되는 명령/요청
- **Message Order**: 메시지의 발생 순서 (번호)
- **Frame**: 시나리오 또는 컨텍스트 범위 지정  

---

### 039. 상태 다이어그램 (State Diagram)

#### 📘 정의
상태 다이어그램은 시스템이나 객체가 **이벤트 발생에 따라 상태가 어떻게 전이되는지를 시각적으로 표현**하는 UML 행위 다이어그램이다.  
객체의 **생명 주기(Life Cycle)**, 동작 흐름, 상태 변화 조건 등을 명확히 나타낸다.

#### 🧩 핵심 개념 요약
- **객체 또는 시스템의 상태 변화** 흐름을 표현
- **이벤트 발생 → 상태 전이** 구조
- 복잡한 상태 기반 로직을 시각화
- **조건 분기, 반복 처리 흐름** 등에도 사용 가능

#### 🧩 주요 구성 요소

| 구성 요소              | 기호        | 설명                   |
|--------------------|-----------|----------------------|
| **상태(State)**      | 둥근 사각형    | 객체가 일정 시간 머무는 조건/상태  |
| **시작 상태(Start)**   | ●         | 상태 다이어그램의 시작점        |
| **종료 상태(End)**     | ●◯ (이중 원) | 상태 다이어그램의 종료점        |
| **전이(Transition)** | →         | 상태 간 이동을 나타내는 화살표    |
| **이벤트(Event)**     | `이벤트명()`  | 상태 전이를 유발하는 입력 또는 조건 |
| **프레임(Frame)**     | 박스 표시     | 다이어그램의 범위            |

#### 🖼️ 상태 다이어그램 예시
> ※ 이벤트를 통해 상태가 전이되는 흐름을 표현함

![상태 다이어그램 예시](./images/)

#### 📝 기출 포맷 예시
- 상태 다이어그램에서 **전이(Transition)**는 무엇을 의미하는가?
- 다음 중 **상태 다이어그램의 종료 상태를 나타내는 기호**는?
- 상태 전이를 **발생시키는 요소는 무엇인가?**

#### 🧠 용어 설명
- **State**: 객체가 유지되는 조건이나 상황
- **Transition**: 상태 간의 이동
- **Event**: 전이를 유발하는 트리거
- **Start/End**: 상태 흐름의 시작과 종료 위치  

---

### 040. 패키지 다이어그램 (Package Diagram)

#### 📘 정의
패키지 다이어그램은 시스템을 **논리적 단위인 패키지(Package)** 로 나누고,  
**패키지 간의 의존 관계**를 표현하는 UML 구조 다이어그램이다.  
복잡한 시스템 구조를 **모듈화하고 계층화**하는 데 활용된다.

#### 🧩 핵심 개념 요약
- 클래스, 유스케이스 등을 **패키지 단위로 그룹화**
- **패키지 간 의존 관계**를 표현 (`<<import>>`, `<<access>>`, `<<merge>>`)
- **객체 간 의존 관계를 기반으로 패키지 간 의존 유도**
- 시스템의 **구조 설계, 네임스페이스 관리, 모듈 재사용성 향상**에 유용

#### 🧩 주요 구성 요소

| 구성 요소 | 기호 | 설명 |
|-----------|------|------|
| **패키지(Package)** | 폴더 모양 상자 | 관련 UML 요소를 묶는 논리 단위 |
| **의존 관계(Dependency)** | 점선 화살표 `--->` | 다른 패키지에 접근하거나 참조하는 관계 |
| **<<import>>** | 점선 화살표 + `<<import>>` | 다른 패키지의 **객체를 직접 가져와 내부에서 사용** |
| **<<import>>** | 점선 화살표 + `<<import>>` | 다른 패키지의 **public 요소**를 직접 가져와 내부에서 사용함 (**객체를 직접 포함**) |
| **<<access>>** | 점선 화살표 + `<<access>>` | 다른 패키지의 **private 요소**에 인터페이스를 통해 접근함 (**간접 참조**) |
| **내포(Nesting)** | 패키지 내부에 또 다른 패키지 포함 | 계층적 구조 표현

#### 🧩 출제 개념: 객체 간 의존 → 패키지 간 의존
- 객체 A → 객체 B 간 의존이 있을 경우  
  → 객체 A가 속한 **패키지는 객체 B의 패키지에 의존**
- 즉, **패키지 간 의존 관계는 포함된 객체 간의 의존 관계에서 유도됨**
- 정보처리기사 실기에서 자주 출제되는 핵심 포인트

#### 🖼️ 패키지 다이어그램 예시
> ※ 의존 관계, 계층 구조 중심으로 표현됨

![패키지 다이어그램 예시](./images/)

#### 📝 기출 포맷 예시
- 다음 중 **`<<import>>` 관계의 설명으로 가장 적절한 것은?**
- 패키지 다이어그램에서 **`<<access>>` 관계는 어떤 방식으로 객체에 접근하는가?**
- **패키지 간 의존 관계는 무엇을 기준으로 형성되는가?**

#### 🧠 용어 설명
- **Package**: UML 요소를 논리적으로 묶은 모듈 단위
- **Dependency**: 다른 패키지를 참조하거나 사용하는 관계
- **Import**: 외부 패키지의 객체를 직접 가져와 사용
- **Access**: 외부 패키지의 객체에 인터페이스를 통해 접근
- **Merge**: 두 패키지를 병합하여 확장
- **Nesting**: 패키지 안에 또 다른 패키지를 포함
- **객체 간 의존 → 패키지 간 의존**: 시험 출제 핵심 구조  

---

### 041. 구조적 방법론 (Structured Methodology)

#### 📘 정의
구조적 방법론은 시스템을 **처리(Process) 중심으로 분석·설계**하는 전통적인 절차적 개발 방법론이다.  
시스템이 수행해야 할 **기능을 중심으로 처리 흐름을 정의**하며,  
**데이터 흐름도(DFD)**를 통해 전체 시스템의 구조와 흐름을 표현한다.

> ※ 일부 서술에서는 "기능 중심"이란 표현도 사용되지만,  
> 정보처리기사 시험에서는 반드시 "**처리 중심 방법론**"으로 표현해야 정답 처리됨.

#### 🧩 개발 절차
> ※ 교재 기준 순서 정리

1. **요구사항 정의**
2. **기능 분해 및 자료 흐름 도식화**
3. **자료 흐름도(DFD) 작성**
4. **자료 사전 작성**
5. **프로세스 명세서 작성**

#### 🧩 시험 출제 포인트 요약
- **처리 중심** 설계 방식 (기능 흐름 분석 포함)
- **DFD, 자료사전** 도구의 목적과 용도 구분
- **개발 절차 순서** 관련 문제 출제 다수

#### 🧠 용어 설명
- **DFD (Data Flow Diagram)**: 처리 기능 간 데이터 흐름을 도식화한 도구
- **자료 사전(Data Dictionary)**: DFD에 사용된 데이터 항목을 정의한 명세서
- **프로세스 명세서 (Process Spec)**: 각 기능(프로세스)의 처리 내용을 기술
- **기능 분해 (Functional Decomposition)**: 상위 기능을 점진적으로 세분화하는 설계 기법
- **처리 중심(=기능 흐름 중심)**: 시스템이 수행할 처리 과정을 분석하고 흐름에 따라 구조화하는 방식  

---

### 041. 구조적 방법론 (Structured Methodology)

#### 📘 정의
구조적 방법론은 시스템을 **처리(Process) 중심으로 분석·설계**하는 전통적인 절차적 개발 방법론이다.  
시스템이 수행해야 할 **기능을 중심으로 처리 흐름을 정의**하며,  
**데이터 흐름도(DFD)**를 통해 전체 시스템의 구조와 흐름을 표현한다.

> ※ 일부 서술에서는 "기능 중심"이란 표현도 사용되지만,  
> 정보처리기사 시험에서는 반드시 "**처리 중심 방법론**"으로 표현해야 정답 처리됨.

#### 🧩 개발 단계

1. **타당성 검토**
2. **계획**
3. **요구사항 분석**
4. **설계**
5. **구현**
6. **시험(Test)**
7. **운용 및 유지보수**

#### 🧩 시험 출제 포인트 요약
- **처리 중심** 설계 방식 (기능 흐름 분석 포함)
- **DFD, 자료사전** 도구의 목적과 용도 구분
- **개발 절차 순서** 관련 문제 출제 다수

#### 🧠 용어 설명
- **DFD (Data Flow Diagram)**: 처리 기능 간 데이터 흐름을 도식화한 도구
- **자료 사전(Data Dictionary)**: DFD에 사용된 데이터 항목을 정의한 명세서
- **프로세스 명세서 (Process Spec)**: 각 기능(프로세스)의 처리 내용을 기술
- **기능 분해 (Functional Decomposition)**: 상위 기능을 점진적으로 세분화하는 설계 기법
- **처리 중심(=기능 흐름 중심)**: 시스템이 수행할 처리 과정을 분석하고 흐름에 따라 구조화하는 방식  

---

### 042. 컴포넌트 기반 방법론 (Component-Based Methodology)

#### 📘 정의
컴포넌트 기반 방법론은 소프트웨어를 **재사용 가능한 컴포넌트 단위로 분리하고**,  
이들을 **조립하여 전체 시스템을 완성**하는 개발 방법론이다.  
**재사용성, 확장성, 유지보수성** 향상이 핵심 목표다.

#### 🧩 개발 단계

1. **개발 준비**
2. **분석**
3. **설계**
4. **구현**
5. **테스트**
6. **전개**
7. **인도**

#### 🧩 특징 요약

- **컴포넌트(Component)**: 특정 기능을 수행하는 **독립적인 소프트웨어 모듈**
- 컴포넌트는 **인터페이스를 통해 통신**, 내부 구현은 은닉
- **결합도 낮고, 응집도 높음** → 변경 영향 최소화
- **재사용 중심 개발** → 생산성, 품질 향상
- **표준화, 자동화, 유지보수 용이성** 확보

#### 📝 기출 포맷 예시

- 컴포넌트 기반 방법론의 **주요 특징으로 옳은 것은?**
- 다음 중 컴포넌트 기반 방법론의 **장점으로 보기 어려운 것**은?
- 컴포넌트 기반 방법론에서 **인터페이스의 역할로 가장 적절한 것은?**
- 컴포넌트 간 결합도와 응집도에 대한 설명으로 **틀린 것**은?
- 컴포넌트 기반 방법론의 **개발 단계 순서**로 옳은 것은?

#### 🧠 용어 설명
- **컴포넌트(Component)**: 독립적으로 개발·배포·재사용 가능한 기능 단위 모듈
- **인터페이스(Interface)**: 컴포넌트 간 연결 및 메시지 전달 수단
- **결합도(Coupling)**: 컴포넌트 간의 의존도 (낮을수록 유리)
- **응집도(Cohesion)**: 하나의 컴포넌트가 하나의 기능에 집중하는 정도 (높을수록 유리)
- **재사용(Reuse)**: 기존 컴포넌트를 동일하거나 유사한 시스템에 반복 사용  

---

### 043. 소프트웨어 재사용 (Software Reuse)

#### 📘 정의
소프트웨어 재사용은 **이미 개발되어 검증된 소프트웨어 자산(코드, 설계, 문서 등)을 새로운 시스템에 재활용하는 개발 기법**이다.  
개발 생산성 향상, 품질 향상, 개발 기간 단축 등을 목적으로 한다.

#### 🧩 핵심 개념 요약

- **재사용 가능한 자산**: 소스코드, 모듈, 설계서, 테스트 케이스, 문서 등
- **재사용 목적**: 생산성 향상, 비용 절감, 품질 안정화
- **적용 범위**: 단위 모듈 ~ 전체 아키텍처 수준까지
- **반복 사용 가능성(Generality)**과 **이식성(Portability)**이 중요 요건

#### 🧩 재사용 분류

| 분류 기준 | 유형 | 설명 |
|-----------|------|------|
| **재사용 시점** | 사전적 재사용 | 처음부터 재사용을 염두에 두고 개발 |
|  | 사후적 재사용 | 기존 시스템에서 재사용 가능한 요소를 추출 |
| **재사용 대상** | 코드 재사용 | 함수, 모듈, 라이브러리 등 실행 단위 중심 |
|  | 설계 재사용 | 클래스 설계, 패턴 등 구조 중심 재사용 |
|  | 문서 재사용 | 명세서, 테스트 케이스 등 비코드 산출물 활용 |

#### 🧩 재사용 조건 및 고려사항

- **응집도는 높고, 결합도는 낮아야 함**
- 범용성, 모듈화, 문서화, 테스트 완료 상태
- 유지보수 용이성 확보
- 표준화된 명세 제공 필요

#### 📝 기출 포맷 예시
- 소프트웨어 재사용의 **장점으로 옳지 않은 것은?**
- **사전적 재사용**과 **사후적 재사용**의 차이는?
- 재사용 가능한 컴포넌트의 **요건으로 적절한 것은?**

#### 🧠 용어 설명
- **Software Reuse**: 검증된 소프트웨어 자산을 반복 활용하는 개발 기법
- **사전적 재사용**: 재사용 목적을 가지고 사전에 개발
- **사후적 재사용**: 기존 시스템에서 추출
- **재사용 자산**: 코드, 설계, 문서 등 다양한 형태의 개발 산출물 

---

### 044. CASE (Computer-Aided Software Engineering)

#### 📘 정의
CASE는 **소프트웨어 개발 전 과정(분석, 설계, 구현, 테스트 등)을 컴퓨터 기반 도구로 지원하는 시스템**을 의미한다.  
즉, 소프트웨어 개발의 **자동화와 표준화**를 통해 **생산성과 품질 향상**을 목표로 한다.

#### 🧩 핵심 개념 요약

- CASE 도구는 **소프트웨어 생명주기의 여러 단계**를 지원
- **반복적 작업 자동화**, **설계 문서 일관성 유지**, **개발 생산성 향상**
- 주요 적용 범위: 분석, 설계, 구현, 테스트, 유지보수 등
- 요구사항 추적, 코드 생성, 다이어그램 관리 등 다양한 기능 포함
- 그래픽, 소프트웨어 개발 모형 지원

#### 🧩 CASE의 분류

| 분류 기준 | 유형 | 설명 |
|-----------|------|------|
| **기능 기준** | 전방 CASE | 요구사항 분석 ~ 설계 단계 지원 |
|               | 후방 CASE | 구현 ~ 테스트, 유지보수 단계 지원 |
|               | 통합 CASE | 전방 + 후방 CASE 기능 통합 |
| **기능 수준** | 도구 (Tool) | 특정 작업만 지원 (예: 설계 도구) |
|               | 워크벤치 (Workbench) | 특정 개발 단계 전체 지원 (예: 분석 워크벤치) |
|               | 환경 (Environment) | 전체 생명주기 지원 (예: 통합 CASE 환경) |

#### 🧩 CASE의 기대 효과

- **개발 생산성 향상**
- **개발 표준화 및 문서 일관성 유지**
- **소프트웨어 품질 향상**
- **프로젝트 관리 효율 증대**

#### 📝 기출 포맷 예시

- CASE의 주요 **목적 또는 장점**으로 옳지 않은 것은?
- 다음 중 CASE 도구의 **분류 기준에 해당하지 않는 것**은?
- CASE의 **도구 / 워크벤치 / 환경** 구분에 대한 설명 중 옳은 것은?
- 전방 CASE와 후방 CASE의 **적용 단계 비교** 문제

#### 🧠 용어 설명

- **CASE**: 컴퓨터를 이용해 소프트웨어 개발을 자동화·지원하는 도구 집합
- **전방 CASE**: 분석·설계 중심 지원 도구
- **후방 CASE**: 구현·테스트 중심 지원 도구
- **통합 CASE**: 전 과정 지원 도구
- **워크벤치(Workbench)**: 특정 단계의 작업 전체를 지원하는 CASE 도구  

---

### 045. LOC 기법 (Lines of Code)

#### 📘 정의
LOC 기법은 소프트웨어 규모를 **개발할 소스코드의 라인 수**로 측정하여  
**개발 비용, 인력, 일정 등을 산정**하는 정량적 비용 산정 기법이다.  
간단하고 직관적이지만, **개발 언어와 개발자 스타일에 따라 오차가 발생**할 수 있다.

#### 🧩 핵심 개념 요약

- **코드 라인 수(LOC: Line Of Code)**를 기준으로 소프트웨어 규모 추정
- 규모가 크면 인력·비용도 비례하여 증가한다고 가정
- 산정 대상: **명령문 라인 수 (주석, 공백 제외)**
- 계산이 간편해 **중소 규모 프로젝트나 초기 견적에 자주 사용됨**

#### 🧩 LOC 기반 비용 산정 예시

- 예: 1,000 LOC × 인당 월 생산성(LOC/월) × 인건비(원/월) = 총 개발 비용
- 생산성, 비용 단가는 조직별 기준값 활용

#### 🧩 LOC 기법의 장단점

| 구분 | 내용 |
|------|------|
| ✅ 장점 | 계산이 간단하고 이해하기 쉬움 |
| ❌ 단점 | 언어, 코딩 스타일, 개발자 능력에 따라 편차 큼<br>구조·설계 복잡도는 반영 어려움 |

#### 📝 기출 포맷 예시

- LOC 기법의 **단점**으로 옳지 않은 것은?
- LOC 기법의 **산정 대상**에 포함되지 않는 것은?
- LOC 기법을 사용할 때 **주의해야 할 사항**은?

#### 🧠 용어 설명

- **LOC (Line of Code)**: 주석, 공백을 제외한 순수 명령문 라인 수
- **산정 기준**: 개발할 기능의 코드 수량
- **생산성**: 개발자가 일정 기간 동안 작성 가능한 LOC 수
- **정량적 산정 기법**: 수치 기반으로 규모/비용을 계산하는 방식  

---

### 046. 수학적 산정 기법 (Mathematical Estimation Techniques)

#### 📘 정의
수학적 산정 기법은 **수학적인 모델과 공식**을 사용하여  
소프트웨어 개발에 필요한 **노력(Man-Month), 비용, 일정 등을 정량적으로 산정**하는 방식이다.  
**정확한 산정 근거 확보**와 **객관적 비용 예측**이 가능한 것이 특징이다.

#### 🧩 대표 기법

1. **LOC 기법**
    - 코드 라인 수(LOC)를 기준으로 규모 산정
    - 간단하지만 언어·개발자별 편차 큼 (→ 045번 참고)

2. **기능 점수(Function Point, FP) 기법**
    - 소프트웨어의 기능 수와 복잡도를 기준으로 산정
    - 사용자 입장에서 시스템이 제공하는 기능 수 기반

3. **COCOMO (Constructive Cost Model)**
    - LOC 기반 경험 공식으로 비용/노력/일정 추정
    - 개발 유형별 상수 적용 (기초형, 중간형, 내장형)

4. **Putnam 모델 (SLIM)**
    - Rayleigh-Norden 곡선 기반, 프로젝트 기간·노력 예측
    - 인력 배분과 생산성 지수(P) 활용

5. **델파이 기법 (Delphi)**
    - 전문가 집단의 **반복적 의견 수렴**으로 추정
    - 정량보다 정성적 추정, 평균·중앙값 등 활용

#### 🧩 특징 요약

- **정량적 산정 기법**에 해당
- 조직 내 과거 데이터와 통계 기반
- **LOC, FP, COCOMO, Putnam, 델파이 등** 다양한 방법 존재
- 프로젝트 특성에 따라 기법 선택 필요

#### 📝 기출 포맷 예시

- 다음 중 **정량적 산정 기법**에 해당하지 않는 것은?
- 수학적 산정 기법에 해당하는 것으로 옳은 것은?
- COCOMO와 FP 기법의 **차이점**에 대한 설명으로 옳은 것은?

#### 🧠 용어 설명

- **정량적 산정 기법**: 수치 기반 모델로 비용·노력 등을 계산하는 방법
- **LOC**: 명령문 라인 수
- **FP**: 사용자 관점 기능 수 기반 산정
- **COCOMO**: LOC 기반 수학적 모델
- **Putnam 모델**: 시간-노력 곡선 활용 예측
- **델파이 기법**: 전문가 집단의 직관 기반 추정 방식  

---

### 047. COCOMO 모델 (Constructive Cost Model)

#### 📘 정의
COCOMO(코코모)는 **보잉사의 배리 보엄(Barry Boehm)** 이 제안한  
**소프트웨어 비용 산정 모델**로,  
**개발할 코드 양(LOC)**을 기준으로 **노력(Person-Month), 비용, 개발 기간**을 추정한다.

#### 🧩 산정 수식

**기본 노력 산정 공식**
```
Effort (PM) = a × (KLOC)^b
```
- PM: 인월(Person-Month)
- KLOC: 천 줄(1000 LOC)
- a, b: 유형별 계수

> 예: 기초형 → a = 2.4, b = 1.05

#### 🧩 COCOMO 모델의 특징

- **LOC 기반 정량적 비용 산정 기법**
- 개발 유형별로 계수가 달라짐
- **COCOMO II**는 객체지향, 재사용, 유지보수 등 반영한 확장 모델 (비출제)

#### 📝 기출 포맷 예시

- COCOMO 모델에서 **노력 산정 공식의 구성 요소**로 옳지 않은 것은?
- COCOMO의 **기초형/중간형/내장형** 구분 기준은?
- 다음 중 COCOMO 모델의 **특징**으로 적절한 것은?

#### 🧠 용어 설명

- **COCOMO**: LOC 기반 비용 산정 수학 모델
- **KLOC**: 1000줄 단위 코드 양
- **Effort**: 개발에 투입되는 총 인월(Person-Month)
- **기초형 / 중간형 / 내장형**: 개발 규모·복잡도·팀 역량에 따라 구분된 모델 유형  

---

### 048. 소프트웨어 개발 유형 (COCOMO 개발 유형)

#### 📘 정의
COCOMO 모델에서는 프로젝트의 규모, 복잡도, 제약 사항, 팀 역량 등을 기준으로  
소프트웨어 개발을 **조직형, 반분리형, 내장형** 3가지 유형으로 구분한다.  
각 유형은 **비용 산정 공식의 계수(a, b)에 영향을 미치며**, 적용 모델도 달라진다.

#### 🧩 개발 유형 비교

| 구분 | 조직형 (Organic) | 반분리형 (Semi-Detached) | 내장형 (Embedded) |
|------|------------------|---------------------------|-------------------|
| 적용 대상 | 소규모, 단순한 개발 | 중간 규모, 보통 복잡도 | 대규모, 복잡하고 제약 多 |
| 팀 특성 | 경험 많은 소수 팀 | 기능별로 나뉜 일반 팀 | 다수 팀, 고난이도 시스템 |
| 예시 | 급여 계산, 회계 처리 | 정보 관리 시스템 | 항공 제어, 실시간 제어 |
| 모델 복잡도 | 낮음 | 중간 | 높음 |
| 계수 (a, b) | 작음 | 중간 | 큼 |
| 예측 정확도 | 낮음 | 보통 | 높음 (계산 복잡) |

#### 📝 기출 포맷 예시

- 다음 중 **조직형** 개발 유형의 특징으로 적절한 것은?
- **반분리형** 유형에 대한 설명으로 옳은 것은?
- **내장형** 개발 유형이 적용될 수 있는 사례로 적절한 것은?

#### 🧠 용어 설명

- **조직형 (Organic)**: 단순한 업무, 유경험 팀, 소규모 프로젝트
- **반분리형 (Semi-Detached)**: 중간 복잡도, 기능별 팀 구성
- **내장형 (Embedded)**: 고복잡도, 제약조건 多, 실시간 시스템
- **계수 (a, b)**: COCOMO 수식 내 LOC 기반 계수 (유형별로 다름)

---

### 049. Putnam 모델 (Putnam Model, SLIM)

#### 📘 정의
Putnam 모델은 **Rayleigh-Norden 곡선**을 기반으로  
소프트웨어 개발의 **노력 분포와 개발 기간**을 예측하는 **정량적 산정 기법**이다.  
**개발 속도 지수(P)**를 활용하여 **투입 인력, 일정, 비용 간 균형을 수학적으로 산정**한다.

#### 🧩 핵심 공식
```
E = (Size)^3 / (P × T^4)
```
- **E**: 노력 (Effort, 인월)
- **Size**: 개발 규모 (LOC 기준)
- **P**: 생산성 지수 (Productivity)
- **T**: 개발 기간 (Time)

> 일정(T)이 늘어나면 노력(E)은 줄어드는 곡선 형태를 가짐 (Rayleigh 곡선)

#### 🧩 특징 요약

- **생산성 지수(P)** 활용 → 조직별 과거 개발 사례 기반
- **Rayleigh-Norden 곡선** 기반으로 **인력 투입 곡선** 모델링
- 프로젝트 시작 시점에는 인력 투입이 적고, 중후반에 최대 투입
- 일정이 길어지면 투입 노력은 줄어듦
- **COCOMO보다 일정 중심의 예측**에 강점

#### 📝 기출 포맷 예시

- 다음 중 **Putnam 모델의 특징**으로 옳지 않은 것은?
- **생산성 지수(P)**는 무엇을 의미하는가?
- Putnam 모델에서 일정과 노력의 관계는?

#### 🧠 용어 설명

- **Rayleigh-Norden 곡선**: 시간에 따른 노력 투입의 이상적인 분포 곡선
- **생산성 지수(P)**: 조직의 개발 환경, 도구, 경험 등을 반영한 고유 지표
- **Effort (E)**: 투입된 전체 노력 (인월)
- **Time (T)**: 개발에 소요되는 총 기간  

---

### 050. 기능 점수 모형 (Function Point, FP)

#### 📘 정의
기능 점수(Function Point, FP) 모형은 소프트웨어의 **기능적 요구사항**을 기반으로  
**사용자 관점에서 시스템의 크기(규모)를 정량화**하는 비용 산정 기법이다.  
LOC처럼 개발자 중심이 아닌, **외부에 드러나는 기능의 수와 복잡도**를 기준으로 측정한다.

#### 🧩 측정 대상 5가지 구성 요소

| 구성 요소 | 설명 |
|-----------|------|
| **입력(I)** | 사용자가 시스템에 제공하는 외부 입력 (예: 로그인 정보) |
| **출력(O)** | 시스템이 사용자에게 제공하는 외부 출력 (예: 보고서, 알림) |
| **조회(IQ)** | 단순 참조 및 검색 (예: 고객 정보 조회) |
| **내부 논리 파일(ILF)** | 시스템 내부에서 관리되는 논리적 데이터 집합 |
| **외부 인터페이스 파일(EIF)** | 다른 시스템과 연동되는 데이터 (외부 시스템에서 관리됨) |

#### 🧩 기능 점수 산정 절차

1. **기능 수 식별**
    - 위 5가지 항목별로 단순 / 보통 / 복잡으로 나누어 점수 부여
2. **기초 FP 계산 (Unadjusted FP)**
    - 항목별 가중치를 적용해 총점 계산
3. **보정 계수 계산 (VAF)**
    - 시스템의 특성을 고려한 14개 보정 항목 → 보정 계수 산출
4. **최종 FP 계산**
   ```
   FP = 기초 FP × (0.65 + 0.01 × 총 보정 계수)
   ```

#### 🧩 FP 기법의 특징

- **사용자 요구 중심**의 정량적 산정 기법
- 언어·환경과 무관한 측정 가능
- **초기 견적이나 기능 위주의 시스템 분석에 적합**
- 재사용성과 유지보수성도 고려 가능

#### 📝 기출 포맷 예시

- 기능 점수 기법(FP)에서 **산정 대상 요소**에 해당하지 않는 것은?
- 기능 점수 모형의 **장점 또는 특징**으로 옳은 것은?
- 다음 중 **FP 산정 절차의 올바른 순서**는?

#### 🧠 용어 설명

- **FP (Function Point)**: 사용자 기능 기반으로 소프트웨어 규모를 정량화한 단위
- **입력/출력/조회/ILF/EIF**: 기능 점수 산정의 다섯 가지 기본 항목
- **VAF (Value Adjustment Factor)**: 시스템 특성을 반영하는 보정 계수
- **Unadjusted FP**: 기능 수 기반의 기본 점수  

---

### 051. 비용 산정 자동화 추정 도구

#### 📘 정의
비용 산정 자동화 추정 도구는 **소프트웨어 개발 비용, 일정, 인력 등 자원 소요를 정량적으로 예측**하기 위해  
**자동으로 계산을 수행하는 소프트웨어 도구**이다.  
경험적 데이터와 알고리즘 모델을 기반으로 산정 정확도를 높인다.

#### 🧩 대표 도구

| 도구 | 설명 |
|------|------|
| **COCOMO II** | Boehm이 개발한 LOC 기반 산정 도구. 최신 버전은 객체지향·반복적 개발 지원 |
| **SLIM (Putnam 모델 기반)** | Rayleigh 곡선 기반, 조직의 생산성 지수(P)를 활용한 일정 중심 산정 도구 |
| **CheckPoint** | 프로젝트 위험 분석, 일정·비용 추정 등 다양한 기능 제공 |
| **ESTIMACS** | FP 기반 비용 산정. 유지보수까지 고려 가능 |
| **SEER-SEM** | 다양한 입력 변수와 AI 기술을 적용한 정교한 산정 가능 도구 |

#### 🧩 특징 요약

- **정확도 향상**: 경험적 데이터 기반으로 수작업보다 정확한 추정 가능
- **다양한 모델 지원**: LOC, FP, COCOMO, SLIM 등
- **위험 요소 분석 및 리스크 평가 기능 포함**
- **시각화 및 보고서 자동 생성 기능 지원** 도구도 있음

#### 📝 기출 포맷 예시

- 다음 중 **자동화된 소프트웨어 비용 산정 도구**가 아닌 것은?
- COCOMO, SLIM, SEER-SEM은 어떤 도구인가?
- 비용 산정 자동화 도구의 **공통된 특징**은?

#### 🧠 용어 설명

- **COCOMO II**: LOC 기반, 다양한 개발 유형 반영
- **SLIM**: Putnam 모델 기반의 일정 중심 산정
- **FP 기반 도구**: 기능 단위 기준 산정 (예: ESTIMACS)
- **CheckPoint / SEER-SEM**: 통합형 추정 도구

---

### 052. PERT (Program Evaluation and Review Technique)

#### 📘 정의
PERT는 **프로젝트 작업의 일정과 소요 시간의 불확실성**을 고려하여  
**계획과 통제를 지원하는 네트워크 기반 일정 관리 기법**이다.  
특히 **낙관/비관/기대 시간**을 반영해 일정 예측의 신뢰도를 높인다.

#### 🧩 3점 추정 기법

| 추정 종류 | 기호 | 설명 |
|-----------|------|------|
| **낙관적 시간** | `O` | 가장 빠르게 완료될 수 있는 시간 |
| **비관적 시간** | `P` | 가장 오래 걸릴 것으로 예상되는 시간 |
| **기대 시간** | `M` | 가장 가능성이 높은 일반적인 시간 |

#### 🧩 기대 시간 계산 공식
```
TE = (O + 4M + P) / 6
```
- TE: 기대 시간 (Expected Time)
- 3점 추정을 기반으로 평균적 작업 소요 시간 산정

#### 🧩 특징 요약

- **불확실성 있는 일정 예측에 적합**
- **CPM과 달리 확률 기반**
- **작업 간 의존 관계 표현** 가능 (네트워크 다이어그램 활용)

#### 📝 기출 포맷 예시

- PERT에서 기대 시간을 계산하는 공식은?
- 다음 중 PERT 기법의 특징으로 옳지 않은 것은?
- PERT 기법에서 사용하는 시간 추정 방식은?

#### 🧠 용어 설명

- **PERT**: 낙관·비관·기대 시간 기반 일정 관리 기법
- **3점 추정**: O, M, P 값을 기반으로 한 평균 시간 계산
- **TE (Expected Time)**: 예상 일정 소요 시간

---

### 053. CPM (Critical Path Method)

#### 📘 정의
CPM은 **프로젝트 일정 계획을 위해 작업 간 선후 관계를 네트워크 다이어그램으로 표현**하고,  
전체 일정 중 **가장 오래 걸리는 경로(=주 경로, Critical Path)** 를 식별하는 일정 관리 기법이다.  
→ 주 경로상의 작업은 **지연 시 전체 프로젝트 일정에 직접 영향**을 준다.

#### 🧩 주요 개념

| 용어 | 설명 |
|------|------|
| **주 경로(Critical Path)** | 전체 일정 중 가장 긴 경로. 여유 시간 0 |
| **총 여유 시간(Total Float)** | 작업이 늦어져도 전체 일정에 영향 없는 시간 |
| **조기 착수/완료(ES/EF)** | 가장 빠르게 시작/완료 가능한 시점 |
| **최종 착수/완료(LS/LF)** | 일정 지연 없이 시작/완료해야 하는 시점 |

#### 🧩 표시 방법
- **네트워크 다이어그램(Network Diagram)** 으로 표현
- **작업(Task)** 을 노드로 나타내고,  
  **작업 간 순서를 화살표**로 연결

#### 🧩 특징 요약

- **확정적 시간 기반 일정 예측** (PERT는 확률적 시간)
- **주 경로 파악을 통한 일정 최적화** 가능
- **작업 간 의존성, 여유 시간 등을 시각적으로 분석**

#### 📝 기출 포맷 예시

- CPM 기법에서 주 경로의 의미는?
- 총 여유 시간이 0인 경로는 무엇인가?
- CPM은 어떤 일정 추정 방식을 사용하는가?

#### 🧠 용어 설명

- **CPM**: 주 경로 분석을 통한 일정 계산 기법
- **Network Diagram**: 작업 흐름을 시각화한 도식
- **Float**: 일정 지연이 허용되는 시간 범위

---

### 054. 간트 차트 (Gantt Chart)

#### 📘 정의
간트 차트는 **작업 일정을 막대 그래프로 표현한 프로젝트 관리 도구**로,  
각 작업의 **시작일, 종료일, 지속 시간**을 **시간 축 기준의 막대 형태**로 나타낸다.

#### 🧩 구성 요소

| 구성 요소 | 설명 |
|-----------|------|
| **작업(Task)** | 수행해야 할 개별 활동 또는 단계 |
| **시간 축(Time Axis)** | 작업이 시작되고 끝나는 일정 기준선 (보통 수평축) |
| **막대(Bar)** | 작업의 기간을 나타냄 (왼쪽: 시작일, 오른쪽: 종료일) |
| **진척도(Progress)** | 막대 내부 색상 등으로 진행 상태 표시 가능 |

#### 🧩 특징 요약

- **시각적으로 직관적**인 일정 표현
- 작업 간 **동시 수행 여부나 전체 흐름 파악 가능**
- **프로젝트 계획 및 진행 상황 모니터링에 효과적**
- **작업 간 선후 관계 표현은 제한적** (CPM/PERT와 비교 시)

#### 📝 기출 포맷 예시

- 간트 차트의 **주요 특징**으로 옳은 것은?
- 간트 차트에서 작업 일정은 어떻게 표현되는가?

#### 🧠 용어 설명

- **간트 차트(Gantt Chart)**: 시간 축 기반의 막대형 일정표
- **작업(Task)**: 일정 단위의 업무
- **진척도**: 작업의 진행률 시각 표현

---

### 055. ISO/IEC 12207

#### 📘 정의
ISO/IEC 12207은 **소프트웨어 생명주기 전반에 걸친 표준 절차와 활동을 정의한 국제 표준**이다.  
소프트웨어의 **개발, 운영, 유지보수 등 모든 과정**에 대해 체계적이고 반복 가능한 절차를 제시한다.

#### 🧩 구성 프로세스

| 프로세스 유형           | 하위 프로세스 예시 |
|-------------------|-------------------|
| **기본 생명 주기 프로세스** | 개발, 운영, 유지보수 |
| **지원 생명 주기 프로세스** | 문서화, 검증, 검토, 품질보증, 형상관리 등 |
| **조직 생명 주기 프로세스** | 관리, 인프라, 개선, 교육, 재사용 등 |

#### 🧩 특징 요약

- 소프트웨어 생명주기(SDLC) 전체를 아우르는 **국제 표준 프로세스 모델**
- **프로세스 기반 품질 관리 체계 수립 가능**
- ISO 9001, CMMI 등 품질 관련 표준과 연계 가능

#### 📝 기출 포맷 예시

- ISO/IEC 12207에 포함된 **프로세스 유형**으로 옳은 것은?
- 다음 중 **ISO/IEC 12207의 목적**으로 적절한 것은?
- ISO/IEC 12207의 **지원 프로세스**에 해당하지 않는 것은?

#### 🧠 용어 설명

- **ISO/IEC 12207**: 소프트웨어 생명주기 표준
- **기본/지원/조직 프로세스**: 소프트웨어 활동을 분류한 구조
- **형상관리**: 변경사항을 추적·통제하는 관리 기법

---

### 056. CMMI (Capability Maturity Model Integration)

#### 📘 정의
CMMI는 **조직의 소프트웨어 개발 및 관리 프로세스 성숙도를 평가하고 개선**하기 위한 국제 표준 모델이다.  
CMM(Capability Maturity Model)의 확장 통합 모델로, **프로세스 성숙도 향상**을 통해 **품질, 효율, 생산성**을 높이는 것이 목적이다.

#### 🧩 성숙도 수준 (Maturity Level)

| 수준 | 설명 |
|------|------|
| **1단계 - 초기(Level 1: Initial)** | 비정형적, 비공식적, 계획 없이 수행됨 |
| **2단계 - 관리(Level 2: Managed)** | 프로젝트 단위로 기본적인 관리 수행 |
| **3단계 - 정의(Level 3: Defined)** | 조직 차원의 표준 프로세스 정의 및 활용 |
| **4단계 - 정량적 관리(Level 4: Quantitatively Managed)** | 프로세스 성능을 정량적으로 측정 및 통제 |
| **5단계 - 최적화(Level 5: Optimizing)** | 지속적인 개선과 혁신 추구 |

#### 🧩 특징 요약

- **프로세스 중심의 조직 개선 프레임워크**
- 각 단계마다 **목표 달성 여부에 따라 등급 부여**
- **정량적 평가와 지속적 개선**을 중시
- **소프트웨어 외에 시스템 엔지니어링, 서비스 관리** 등 다양한 분야에 적용 가능

#### 📝 기출 포맷 예시

- CMMI의 **성숙도 수준(Level)** 중 정의된 것은?
- CMMI에서 **정량적 관리**에 해당하는 단계는 몇 단계인가?
- CMMI의 **주요 목적 또는 특징**으로 적절한 것은?

#### 🧠 용어 설명

- **CMMI**: 조직의 프로세스 개선을 위한 통합 모델
- **성숙도(Maturity)**: 프로세스가 얼마나 체계적이고 안정화되어 있는지의 수준
- **정의/정량/최적화**: 고성숙도 단계에서 나타나는 조직적 특성

---

### 057. SPICE (Software Process Improvement and Capability dEtermination)

#### 📘 정의
SPICE는 **소프트웨어 프로세스의 성숙도와 수행 능력을 평가하고 개선하기 위한 국제 표준 모델**이다.  
정식 명칭은 **ISO/IEC 15504**이며,  
**CMMI와 유사한 프로세스 기반 평가 체계**를 제공하여 조직의 품질 향상을 지원한다.

#### 🧩 목적 및 특징

- **소프트웨어 생명주기 전반에 걸친 표준화된 프로세스 제공**
- **프로세스 기반의 정량적 평가 가능**
- **조직 맞춤 적용(Tailoring)이 가능한 유연한 구조**
- **국내외 공공 소프트웨어 사업 입찰 요건**에 반영되기도 함

#### 🧩 구성 체계

| 항목 | 설명 |
|------|------|
| **프로세스 평가 모델 (PAM)** | 프로세스의 성과 기준과 평가 요소 정의 |
| **프로세스 참조 모델 (PRM)** | 수행해야 할 프로세스 활동을 정의 |
| **측정 프레임워크** | 수행 능력을 0~5단계로 계량화 (※ 58번에서 상세히 정리) |

#### 📝 기출 포맷 예시

- SPICE의 **공식 국제 표준 번호**는?
- SPICE에서 정의한 **참조 모델과 평가 모델의 역할**은?

#### 🧠 용어 설명

- **SPICE**: 소프트웨어 프로세스 평가 및 개선 모델
- **ISO/IEC 15504**: SPICE의 국제 표준 명칭
- **Tailoring**: 프로젝트 특성에 맞춘 프로세스 조정
- **PAM / PRM**: 프로세스 평가·참조 모델

---

### 058. SPICE의 수행 능력 단계

#### 📘 정의
SPICE(ISO/IEC 15504)에서는 **각 소프트웨어 프로세스의 수행 능력(Capability)을 6단계 수준**으로 정의하여,  
프로세스의 **성숙도 및 체계성**을 정량적으로 평가한다.

#### 🧩 수행 능력 수준 (Capability Levels)

| 수준 | 명칭 | 설명 |
|------|------|------|
| **0** | 불완전 수행 (Incomplete) | 프로세스가 거의 수행되지 않거나 목적을 달성하지 못함 |
| **1** | 수행됨 (Performed) | 프로세스가 최소한의 산출물을 생성하며 수행됨 |
| **2** | 관리됨 (Managed) | 계획되고 모니터링되며 문서화된 방식으로 관리됨 |
| **3** | 확립됨 (Established) | 조직 표준 프로세스를 기반으로 수행됨 |
| **4** | 예측됨 (Predictable) | 정량적으로 측정·통제되며 안정적으로 수행됨 |
| **5** | 최적화됨 (Optimizing) | 지속적 개선과 혁신을 위한 피드백 중심 수행 |

#### 🧩 특징 요약

- 각 단계는 **이전 단계를 완전히 포함하면서 상위 수준으로 발전**
- 평가 시, **각 프로세스마다 개별 수행 수준**을 부여할 수 있음
- CMMI와 유사하지만, **SPICE는 개별 프로세스 기준 평가**가 가능

#### 📝 기출 포맷 예시

- SPICE에서 **수행 능력 수준 3단계**는 어떤 단계인가?
- SPICE의 **수준 0과 수준 5의 차이점**은 무엇인가?

#### 🧠 용어 설명

- **수행 능력(Capability Level)**: 프로세스 성숙도 평가 척도
- **정량적 관리**: 데이터를 기반으로 측정·통제하는 수행 방식
- **지속적 개선**: 피드백과 혁신 활동 중심의 최적화 수행

---

### 059. 소프트웨어 개발 방법론 테일러링

#### 📘 정의
소프트웨어 개발 방법론 테일러링(Tailoring)은  
**조직이나 프로젝트의 특성에 맞게 개발 방법론의 구성 요소(활동, 절차, 산출물 등)를 선택·수정·재구성하는 과정**이다.  
→ 획일적인 적용 대신, **효율성과 실용성을 높이기 위한 맞춤형 적용** 방식이다.

#### 🧩 테일러링 필요성

- 프로젝트의 **범위, 규모, 복잡도, 리소스**가 상이함
- 불필요한 절차나 산출물을 제거하여 **효율성 향상**
- 조직 내 개발 문화, 기술 역량, 도구 등에 따라 유연한 적용 가능

#### 🧩 테일러링 기준

테일러링은 **내부적 기준과 외부적 기준**을 함께 고려하여 수행된다.

| 구분 | 항목 | 설명 |
|------|------|------|
| **내부적 기준** | **목표 환경** | 운영 환경, 플랫폼, 인프라 등 |
|  | **요구사항** | 기능·비기능 요구사항의 복잡도 및 우선순위 |
|  | **프로젝트 규모** | 인력, 예산, 일정 등 프로젝트의 범위와 크기 |
|  | **보유 기술 및 자원** | 조직이 보유한 개발 인력, 도구, 기술 수준 등 |
| **외부적 기준** | **법적 제약사항** | 산업별 규제, 보안 법규 등 외부 법률 요건 |
|  | **표준 및 품질 기준** | ISO, IEEE 등의 표준 준수 요구, 품질보증 체계 등 |

#### 🧩 주요 조정 항목

| 항목 | 설명 |
|------|------|
| **활동(Activity)** | 수행할 작업의 생략, 추가, 병합 등 |
| **산출물(Deliverable)** | 문서의 종류·형식 변경 또는 축소 |
| **역할(Role)** | 작업 담당자의 역할 조정 또는 통합 |
| **절차(Process)** | 방법론 내 절차의 순서나 방식 변경 |

#### 🧩 특징 요약

- **고정된 방법론을 유연하게 변형**
- **효율성 vs 표준성의 균형** 유지
- **프로젝트 성공률 제고**에 기여

#### 📝 기출 포맷 예시

- 소프트웨어 개발 방법론 테일러링의 **목적 또는 필요성**은?
- 테일러링 과정에서 **조정 대상이 아닌 것**은 무엇인가?
- 테일러링의 **내부적 기준과 외부적 기준**에 포함되는 항목은?

#### 🧠 용어 설명

- **Tailoring(테일러링)**: 개발 방법론을 맞춤화하는 활동
- **산출물 조정**: 산출물의 생략·간소화·대체 등
- **역할 조정**: 인력 구조에 따라 책임 분담 변경
- **법적 제약사항**: 외부 규제에 따라 필수 적용 요건

---

### 060. 소프트웨어 개발 프레임워크

#### 📘 정의
소프트웨어 개발 프레임워크는 **소프트웨어 생명주기 전반에 걸쳐 표준화된 절차, 도구, 산출물, 역할 등을 통합적으로 제공하는 개발 지원 체계**이다.  
→ 개발자의 작업 방식과 산출물을 통일하고, 품질과 생산성을 높이기 위한 목적의 **일관된 개발 환경**을 제공한다.

#### 🧩 목적

- **개발 표준의 일관성 유지**
- **생산성 및 품질 향상**
- **개발 절차의 체계화와 반복 가능성 확보**
- **산출물 자동 생성 등 도구 지원을 통한 효율화**

#### 🧩 주요 구성 요소

| 구성 요소 | 설명 |
|-----------|------|
| **개발 절차** | 요구사항 분석부터 유지보수까지 전 단계의 표준화된 절차 |
| **산출물 템플릿** | 단계별로 생성되는 문서 및 결과물의 형식과 기준 |
| **역할 및 책임** | 참여자별 수행 업무와 책임을 명확히 정의 |
| **지원 도구** | 형상 관리, 빌드, 테스트 등 자동화 도구와의 통합 |
| **개발 방법론** | 프레임워크에 내재된 프로세스 기반 개발 방식 |

#### 📝 기출 포맷 예시

- 소프트웨어 개발 프레임워크의 **구성 요소**에 해당하지 않는 것은?
- 개발 프레임워크의 **목적**으로 가장 적절한 것은?

#### 🧠 용어 설명

- **프레임워크(Framework)**: 재사용 가능하고 구조화된 개발 지원 체계
- **산출물 템플릿**: 문서 형식이나 작성 기준을 제공하는 틀
- **개발 도구 통합**: 테스트, 형상관리, 자동화 도구 등의 연결

---

### 061. 소프트웨어 개발 프레임워크의 특성

#### 📘 핵심 특성 (4가지)

1. **모듈화 (Modularity)**
    - 인터페이스 기반 캡슐화를 통해 모듈 단위로 분리 ⇒ 변경 영향 최소화, 유지보수 용이 :contentReference[oaicite:1]{index=1}

2. **재사용성 (Reusability)**
    - 템플릿·모듈·컴포넌트를 반복 활용 가능 ⇒ 생산성·품질 향상 :contentReference[oaicite:2]{index=2}

3. **확장성 (Extensibility)**
    - 다형성 기반 인터페이스 확장 가능 ⇒ 다양한 요구사항에 유연하게 대응 :contentReference[oaicite:3]{index=3}

4. **제어의 역흐름 (Inversion of Control, IoC)**
    - 프레임워크가 전체 흐름을 제어하고, 필요한 지점에서 사용자 코드 호출 ⇒ 개발자는 구현에 집중 :contentReference[oaicite:4]{index=4}

---

### 📝 기출 포맷 예시

- 프레임워크의 **특성**으로 옳지 않은 것은?
- **모듈화**와 **재사용성**이 나타내는 장점은 무엇인가?
- **제어의 역흐름**이 개발 효율에 미치는 영향은?

---

### 🧠 요약

- **정보처리기사 시험**에서는 이 네 가지 키워드만 정확히 기억하면 됨
- 불필요한 항목이나 과도한 설명 없이 **이 네 가지만 정리**하시면 충분합니다  
