## 202. 애플리케이션 테스트의 기본 원리

**테스트의 6대 기본 원리:**

- [ ] **1. 결함 존재의 원리**: 테스트는 **결함의 존재를 밝힐 수는 있지만** **결함이 없음을 증명할 수는 없다**
- [ ] **2. 완전 테스트 불가능의 원리**: 모든 입력값/경우를 다 테스트하는 것은 **비현실적**, 일부 샘플 기반으로 **품질 추정**
- [ ] **3. 결함 집중의 원리**: 대부분의 결함은 **일부 모듈, 기능, 구간에 집중**, **파레토 법칙(80:20)** 적용
- [ ] **4. 살충제 패러독스**: 같은 테스트 케이스 반복하면 **더 이상 새로운 결함 찾기 어려움**, **주기적 수정·보완 필요**
- [ ] **5. 테스트의 정황 의존성**: 테스트는 **소프트웨어의 성격, 목적, 도메인**에 따라 방식이 달라짐
- [ ] **6. 오류-부재의 궤변**: 모든 기능이 정확해도 **사용자 요구사항을 충족하지 못하면 테스트 실패**, **요구사항 기반 테스트** 중요

---

## 203. 애플리케이션 테스트의 구분

- [ ] **실행 여부**: **정적 테스트**(실행 없이 검토, 코드 리뷰) vs **동적 테스트**(실행하여 동작 검증)
- [ ] **개발 단계**: **개발자 테스트**(자체 수행) + **검증 테스트**(QA팀) + **인수 테스트**(사용자 최종 판단)
- [ ] **목적별**: **기능 테스트**(기능 수행) + **성능 테스트**(응답시간/처리량) + **보안 테스트**(취약점) + **회귀 테스트**(기존 기능 재확인)
- [ ] **레벨별**: **단위 테스트**(모듈/함수) → **통합 테스트**(모듈 간 연동) → **시스템 테스트**(전체 기능) → **인수 테스트**(최종 승인)
- [ ] **정적 테스트는 비용 저렴하고 초기 결함 검출**에 유리

---

## 204. 시각에 따른 테스트 – 확인 / 검증

- [ ] **확인 (Verification)**: **설계 명세서대로 올바르게 구현되었는지** 확인, **개발자 시각**, **화이트박스 테스트** 주로 활용
- [ ] **검증 (Validation)**: **사용자의 요구사항을 충족**하는지 테스트, **사용자 시각**, **블랙박스 테스트** 주로 활용
- [ ] **확인**: 구현이 명세대로 되었는지 (정적 분석, 코드 리뷰)
- [ ] **검증**: 결과물이 사용자 요구 충족하는지 (시스템 테스트, 인수 테스트)
- [ ] **화이트박스**는 확인, **블랙박스**는 검증과 연결

---

## 205. 목적에 따른 테스트

- [ ] **회복 테스트**: 시스템에 **장애나 오류를 인위적으로 발생**시켜 **정상 상태로 복구되는지** 확인
- [ ] **보안 테스트**: **인증, 권한, 접근 통제, 취약점 존재 여부** 등을 테스트하여 보호 능력 평가
- [ ] **강도 테스트**: 시스템에 **과도한 부하를 인위적으로 가해** 안정성, 처리 능력 검증
- [ ] **성능 테스트**: 일정 시간 내 **응답 속도, 처리량, 자원 사용률** 등 요구 성능 조건 만족 확인
- [ ] **구조 테스트**: 소프트웨어 **내부 구조**를 분석하여 **논리적 결함이나 코드 복잡도** 검증
- [ ] **회귀 테스트**: 프로그램 수정/기능 추가 등 변경 후 **기존 기능이 정상 동작하는지** 확인
- [ ] **병행 테스트**: 변경 전후 시스템에 **동일 입력을 주고 결과 일치 여부** 비교하여 신뢰성 검증

---

## 206. 화이트박스 테스트

- [ ] 소프트웨어의 **내부 구조(코드, 제어 흐름, 데이터 흐름)**를 직접 분석하고 **개발자 관점에서 논리, 로직, 경로** 검증
- [ ] **특징**: 구조 기반 테스트, **소스 코드와 설계 문서** 기반, **제어 흐름/조건/데이터 흐름** 초점
- [ ] **적용**: **단위 테스트/통합 테스트** 단계에서 주로 수행, **커버리지 기준**으로 완전도 판단
- [ ] **장점**: 초기 결함 발견, 보안 취약점 탐지, 코드 최적화 가능
- [ ] **단점**: 구현 의존적, 사용자 시나리오 검증 부족, 코드 변경 시 유지보수 비용 발생

---

## 207. 화이트박스 테스트의 종류

- [ ] **기초 경로 검사**: 프로그램의 **제어 흐름 그래프 내 독립 경로**를 모두 식별하고 테스트
- [ ] **제어 구조 테스트**: **조건문, 반복문, 분기** 등의 제어 흐름 요소에 대한 집중 테스트
- [ ] **데이터 흐름 테스트**: **변수 선언, 할당, 사용** 등의 흐름 간 생기는 오류 검증
- [ ] **조건 테스트**: **복합 조건 내 개별 조건 값**의 참/거짓 경우를 모두 테스트
- [ ] **루프 테스트**: 단일 루프, 중첩 루프, **경계 반복 횟수** 등에 따라 다양한 루프 경로 검증
- [ ] **경로 테스트**: **가능한 모든 실행 경로**를 따라 테스트 케이스 구성
- [ ] **예외 처리 테스트**: **예외 발생 조건과 예외 처리 흐름**이 올바른지 확인

---

## 208. 화이트박스 테스트의 검증 기준 (Coverage)

**커버리지 계층 구조 (포함 관계): 문장 ⊂ 분기 ⊂ 조건 ⊂ 조건-결정 ⊂ MC/DC ⊂ 다중 조건 ⊂ 경로**

- [ ] **문장 커버리지**: **모든 코드 라인**이 최소 1회 실행되었는지 확인
- [ ] **분기 커버리지**: **모든 조건문의 참/거짓 분기 경로**가 실행되었는지 확인
- [ ] **조건 커버리지**: **복합 조건 내 각 조건**이 참/거짓 모두 수행되었는지 확인
- [ ] **조건-결정 커버리지**: **조건 커버리지 + 분기 커버리지** 동시 만족
- [ ] **변경조건/결정 커버리지 (MC/DC)**: **각 조건이 결과에 독립적으로 영향** 주는지 확인
- [ ] **다중 조건 커버리지**: **모든 조건 조합**을 테스트 (가장 포괄적)
- [ ] **경로 커버리지**: **가능한 모든 제어 흐름 경로**를 테스트

---

## 209. 블랙박스 테스트

- [ ] 소프트웨어의 **내부 구조를 보지 않고** **입력과 출력의 기능적 관계**만 보고 시스템이 요구사항 충족하는지 검증
- [ ] **특징**: **외부 관점**(사용자/인터페이스), **실행 기반**, **비구조 중심**(내부 코드 참조 안함)
- [ ] **시점**: **통합 또는 시스템 테스트** 단계에서 주로 사용
- [ ] **별칭**: **기능 테스트**, **명세서 기반 실행 테스트**
- [ ] 사용자나 인터페이스 관점에서 **요구사항 준수 여부** 확인

---

## 210. 블랙박스 테스트의 종류

- [ ] **동등 분할**: 입력 영역을 **유효/무효 그룹으로 나눠** 대표값만 테스트
- [ ] **경계값 분석**: **최소/최대 경계 및 인근 값** 중심으로 테스트
- [ ] **결정 테이블**: **조건-행동 조합을 표로 정리**해 모든 조합 검증
- [ ] **상태 전이**: **상태와 이벤트 흐름**에 따라 상태 변화 검증
- [ ] **원인-효과 그래프**: **입력-출력 관계를 논리 그래프**로 시각화하여 테스트
- [ ] **비교 테스트**: 다른 버전/시스템과 **동일 입력→결과 비교** 검증
- [ ] **오류 예측**: **경험 기반 직관**으로 잠재 결함 예상 테스트

---

## 211. 개발 단계에 따른 애플리케이션 테스트 (V-모델)

**개발은 위에서 아래로, 테스트는 아래에서 위로 (V 형태 흐름):**

- [ ] **요구사항 분석** ↔ **인수 테스트**: 사용자의 요구사항이 모두 반영되었는지 확인
- [ ] **분석** ↔ **시스템 테스트**: 전체 시스템이 요구 명세대로 동작하는지 검증
- [ ] **설계** ↔ **통합 테스트**: 모듈 간 연결과 데이터 흐름의 정확성 확인
- [ ] **구현(코딩)** ↔ **단위 테스트**: 개별 모듈 내부 로직과 기능의 정확성 검증
- [ ] **V-모델**: 개발 단계와 테스트 단계가 **1:1로 대응**되는 구조

---

## 212. 단위 테스트 (Unit Test)

- [ ] **소프트웨어의 가장 작은 단위**(모듈, 함수, 클래스)를 **개발자가 직접 테스트**
- [ ] **목적**: 기능이 명세대로 동작하는지 확인, **내부 오류 조기 검출**
- [ ] **검증 대상**: 인터페이스, 자료 구조, 조건문, 경로 흐름, 예외 처리
- [ ] **테스트 방식**: **화이트박스 테스트**(내부 로직 기반), 경우에 따라 블랙박스도 병행
- [ ] **자동화 도구**: JUnit(Java), pytest(Python), CppUnit(C++)
- [ ] **테스트 커버리지 측정** 가능 (명령문, 분기 커버리지 등)

---

## 213. 통합 테스트 (Integration Test)

- [ ] 단위 테스트 완료된 모듈들을 결합하여 **모듈 간 인터페이스와 데이터 흐름** 검증
- [ ] **빅뱅 통합**: **모든 모듈을 한꺼번에** 결합 (빠르지만 결함 원인 추적 어려움)
- [ ] **하향식**: **상위 모듈부터** 시작, **스텁(Stub)**으로 하위 모듈 대체, 제어 흐름 테스트 유리
- [ ] **상향식**: **하위 모듈부터** 결합, **드라이버(Driver)**로 상위 모듈 대체, 데이터 흐름 테스트 유리
- [ ] **혼합식**: 상향식과 하향식을 **절충하여 동시** 적용
- [ ] **스텁**: 하위 모듈 임시 대체, **드라이버**: 상위 모듈 임시 대체

---

## 214. 시스템 테스트 (System Test)

- [ ] 통합된 **전체 시스템이 기능 및 비기능 요구사항**을 충족하는지 확인
- [ ] **대상**: 전체 시스템의 모든 기능 및 비기능 요소
- [ ] **목적**: 기능 테스트(요구사항 기능 수행) + **비기능 테스트**(성능, 보안, 안정성, 신뢰성)
- [ ] **테스트 방식**: **E2E 관점**, **블랙박스 방식**
- [ ] **실행 환경**: **운영 환경과 유사한** 테스트 환경에서 수행
- [ ] **수행 주체**: QA팀 또는 독립 테스터

---

## 215. 인수 테스트 (Acceptance Test)

- [ ] **최종 사용자 또는 고객이 실제 시스템을 운영 환경에서 평가**하는 단계
- [ ] **검증 주체**: 최종 사용자, 고객 또는 이해관계자
- [ ] **목적**: 요구사항 충족 여부 확인, **실제 운영 환경에서의 안정성/호환성/사용성** 평가
- [ ] **테스트 방식**: 요구사항 기반 명세용 **블랙박스 테스트**
- [ ] **완료 기준**: 사용자 또는 고객의 **체크리스트 기반 승인** 후 시스템 인수
- [ ] **UAT**(User Acceptance Test): 최종 사용자 주도의 인수 테스트

---

## 216. 하향식 통합 테스트 (Top-Down)

- [ ] **최상위 모듈부터 하위 모듈 방향**으로 단계적 통합하면서 테스트
- [ ] **스텁(Stub)** 사용: 미구현 하위 모듈을 **임시 모듈로 대체**
- [ ] **통합 방식**: **깊이 우선**(한 경로 끝까지) 또는 **너비 우선**(같은 레벨 먼저)
- [ ] **장점**: 초기에 전체 시스템 구조 파악, **상위 제어 로직 우선 검증**, 사용자 인터페이스 조기 테스트
- [ ] **단점**: 하위 모듈 실제 기능 검증 지연, **많은 스텁 작성** 필요, 데이터 처리 로직 검증 어려움
- [ ] **회귀 테스트**: 각 통합 단계마다 기존 기능 재검증

---

## 217. 상향식 통합 테스트 (Bottom-Up)

- [ ] **최하위 모듈부터 상위 모듈 방향**으로 단계적 통합하면서 테스트
- [ ] **드라이버(Driver)** 사용: 미구현 상위 모듈을 **임시 모듈로 대체**
- [ ] **클러스터 통합**: **관련 모듈들을 그룹으로 묶어** 통합
- [ ] **장점**: **하위 모듈의 실제 기능 우선 검증**, **데이터 처리 로직 조기 테스트**, 스텁 작성 불필요
- [ ] **단점**: 상위 제어 로직 검증 지연, **드라이버 작성** 필요, 전체 시스템 구조 파악 어려움
- [ ] **스텁 불필요**: 하위부터 시작하므로 스텁 작성 불필요

---

## 218. 회귀 테스트 (Regression Test)

- [ ] 소프트웨어를 **수정하거나 기능을 추가한 후** **기존에 잘 작동하던 기능들이 여전히 정상** 작동하는지 확인
- [ ] **목적**: 코드 변경이 기존 기능에 **부정적 영향을 주지 않았는지** 확인
- [ ] **시점**: 단위, 통합, 시스템 등 **모든 테스트 단계 후** 수행 가능
- [ ] **자동화**: 테스트 케이스를 자동화하여 **효율적으로 반복 수행**
- [ ] **범위**: **전체 회귀**(전체 테스트 케이스) vs **부분 회귀**(변경된 부분만)
- [ ] **vs 재테스트**: 회귀(기존 기능 확인) vs 재테스트(특정 버그만 재검증)

---

## 219. 테스트 오라클 (Test Oracle)

- [ ] **테스트 수행 시 기대 결과(정답 기준)를 제공하는 메커니즘**
- [ ] **주요 유형**: **휴리스틱**(경험 기반 판단) + **대조**(기준 시스템과 비교) + **사양 기반**(명세서 기준) + **휴먼**(사람 직접 확인) + **속성 기반**(입출력 관계)
- [ ] **입력에 대한 올바른 출력** 또는 동작의 기준을 정의하여 **테스트 결과 판단**
- [ ] 테스트 결과가 기대 결과와 일치하는지 판단하는 **기준**
- [ ] **오라클 한계**: 휴리스틱(주관성), 휴먼(비용/시간 문제)

---

## 220. 테스트 오라클의 종류

- [ ] **참 오라클**: **모든 입력에 대해 정확한 기대 결과** 제공 (오류 검출률 높지만 구현 비용 큼)
- [ ] **샘플링 오라클**: **일부 입력 데이터에 대해서만** 기대 결과 제공 (대표 케이스만 검증)
- [ ] **휴리스틱 오라클**: **경험, 추정 등 직관에 의존** (빠르지만 신뢰도 낮고 주관 개입)
- [ ] **일관성 검사 오라클**: **이전 결과 또는 다른 시스템 결과**와 비교 (회귀 테스트, 버전 비교)
- [ ] **사양 기반 오라클**: **요구사항 명세서나 설계서**에 명시된 결과 기준 사용 (문서 기반 자동 판단)

---

## 221. 테스트 자동화 도구

- [ ] **반복적이고 수동으로 수행하기 어려운 테스트를 자동화**하여 효율성과 정확성 향상
- [ ] **정적 분석 도구**: 코드 **실행 없이 구조, 문법, 품질** 분석 (SonarQube, PMD, Cppcheck)
- [ ] **동적 분석 도구**: **실행 중 오류, 누수** 등 런타임 행위 분석 (Valgrind, Purify)
- [ ] **테스트 실행 도구**: **자동화된 테스트 케이스 실행**하고 결과 비교 (JUnit, Selenium, TestNG)
- [ ] **테스트 커버리지 도구**: 테스트가 **소스코드 어느 부분을 실행**했는지 측정 (JaCoCo, Cobertura)
- [ ] **성능 테스트 도구**: **부하, 응답 시간, 안정성** 측정 (Apache JMeter, LoadRunner)
- [ ] **테스트 관리 도구**: 테스트 **계획, 실행, 결함 추적, 보고** 종합 관리 (TestLink, HP ALM, Xray)

---

## 222. 테스트 하네스 구성 요소

- [ ] **모듈 단위 테스트 자동화 환경을 구성하는 도구 세트**
- [ ] **드라이버**: 하위 모듈 테스트 시 **상위 모듈 역할을 대신** 수행
- [ ] **스텁**: 상위 모듈 테스트 시 **하위 모듈을 가상으로 대체**
- [ ] **테스트 슈트**: 여러 테스트 케이스들을 **논리적으로 묶은 집합**
- [ ] **테스트 케이스**: **테스트 입력, 실행 조건, 기대 결과** 등 정의
- [ ] **테스트 스크립트**: **실행 절차에 대한 명세서**
- [ ] **목 오브젝트**: 외부 시스템과의 연동을 흉내 내는 **가짜 객체**

---

## 223. 결함 (Defect, Fault, Bug)

- [ ] 소프트웨어가 **요구사항 명세와 다르게 동작**하거나 의도한 결과를 제대로 생성하지 못하는 상태
- [ ] **용어 구분**: **오류**(Error, 개발자 실수) → **결함**(Defect, 코드 문제 요소) → **실패**(Failure, 시스템 잘못된 동작)
- [ ] **결함 유형**: **명세 결함**(요구사항 오류) + **설계 결함**(구조적 실수) + **코드 결함**(논리 오류) + **자료 결함**(데이터 오류) + **환경 결함**(외부 환경 충돌)
- [ ] **결함 생명주기**: 결함 발견 → 등록 → 분석/재현 → 수정 → 확인 → 종료
- [ ] **관리 도구**: Bugzilla, JIRA 등으로 결함 등록·추적·상태 변경 관리

---

## 224. 애플리케이션 성능 측정 지표

- [ ] **응답 시간**: 사용자의 요청 후 **응답이 시작되기까지의 시간** (네트워크 지연, 서버 처리 시간 포함)
- [ ] **처리량**: **단위 시간당 시스템이 처리하는 작업 수** (예: TPS)
- [ ] **경과 시간**: **작업 요청 시점부터 최종 출력 완료까지의 전체 소요 시간**
- [ ] **자원 사용률**: **CPU, 메모리, 네트워크** 등 자원이 실제 얼마나 사용되는지 비율로 측정
- [ ] **가용성**: 시스템이 **정상적으로 서비스된 시간의 비율**, **SLA 준수 판단 기준**

---

## 225. 최악의 시간 복잡도 (Big O)

- [ ] **빅오 표기법**은 알고리즘의 **최악 시간 복잡도** 표현, **입력 크기 n이 커질 때의 수행 시간 상한선**
- [ ] **기본 규칙**: 상수 및 낮은 차수 항 무시, **지배적인 항만 고려** (예: 2n²+3n+5 → O(n²))
- [ ] **주요 복잡도**: **O(1)**(상수) < **O(log n)**(로그) < **O(n)**(선형) < **O(n log n)**(선형로그) < **O(n²)**(이차) < **O(2ⁿ)**(지수) < **O(n!)**(팩토리얼)
- [ ] **예시**: 배열 접근(O(1)), 이진 탐색(O(log n)), 순차 탐색(O(n)), 병합정렬(O(n log n)), 버블정렬(O(n²))
- [ ] **vs 다른 표기법**: O(상한), Ω(하한), Θ(상하한 동일)

---

## 226. 순환 복잡도 (Cyclomatic Complexity)

- [ ] **프로그램의 논리적 복잡도를 측정**하는 지표, **모듈의 독립 실행 경로 수** 나타냄
- [ ] **계산 공식**: **V(G) = E – N + 2** (E=간선 수, N=노드 수) 또는 **V(G) = P + 1** (P=분기문 개수)
- [ ] **의미**: **독립 실행 경로 수** = **필요한 최소 테스트 케이스 수**
- [ ] **복잡도 기준**: V ≤ 10(단순), 10 < V ≤ 20(중간), V > 20(복잡)
- [ ] 복잡도가 높을수록 **유지보수성 저하**, **결함 확률 증가**

---

## 227. 소스 코드 최적화

- [ ] **코드의 실행 효율성과 유지보수성을 향상**시키기 위한 개선 작업
- [ ] **최적화 기법**: **알고리즘 개선**(시간·공간 복잡도) + **루프 최적화**(병합, 언롤링) + **메모리 접근 최적화**(캐시 친화적)
- [ ] **데드 코드 제거**(실행되지 않는 코드) + **인라인 함수**(함수 호출 오버헤드 제거) + **지연 초기화**(필요시 객체 생성)
- [ ] **부적절한 코드**: **스파게티 코드**(구조 없이 얽힌 코드) + **외계인 코드**(의도 파악 어려운 난해한 코드) + **데드 코드**(실행되지 않는 코드)

---

## 228. 클린 코드 작성 원칙

**클린 코드 5가지 원칙:**

- [ ] **가독성 (Readability)**: **이해하기 쉬운 용어와 들여쓰기** 유지
- [ ] **단순성 (Simplicity)**: 함수·클래스는 **한 가지 기능만 수행**, 작고 간결하게
- [ ] **의존성 배제 (Low Dependency)**: **다른 모듈에 미치는 영향을 최소화**
- [ ] **중복 제거 (DRY: Don't Repeat Yourself)**: **중복된 코드를 줄여** 유지보수성 향상
- [ ] **추상화 (Abstraction)**: **동일 수준의 추상화** 유지, 상세 구현은 하위 모듈에서 담당
- [ ] **읽기 쉽고, 이해하기 쉽고, 유지보수하기 쉬운 코드** 작성

---

## 229. 소스 코드 품질 분석 도구

- [ ] **코드를 실행하지 않고도** 소스 코드의 **구조, 스타일, 복잡도, 오류 가능성** 등을 분석하여 품질 문제 조기 발견
- [ ] **정적 분석 도구**: **코드 실행 없이** 문법 오류, 복잡도, 스타일, **보안 취약점** 점검 (SonarQube, PMD, cppcheck, checkstyle, Cobertura)
- [ ] **동적 분석 도구**: **프로그램 실행 중** 동작 분석하여 **런타임 오류, 메모리 누수, 스레드 문제** 점검 (Valgrind, Purify, JProfiler)
- [ ] **활용 목적**: 코딩 표준 준수 점검, **복잡도 및 중복 코드 탐지**, 코드 품질 향상, **메모리 누수/스레드 이슈** 사전 검출
- [ ] 개발 초기 단계에서 **품질 문제를 조기에 발견하고 예방** 지원