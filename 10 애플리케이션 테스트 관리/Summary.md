## 🔹 202. 애플리케이션 테스트의 기본 원리

#### 📘 정의
애플리케이션 테스트의 기본 원리는 **소프트웨어 테스트가 왜 필요한지, 테스트를 어떻게 해석해야 하는지에 대한 이론적 기반**을 의미한다.  
정보처리기사 실기에서는 **오류 존재 증명**, **결함 집중**, **완전 테스트 불가성**, **살충제 패러독스** 등 **6가지 원리**가 출제된다.

#### 🧩 테스트의 6대 기본 원리

| 원리명 | 설명 |
|--------|------|
| **1. 결함 존재의 원리**<br>(Testing shows the presence of defects) | 테스트는 결함의 존재를 밝힐 수는 있지만, **결함이 없음을 증명할 수는 없다.** |
| **2. 완전 테스트 불가능의 원리**<br>(Exhaustive testing is impossible) | 모든 입력값/경우를 다 테스트하는 것은 **비현실적**이며, 일부 샘플 기반 테스트로 **품질을 추정**할 수밖에 없다. |
| **3. 결함 집중의 원리**<br>(Defect clustering) | 대부분의 결함은 **일부 모듈, 기능, 구간**에 집중되며, **파레토 법칙(80:20)**처럼 특정 영역에 결함이 몰리는 경향이 있다. |
| **4. 살충제 패러독스**<br>(Pesticide paradox) | 같은 테스트 케이스로 반복 테스트하면 **더 이상 새로운 결함을 찾기 어려움** → 테스트 케이스 **주기적 수정·보완 필요** |
| **5. 테스트의 정황 의존성 원리**<br>(Testing is context dependent) | 테스트는 **소프트웨어의 성격, 목적, 도메인**에 따라 방식이 달라진다. (ex. 게임 vs 은행 시스템 테스트 방식 다름) |
| **6. 오류-부재의 궤변**<br>(Absence-of-errors fallacy) | 모든 기능이 정확히 작동해도, **사용자의 요구사항을 충족하지 못하면 테스트는 실패** → **요구사항 기반 테스트가 중요**

> 💡 실제 시험에서는 "살충제 패러독스", "오류-부재의 궤변", "완전 테스트 불가성"이 가장 자주 출제됨  
> 💡 시험 문제 유형: “다음 중 테스트 기본 원리에 해당하지 않는 것은?”, “설명에 맞는 테스트 원리를 고르시오” 등

#### 📝 기출 포맷 예시

- 다음 중 테스트 기본 원리와 거리가 먼 것은?
- 같은 테스트 반복 시 효과가 떨어지는 이유는?
- 테스트가 오류가 없음을 보장하지 못하는 이유는?

#### 🧠 용어 설명

- **결함 존재 원리**: 테스트는 결함이 *있음을* 확인하는 수단
- **결함 집중 원리**: 오류는 특정 영역에 집중되는 경향
- **살충제 패러독스**: 테스트 케이스가 고정되면 효과 감소
- **오류-부재 궤변**: 기능이 맞아도 요구를 못 맞추면 실패
- **테스트 정황 의존성**: 상황·도메인에 따라 테스트 전략이 다름
- **완전 테스트 불가능**: 모든 경우의 수를 다 테스트할 수는 없음

---

## 🔹 202. 애플리케이션 테스트의 기본 원리

#### 📘 정의
애플리케이션 테스트의 기본 원리는 **소프트웨어 테스트가 왜 필요한지, 테스트를 어떻게 해석해야 하는지에 대한 이론적 기반**을 의미한다.  
정보처리기사 실기에서는 **오류 존재 증명**, **결함 집중**, **완전 테스트 불가성**, **살충제 패러독스** 등 **6가지 원리**가 출제된다.

#### 🧩 테스트의 6대 기본 원리

| 원리명                                                          | 설명 |
|--------------------------------------------------------------|------|
| **1. 결함 존재의 원리**<br>(Testing shows the presence of defects)  | 테스트는 결함의 존재를 밝힐 수는 있지만, **결함이 없음을 증명할 수는 없다.** |
| **2. 완벽한 테스트 불가능의 원리**<br>(Exhaustive testing is impossible) | 모든 입력값/경우를 다 테스트하는 것은 **비현실적**이며, 일부 샘플 기반 테스트로 **품질을 추정**할 수밖에 없다. |
| **3. 결함 집중의 원리**<br>(Defect clustering)                      | 대부분의 결함은 **일부 모듈, 기능, 구간**에 집중되며, **파레토 법칙(80:20)**처럼 특정 영역에 결함이 몰리는 경향이 있다. |
| **4. 살충제 패러독스**<br>(Pesticide paradox)                       | 같은 테스트 케이스로 반복 테스트하면 **더 이상 새로운 결함을 찾기 어려움** → 테스트 케이스 **주기적 수정·보완 필요** |
| **5. 테스트의 정황 의존성 원리**<br>(Testing is context dependent)      | 테스트는 **소프트웨어의 성격, 목적, 도메인**에 따라 방식이 달라진다. (ex. 게임 vs 은행 시스템 테스트 방식 다름) |
| **6. 오류-부재의 궤변**<br>(Absence-of-errors fallacy)              | 모든 기능이 정확히 작동해도, **사용자의 요구사항을 충족하지 못하면 테스트는 실패** → **요구사항 기반 테스트가 중요**

> 💡 실제 시험에서는 "살충제 패러독스", "오류-부재의 궤변", "완전 테스트 불가성"이 가장 자주 출제됨  
> 💡 시험 문제 유형: “다음 중 테스트 기본 원리에 해당하지 않는 것은?”, “설명에 맞는 테스트 원리를 고르시오” 등

#### 📝 기출 포맷 예시

- 다음 중 테스트 기본 원리와 거리가 먼 것은?
- 같은 테스트 반복 시 효과가 떨어지는 이유는?
- 테스트가 오류가 없음을 보장하지 못하는 이유는?

#### 🧠 용어 설명

- **결함 존재 원리**: 테스트는 결함이 *있음을* 확인하는 수단
- **결함 집중 원리**: 오류는 특정 영역에 집중되는 경향
- **살충제 패러독스**: 테스트 케이스가 고정되면 효과 감소
- **오류-부재 궤변**: 기능이 맞아도 요구를 못 맞추면 실패
- **테스트 정황 의존성**: 상황·도메인에 따라 테스트 전략이 다름
- **완전 테스트 불가능**: 모든 경우의 수를 다 테스트할 수는 없음

---

## 🔹 203. 애플리케이션 테스트의 구분

#### 📘 정의
애플리케이션 테스트는 **목적, 실행 여부, 시점, 범위** 등에 따라 다양한 기준으로 구분된다.  
정보처리기사 실기에서는 **정적/동적 테스트**, **개발 단계별 테스트**, **목적 기반 테스트**, **레벨 기반 테스트**가 주로 출제된다.

#### 🧩 1. 실행 여부에 따른 구분

| 구분 | 설명 | 예시 |
|------|------|------|
| **정적 테스트** | 실행 없이 코드, 문서 등을 검토해 결함을 찾는 방법 | 코드 리뷰, 워크스루, 인스펙션 |
| **동적 테스트** | 애플리케이션을 **실행하여 동작을 검증** | 단위 테스트, 통합 테스트 등 |

> 💡 정적 테스트는 **비용이 저렴하고 초기 결함 검출**에 유리

#### 🧩 2. 개발 단계(시점)에 따른 구분

| 구분 | 설명 | 예시 |
|------|------|------|
| **개발자 테스트** | 개발자가 구현 후 자체 수행 | 단위 테스트 등 |
| **검증 테스트** | QA팀이 테스트 케이스 기반으로 검증 | 시스템 테스트 등 |
| **인수 테스트** | 사용자가 최종 수용 여부 판단 | 사용자 인수 테스트, 알파/베타 테스트 |

> 💡 실무에서는 **개발자 테스트 → 검증 테스트 → 인수 테스트** 순으로 진행

#### 🧩 3. 목적에 따른 구분

| 구분 | 설명 | 목적 |
|------|------|------|
| **기능 테스트** | 요구된 **기능 수행 여부** 확인 | 기능 동작 확인 |
| **성능 테스트** | **응답 시간, 처리량 등** 검증 | 비기능 요구 확인 |
| **보안 테스트** | 시스템의 **취약점 존재 여부** 확인 | 해킹, 침입 탐지 등 |
| **회귀 테스트** | 변경 후 **기존 기능이 잘 작동하는지** 재확인 | 유지보수 검증 |

> 💡 회귀 테스트는 **수정 후 영향도 최소화**를 위한 필수 단계

#### 🧩 4. 테스트 레벨에 따른 구분

| 테스트 수준 | 설명 | 대상 |
|-------------|------|------|
| **단위 테스트** | 모듈 또는 함수 단위로 수행 | 최소 기능 단위 |
| **통합 테스트** | 모듈 간 **연동**을 확인 | 인터페이스 |
| **시스템 테스트** | 전체 시스템 기준으로 테스트 | 전체 기능 |
| **인수 테스트** | 최종 사용자 입장에서 수용 여부 판단 | 실제 요구사항 만족 여부 |

> 💡 시험에서는 “테스트 수준”과 “단계별 수행자” 연결 문제가 자주 출제됨

#### 📝 기출 포맷 예시

- 다음 중 정적 테스트에 해당하는 것은?
- 테스트 목적에 따른 구분으로 옳은 것은?
- 단위 테스트와 통합 테스트의 차이를 설명하시오.

#### 🧠 용어 설명

- **정적 테스트**: 실행 없이 문서나 코드 구조 분석
- **동적 테스트**: 시스템 실행을 통해 결과 확인
- **성능 테스트**: 응답 시간, 처리 속도 등 검증
- **회귀 테스트**: 변경 이후 기존 기능 이상 여부 확인
- **인수 테스트**: 사용자가 최종 확인하는 단계

---

## 🔹 204. 시각에 따른 테스트 – 확인 / 검증

#### 📘 정의
시각에 따른 테스트는 **테스트 수행자가 소프트웨어를 바라보는 관점**에 따라 구분되며,  
정보처리기사 실기에서는 **확인(Verification)**과 **검증(Validation)**으로 구분된다.

#### 🧩 확인 (Verification)

- 소프트웨어가 **설계 명세서대로 올바르게 구현되었는지 확인**하는 과정
- **개발자 시각** 중심
- 코드, 설계 문서, 요구사항 분석서 등을 기반으로 정적 분석 수행
- 주로 **화이트박스 테스트** 활용

| 항목 | 설명 |
|------|------|
| 목적 | 요구사항이 **정확히 구현되었는가?** |
| 대상 | 설계 문서, 코드 |
| 방식 | 정적 테스트 중심 (리뷰, 코드 분석 등) |
| 예시 | 코드 리뷰, 유닛 테스트, 정적 분석 도구 활용 |

#### 🧩 검증 (Validation)

- 소프트웨어가 **사용자의 요구사항을 충족**하는지를 테스트하는 과정
- **사용자 시각** 중심
- 실제 동작을 테스트하여 기능 및 성능이 제대로 작동하는지 확인
- 주로 **블랙박스 테스트** 활용

| 항목 | 설명 |
|------|------|
| 목적 | 사용자가 **원하는 기능이 구현되었는가?** |
| 대상 | 실행 중인 시스템 |
| 방식 | 동적 테스트 중심 (실행 기반) |
| 예시 | 시스템 테스트, 인수 테스트 |


#### 🧩 관련 테스트 방식 연결

| 테스트 방식 | 확인 or 검증 | 설명 |
|-------------|---------------|------|
| 화이트박스 테스트 | 확인(Verification) | 내부 로직, 코드 검사 중심 |
| 블랙박스 테스트 | 검증(Validation) | 사용자 요구사항 만족 확인 |

> 💡 실기에서는 “검증 vs 확인”, “개발자 vs 사용자 시각”, “화이트박스 vs 블랙박스 대응 관계” 문제 자주 출제


#### 📝 기출 포맷 예시

- 다음 중 확인(Verification)에 해당하는 테스트는?
- 검증(Validation)의 정의로 옳은 것은?
- 화이트박스 테스트는 어떤 시각의 테스트인가?

#### 🧠 용어 설명

- **확인(Verification)**: 구현이 명세대로 되었는지 확인하는 활동
- **검증(Validation)**: 결과물이 사용자 요구를 충족하는지 점검
- **화이트박스 테스트**: 내부 구조 기반 테스트
- **블랙박스 테스트**: 입력-출력 기능 기반 테스트

---

## 🔹 205. 목적에 따른 테스트

#### 📘 정의
목적에 따른 테스트란, 소프트웨어가 특정 목표(예: 보안성, 성능, 회복력 등)를 얼마나 만족하는지를 평가하기 위해 수행하는 테스트 방법이다.  
정보처리기사 실기에서는 다음 7가지 유형이 핵심으로 다뤄진다.

#### 🧩 테스트 유형별 정리

| 테스트 명칭         | 설명 |
|---------------------|------|
| **회복 테스트 (Recovery Testing)** | 시스템에 장애나 오류를 인위적으로 발생시켜 **정상 상태로 복구되는지**를 확인하는 테스트. 백업, 자동 재시작, 복구 속도 등을 검증 |
| **보안 테스트 (Security Testing)** | **인증, 권한, 접근 통제, 취약점 존재 여부** 등을 테스트하여 데이터 유출이나 불법 침입에 대한 보호 능력을 평가 |
| **강도 테스트 (Stress Testing)** | 시스템에 **과도한 부하를 인위적으로 가해** 안정성, 처리 능력, 자원 관리 능력을 검증 |
| **성능 테스트 (Performance Testing)** | 시스템이 일정 시간 내 **응답 속도, 처리량, 자원 사용률** 등 요구 성능 조건을 만족하는지 확인 |
| **구조 테스트 (Structure Testing)** | 소프트웨어 내부 구조(모듈, 제어 흐름 등)를 분석하여 **논리적 결함이나 코드 복잡도** 등을 검증 |
| **회귀 테스트 (Regression Testing)** | 프로그램 수정, 기능 추가 등 변경이 발생한 뒤 **기존 기능이 정상 동작하는지** 확인하는 테스트 |
| **병행 테스트 (Parallel Testing)** | 변경 전 시스템과 변경 후 시스템에 동일 입력을 주고 **결과 일치 여부를 비교**하여 신뢰성 검증 |

#### 📝 기출 포맷 예시

- 회복 테스트는 무엇을 확인하는가?
- 다음 중 회귀 테스트의 설명으로 옳은 것은?
- 성능 테스트와 강도 테스트의 차이로 옳은 것은?

---

## 🔹 206. 화이트박스 테스트

#### 📘 정의
화이트박스 테스트는 소프트웨어의 **내부 구조(코드, 제어 흐름, 데이터 흐름 등)**를 직접 분석하고,  
**개발자 관점에서 논리, 로직, 경로** 등을 검증하는 테스트 방법이다.  
정보처리기사 실기에서는 주로 **코드 기반, 구조 중심 테스트**로 출제된다.

#### 🧩 특징
- **구조 기반 테스트**로 단위 및 통합 테스트 단계에서 수행
- **소스 코드와 설계 문서**를 기반으로 테스트 케이스 설계
- **제어 흐름, 조건, 데이터 흐름**에 초점
- 테스트의 완전도는 **커버리지 기준**으로 판단됨

#### 🧩 장점 / 단점

| 장점 | 단점 |
|------|------|
| 초기 결함 발견, 보안 취약점 탐지 유리 | 구현 의존적, 사용자 시나리오 검증 부족 |
| 코드 최적화, 내부 로직 개선 가능 | 코드 변경 시 테스트 유지보수 비용 발생 |

#### 🧩 적용 수준
- **단위 테스트(Unit Testing)**: 모듈 단위의 기능 검증
- **통합 테스트(Integration Testing)**: 모듈 간 인터페이스 및 데이터 흐름 검증
- (일부 경우) 시스템 테스트 수준에서도 내부 로직 기반 검증 수행 가능

#### 📝 시험 출제 예시
- 화이트박스 테스트의 특징은 무엇인가?
- WHB 테스트가 특히 어느 단계에서 수행되는가?
- WHB 테스트의 장단점을 비교 설명하시오

#### 🧠 용어 요약
- **구조 기반**: 내부 코드 구조·제어 흐름 중심 테스트
- **단위 중심**: 함수/모듈 단위로 실행 테스트
- **코드 커버리지**: 테스트 완전도 측정 기준 (문장, 분기 등)

---

## 🔹 207. 화이트박스 테스트의 종류

#### 📘 정의
화이트박스 테스트의 종류는 **코드 구조, 조건, 루프, 데이터 흐름** 등 소스 내부 특성에 따라 다양한 기법들을 활용하여 결함을 탐지하는 테스트 방법들을 의미합니다.

#### 🧩 주요 기법

| 기법명                  | 설명 |
|------------------------|------|
| **기초 경로 검사 (Base Path Testing)** | 프로그램의 제어 흐름 그래프 내 독립 경로를 모두 식별하고 테스트 케이스로 구성 |
| **제어 구조 테스트 (Control Structure Testing)** | 조건문, 반복문, 분기 등의 제어 흐름 요소에 대한 집중 테스트 |
| **데이터 흐름 테스트 (Data Flow Testing)** | 변수 선언, 할당, 사용 등의 흐름 간에 생기는 오류 검증 |
| **조건 테스트 (Condition Testing)** | 복합 조건 내 개별 조건 값의 참/거짓 경우를 모두 테스트 |
| **루프 테스트 (Loop Testing)** | 단일 루프, 중첩 루프, 경계 반복 횟수 등에 따라 다양한 루프 경로 검증 |
| **경로 테스트 (Path Testing)** | 가능한 모든 실행 경로를 따라 테스트 케이스 구성 |
| **예외 처리 테스트** | 예외 발생 조건과 예외 처리 흐름이 올바른지 확인 |

#### 📝 출제 예시
- "기초 경로 검사는 어떤 기준으로 테스트 경로를 선정하는가?"
- "데이터 흐름 테스트는 어떤 오류를 탐지하나요?"
- "루프 테스트는 어떤 상황에서 수행되나요?"

#### 🧠 용어 요약
- **기초 경로 검사**: 제어 흐름 그래프 기준 독립 경로 테스트
- **제어 구조 테스트**: 조건, 분기, 반복문 등 구조 요소 초점 테스트
- **데이터 흐름 테스트**: 변수의 라이프타입에 따른 흐름 오류 검증
- **조건 테스트**: 복합 조건 내 각각의 분기 조건별 검증
- **루프 테스트**: 최대/최소/중첩 반복 패턴에 따른 테스트
- **예외 처리 테스트**: 오류 발생 시 예외 처리 로직이 제대로 실행되는지 확인

---

## 🔹 208. 화이트박스 테스트의 검증 기준 (Coverage Criteria)

#### 📘 정의
화이트박스 테스트의 검증 기준이란, 테스트가 소스 코드의 내부를 **얼마나 철저하게 수행했는지를 정량적으로 평가하는 기준**이며,  
이를 **커버리지(Coverage)**라고 부른다.

#### 🧩 주요 커버리지 종류 (Coverage Types)

| 커버리지 종류 | 영어 명칭 | 설명 |
|---------------|-----------|------|
| 문장 커버리지 | Statement Coverage | 모든 코드 라인이 최소 1회 실행되었는지 확인 |
| 분기 커버리지 | Branch (Decision) Coverage | 모든 조건문의 참/거짓 분기 경로가 실행되었는지 확인 |
| 조건 커버리지 | Condition Coverage | 복합 조건 내 각 조건이 참/거짓 모두 수행되었는지 확인 |
| 조건-결정 커버리지 | Condition-Decision Coverage | 조건 커버리지 + 분기 커버리지 동시 만족 |
| 변경조건/결정 커버리지 | Modified Condition/Decision Coverage (MC/DC) | 각 조건이 결과에 독립적으로 영향 주는지 확인 |
| 다중 조건 커버리지 | Multiple Condition Coverage | 모든 조건 조합을 테스트 (가장 포괄적) |
| 경로 커버리지 | Path Coverage | 가능한 모든 제어 흐름 경로를 테스트 |

#### 🧠 커버리지 계층 구조 (Coverage Inclusion)

- **문장 ⊂ 분기 ⊂ 조건 ⊂ 조건-결정 ⊂ MC/DC ⊂ 다중 조건 ⊂ 경로**

#### 📝 기출 포맷 예시

- “MC/DC란 무엇인가?”
- “문장 커버리지보다 높은 수준의 커버리지는?”
- “모든 조건 조합을 테스트하는 커버리지는 무엇인가?”

#### 🧠 용어 요약

- **Coverage**: 테스트 수행의 범위를 수치로 표현한 기준
- **Statement**: 코드 라인의 실행 여부
- **Branch**: 조건문의 분기(True/False) 처리 여부
- **MC/DC**: 개별 조건이 결과에 영향을 주는지 검증

---

## 🔹 209. 블랙박스 테스트

#### 📘 정의
블랙박스 테스트(Black‑Box Testing)는 소프트웨어의 **내부 구조를 보지 않고**,  
**입력과 출력의 기능적 관계**만을 보고 시스템이 요구사항을 충족하는지를 검증하는 기법입니다.  
정보처리기사 실기에서는 이를 **기능 테스트**라고 지칭하며,  
**명세서 기반 실행 테스트**로 출제됩니다.

#### 🧩 특징
- **외부 관점**: 사용자나 인터페이스 관점에서 요구사항 준수 여부 확인
- **실행 기반**: 실제 입력값을 넣어 결과를 관찰하고 비교
- **비구조 중심**: 내부 코드나 구현 논리는 전혀 참조하지 않음
- **테스트 시점**: 통합 또는 시스템 테스트 단계에서 주로 사용

#### 📝 시험 출제 예시
- “블랙박스 테스트의 정의는 무엇인가?”
- “WHB 테스트와 BBT 테스트의 관점 차이를 설명하라.”
- “블랙박스 테스트는 어느 테스트 단계에서 수행되는가?”

#### 🧠 용어 요약
- **명세 기반**: 요구사항 문서나 설계서에 따라 테스트
- **기능 검증**: 실제 시스템을 실행해 기능 동작 여부 확인
- **사용자 시각**: 내부 구조 대신 입력/출력 흐름 중심 접근

---

## 🔹 210. 블랙박스 테스트의 종류

#### 📘 정의
블랙박스 테스트는 내부 구조를 보지 않고 **입력-출력 기능 중심**으로 시스템이 명세대로 동작하는지 검증하는 테스트 기법입니다.

#### 🧩 핵심 기법

| 기법명            | 영어명                     | 설명 |
|-------------------|----------------------------|------|
| 동등 분할         | Equivalence Partitioning   | 입력 영역을 유효/무효 그룹으로 나눠 대표값만 테스트 |
| 경계값 분석       | Boundary Value Analysis    | 최소/최대 경계 및 인근 값 중심으로 테스트 |
| 결정 테이블       | Decision Table Testing     | 조건-행동 조합을 표로 정리해 모든 조합 검증 |
| 상태 전이         | State Transition Testing   | 상태와 이벤트 흐름에 따라 상태 변화 검증 |
| 원인-효과 그래프  | Cause‑Effect Graphing      | 입력‑출력 관계를 논리 그래프로 시각화하여 테스트 |
| 비교 테스트       | Comparison Testing         | 다른 버전/시스템과 **동일 입력→결과 비교** 검증 |
| 오류 예측         | Error Guessing             | 경험 기반 직관으로 잠재 결함 예상 테스트 |

#### 🧠 정처기 출제 포인트
- 동등 분할 vs 경계값 분석 차이 이해
- 비교 테스트: 다른 시스템과 결과 비교 방식 ([시뮝 연구소](https://simuing.tistory.com/entry/2024-%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC-%EC%8B%A4%EA%B8%B0-%EB%B8%94%EB%9E%99%EB%B0%95%EC%8A%A4-%ED%85%8C%EC%8A%A4%ED%8A%B8?utm_source=chatgpt.com), [Devinus](https://devinus.tistory.com/6?utm_source=chatgpt.com) 등이 비교검사 언급)
- 오류 예측: 경험 기반 결함 검출 방식 강조

#### 📝 시험 예시
- “비교 테스트는 어떤 방식인가?”
- “오류 예측 테스트의 특징은?”
- “경계값 분석과 동등 분할의 차이는?”

#### 🧠 용어 요약
- **Comparison Testing**: 동일 입력을 다른 시스템/버전에서 실행해 결과 비교
- **Error Guessing**: 경험과 직관으로 결함 가능성을 추정하고 테스트 설계

---

## 🔹 211. 개발 단계에 따른 애플리케이션 테스트

#### 📘 정의
소프트웨어 개발 단계에 따라 테스트를 수행하는 방식으로,  
각 단계에서 생성된 산출물(요구사항, 설계 등)을 기준으로  
적절한 수준의 테스트를 대응시켜 소프트웨어 품질을 검증한다.  
정처기 실기에서는 **V-모델**과 함께 자주 출제된다.

#### 🧩 개발 단계와 테스트 단계의 대응 관계 (V-모델 기반)

| 개발 단계      | 대응 테스트 단계              | 설명 |
|------------|-------------------------------|------|
| 요구사항 분석    | 인수 테스트 (Acceptance Test) | 사용자의 요구사항이 모두 반영되었는지 확인 |
| 분석         | 시스템 테스트 (System Test)   | 전체 시스템이 요구 명세대로 동작하는지 검증 |
| 설계 | 통합 테스트 (Integration Test)| 모듈 간 연결과 데이터 흐름의 정확성 확인 |
| 구현 (코딩)    | 단위 테스트 (Unit Test)       | 개별 모듈 내부 로직과 기능의 정확성 검증 |

→ **개발은 위에서 아래로**, **테스트는 아래에서 위로** 진행되며,  
→ **V 형태의 흐름**으로 시각화됨

#### 🧩 테스트 단계 핵심 요약

| 테스트 단계        | 설명 |
|--------------------|------|
| **단위 테스트**       | - 함수, 모듈 등 **최소 단위**의 기능 검증<br>- 내부 로직, 경로, 조건 검사 중심 |
| **통합 테스트**       | - 모듈 간 인터페이스 및 데이터 흐름 확인<br>- 상향식 / 하향식 / 빅뱅 방식 |
| **시스템 테스트**     | - 전체 시스템이 기능·비기능 요구사항 충족 여부 검증 |
| **인수 테스트**       | - 실제 운영 환경에서 사용자 요구사항이 만족되는지 확인<br>- 고객/사용자 중심 테스트 |

#### 📝 기출 포맷 예시
- V-모델에서 시스템 설계에 대응하는 테스트는?
- 다음 중 통합 테스트의 대상에 해당하는 것은?
- 개발 단계와 테스트 단계의 연결로 옳은 것은?

#### 🧠 용어 설명
- **V-모델**: 개발 단계와 테스트 단계가 1:1로 대응되는 구조
- **단위 테스트**: 모듈 단위의 내부 로직 검사
- **통합 테스트**: 모듈 간 연결 및 인터페이스 검증
- **시스템 테스트**: 전체 시스템의 기능성/성능 검증
- **인수 테스트**: 사용자 요구사항 기준 최종 검토

---

## 🔹 212. 단위 테스트 (Unit Test)

#### 📘 정의
단위 테스트는 **소프트웨어의 가장 작은 단위(모듈, 함수, 클래스 등)**를 개발자가 직접 테스트하여  
내부 로직, 인터페이스, 예외 처리 등을 검증하는 테스트 단계입니다.  
주로 구현 직후 수행되며, 결함을 조기에 발견하는 데 목적이 있습니다.

#### 🧩 주요 특징
- **목적**: 기능이 명세대로 동작하는지 확인, 내부 오류 조기 검출
- **수행 주체**: 개발자
- **테스트 범위**: 개별 모듈, 함수, 클래스 수준
- **검증 대상**: 인터페이스, 자료 구조, 조건문, 경로 흐름, 예외 처리
- **테스트 방식**:
    - 화이트박스 테스트(내부 로직 기반)
    - 경우에 따라 블랙박스 테스트(명세 기반)도 병행
- **자동화 도구**: JUnit(Java), pytest(Python), CppUnit(C++) 등
- **테스트 커버리지 측정 가능**: 명령문 커버리지, 분기 커버리지 등

#### 📝 출제 포인트
- **단위 테스트 = 개발자 주도, 모듈 내부 로직 검증**
- 주로 **화이트박스 테스트 기법** 적용됨
- **테스트 자동화 도구** 관련 문제 자주 출제됨
- **커버리지 기준**(라인, 분기 등) 구분 문제 가능

#### 🧠 용어 요약
- **단위 테스트**: 모듈 또는 함수 단위의 코드 검증
- **화이트박스 테스트**: 내부 구조를 기준으로 테스트
- **테스트 커버리지**: 코드 실행 범위를 측정하는 지표
- **테스트 오라클**: 테스트 결과의 정답 여부를 판단하는 기준
- **회귀 테스트**: 수정된 코드가 기존 기능에 영향을 미치지 않는지 확인

---

## 🔹 213. 통합 테스트 (Integration Test)

#### 📘 정의
단위 테스트가 완료된 모듈들을 결합하여 **모듈 간 인터페이스와 데이터 흐름**이 올바른지 검증하는 테스트입니다.  
정보처리기사 실기에서는 **불완전 통합(빅뱅)**과 **점진적 통합(하향식, 상향식, 혼합식)** 방식으로 자주 출제됩니다.

#### 🧩 주요 통합 방식

- **비점진적 통합 - 빅뱅 통합 (Big‑Bang Integration)**  
  모든 모듈을 한꺼번에 결합해 테스트.
    - 장점: 소규모 시스템에 빠르게 적용
    - 단점: 결함 원인 추적 어려움

- **점진적 통합 (Incremental Integration)**  
  모듈을 단계별로 결합하며 테스트
    - **하향식 (Top‑Down)**  
      상위 모듈부터 시작, **스텁(Stub)**으로 하위 모듈 대체  
      제어 흐름 테스트에 유리
    - **상향식 (Bottom‑Up)**  
      하위 모듈부터 결합, **드라이버(Driver)**로 상위 모듈 대체  
      데이터 흐름 테스트에 유리
    - **혼합식 (Sandwich/Hybrid)**  
      상향식과 하향식을 절충하여 동시에 적용

#### 📝 출제 포인트
- 각 통합 방식의 특징 및 장단점 비교
- 스텁/드라이버의 역할 이해
- 빅뱅 통합의 문제점 예시

#### 🧠 용어 요약
- **스텁(Stub)**: 하위 모듈이 준비되지 않았을 때 임시로 사용하는 대체 코드
- **드라이버(Driver)**: 상위 모듈이 없을 때 대체하는 테스트 호출 코드
- **빅뱅**: 모듈 전체 한 번에 결합 테스트
- **하향식**: 상위→하위 순서로 모듈 결합
- **상향식**: 하위→상위 순서로 모듈 결합
- **혼합식**: 두 방식을 동시에 사용

---

## 🔹 214. 시스템 테스트 (System Test)

#### 📘 정의
통합된 전체 시스템이 **기능 및 비기능 요구사항을 충족하는지 확인**하는 테스트입니다.  
실제 운영 환경 또는 이에 준하는 환경에서, 전체 애플리케이션의 동작을 종합적으로 검증합니다.  
정보처리기사 실기에서는 **블랙박스 방식**이 주로 사용되며, **명세 기반 기능 테스트 + 성능/보안 등 비기능 테스트** 구분이 중요합니다.
개발된 소프트웨어가 해당 컴퓨터 시스템에서 완벽하게 수행되는가

#### 🧩 주요 특징
- **대상**: 전체 시스템의 모든 기능 및 비기능 요소
- **목적**:
    - 기능 테스트: 요구사항에 따른 기능 수행 여부
    - 비기능 테스트: 성능, 보안, 안정성, 신뢰성 등 검증
- **테스트 방식**: E2E 관점, 블랙박스 방식
- **실행 환경**: 운영 환경과 유사한 테스트 환경에서 수행
- **수행 주체**: QA팀 또는 독립 테스터

#### 📝 시험 출제 포인트
- 시스템 테스트는 **기능 + 비기능 테스트 모두 포함**
- 성능 테스트 유형: 부하, 스트레스, 내구성 테스트
- **보안 테스트, 신뢰성 테스트**도 포함되어 출제됨
- **통합 테스트와 시스템 테스트의 차이** 이해 필요

#### 🧠 용어 요약
- **시스템 테스트(String Test)**: 전체 시스템이 명세와 일치하는지 검증
- **기능 테스트(Functional Test)**: 기능 요구사항 중심
- **성능 테스트(Performance Test)**: 처리 속도·용량·반응 시간 등 평가
- **보안 테스트(Security Test)**: 인증·접근 통제·취약점 점검
- **신뢰성 테스트(Reliability Test)**: 장애 발생 및 복구 능력 검증

---

## 🔹 215. 인수 테스트 (Acceptance Test)

#### 📘 정의
인수 테스트는 **최종 사용자 또는 고객이 실제 시스템을 운영 환경에서 평가**하는 단계입니다.  
요구사항이 제대로 반영되었고, 실 사용 환경에서 안정적으로 동작하는지를 검증하는 **최종 승인 절차**입니다.

#### 🧩 주요 특징
- **검증 주체**: 최종 사용자, 고객 또는 이해관계자
- **대상**: 완성된 시스템, 실사용 데이터 및 환경
- **목적**:
    - 요구사항 충족 여부 확인
    - 실제 운영 환경에서의 **안정성, 호환성, 사용성** 평가
- **테스트 방식**: 요구사항 기반 명세용 블랙박스 테스트
- **완료 기준**: 사용자 또는 고객의 **체크리스트 기반 승인** 후 시스템 인수

#### 📝 시험 출제 포인트
- 인수 테스트와 시스템 테스트의 차이 설명
- **UAT(User Acceptance Test)**와 연관 개념
- 인수 테스트 합격 기준 및 사후 대응 절차

#### 🧠 용어 요약
- **인수 테스트 (Acceptance Test)**: 고객이 참가해 실제 요구사항 평가
- **UAT(User Acceptance Test)**: 최종 사용자 주도의 인수 테스트
- **인수 승인 기준**: 요구사항 만족, 결함 허용 범위, 사용성 테스트 결과 등  

---
## 🔹 216. 하향식 통합 테스트 (Top-Down Integration Test)

#### 📘 정의
하향식 통합 테스트는 **최상위 모듈부터 하위 모듈 방향으로 단계적으로 통합하면서 테스트를 수행하는 방식**이다.  
아직 구현되지 않은 하위 모듈은 **스텁(Stub)**으로 대체하여 테스트를 진행한다.

#### 🧩 테스트 절차

1. **최상위 모듈** 단독 테스트 실행
2. **스텁으로 하위 모듈** 임시 대체
3. **깊이 우선** 또는 **너비 우선** 방식으로 통합
4. **스텁을 실제 모듈로** 단계적 교체
5. **회귀 테스트**로 기존 기능 검증
6. **모든 모듈 통합 완료**까지 반복

#### 🧩 주요 특징

| 특징 | 설명 |
|------|------|
| **통합 방향** | 상위 모듈 → 하위 모듈 순서로 진행 |
| **스텁 사용** | 미구현 하위 모듈을 임시 모듈로 대체 |
| **통합 방식** | 깊이 우선(Depth-First) 또는 너비 우선(Breadth-First) |
| **회귀 테스트** | 각 통합 단계마다 기존 기능 재검증 |

#### 🧩 장·단점

| 구분 | 내용 |
|------|------|
| **장점** | • 초기에 전체 시스템 구조 파악 가능<br>• 상위 제어 로직 우선 검증<br>• 사용자 인터페이스 조기 테스트 |
| **단점** | • 하위 모듈 실제 기능 검증 지연<br>• 많은 스텁 작성 및 관리 필요<br>• 데이터 처리 로직 검증 어려움 |

#### 📝 기출 포맷 예시

- 하향식 통합 테스트에서 사용하는 **임시 모듈**은?
- 다음 중 하향식 통합 테스트의 **장점**으로 옳은 것은?
- **깊이 우선**과 **너비 우선** 통합 방식의 차이점은?

#### 🧠 용어 설명

- **스텁(Stub)**: 하위 모듈 대신 사용하는 임시 모듈로, 최소한의 입출력 기능만 구현
- **깊이 우선**: 한 경로를 끝까지 통합한 후 다른 경로로 이동하는 방식
- **너비 우선**: 같은 레벨의 모듈들을 먼저 통합한 후 하위 레벨로 이동하는 방식
- **회귀 테스트**: 새로운 모듈 통합 후 기존 기능이 정상 작동하는지 확인하는 테스트

---

## 🔹 217. 상향식 통합 테스트 (Bottom-Up Integration Test)

#### 📘 정의
상향식 통합 테스트는 **최하위 모듈부터 상위 모듈 방향으로 단계적으로 통합하면서 테스트를 수행하는 방식**이다.  
아직 구현되지 않은 상위 모듈은 **드라이버(Driver)**로 대체하여 테스트를 진행한다.

#### 🧩 테스트 절차

1. **최하위 모듈들** 단독 테스트 실행
2. **드라이버로 상위 모듈** 임시 대체
3. **관련 모듈들을 클러스터로** 그룹화
4. **클러스터 단위로** 점진적 통합
5. **드라이버를 실제 모듈로** 단계적 교체
6. **회귀 테스트**로 기존 기능 검증
7. **모든 모듈 통합 완료**까지 반복

#### 🧩 주요 특징

| 특징 | 설명 |
|------|------|
| **통합 방향** | 하위 모듈 → 상위 모듈 순서로 진행 |
| **드라이버 사용** | 미구현 상위 모듈을 임시 모듈로 대체 |
| **클러스터 통합** | 관련 모듈들을 그룹으로 묶어 통합 |
| **스텁 불필요** | 하위부터 시작하므로 스텁 작성 불필요 |

#### 🧩 장·단점

| 구분 | 내용 |
|------|------|
| **장점** | • 하위 모듈의 실제 기능 우선 검증<br>• 데이터 처리 로직 조기 테스트<br>• 스텁 작성 불필요 |
| **단점** | • 상위 제어 로직 검증 지연<br>• 드라이버 작성 및 관리 필요<br>• 전체 시스템 구조 파악 어려움 |

#### 📝 기출 포맷 예시

- 상향식 통합 테스트에서 사용하는 **임시 모듈**은?
- 다음 중 상향식 통합 테스트의 **특징**으로 옳은 것은?
- **하향식**과 **상향식** 통합 테스트의 차이점은?

#### 🧠 용어 설명

- **드라이버(Driver)**: 상위 모듈 대신 사용하는 임시 모듈로, 하위 모듈을 호출하는 기능 구현
- **클러스터(Cluster)**: 관련된 하위 모듈들을 그룹으로 묶어 통합하는 단위
- **점진적 통합**: 단계별로 모듈을 결합하며 전체 시스템을 구축하는 방식
- **회귀 테스트**: 새로운 모듈 통합 후 기존 기능이 정상 작동하는지 확인하는 테스트

---

## 🔹 218. 회귀 테스트 (Regression Test)

#### 📘 정의
회귀 테스트는 소프트웨어를 수정하거나 기능을 추가한 후에,  
기존에 잘 작동하던 기능들이 여전히 정상적으로 작동하는지 확인하기 위해 수행하는 테스트입니다.

#### 🧩 주요 특징
- **목적**: 코드 변경이 기존 기능에 **부정적 영향**을 주지 않았는지 확인
- **시점**: 단위, 통합, 시스템 등 **모든 테스트 단계 후** 수행 가능
- **자동화**: 테스트 케이스를 자동화하여 효율적으로 반복 수행
- **범위 선택 방식**:
    - 전체 회귀(Full Regression): 전체 테스트 케이스 재실행
    - 부분 회귀(Selective Regression): 변경된 부분만 테스트

#### 🧩 장·단점

| 구분      | 내용 |
|----------|------|
| **장점**  | • 수정/추가 후 기존 기능 보호<br>• 품질 유지 및 안정성 확보 |
| **단점**  | • 테스트 범위가 넓어지면 시간과 비용이 증가<br>• 테스트 스위트 관리 필요 |

#### 📝 기출 포맷 예시
- "회귀 테스트는 언제 사용되나요?"
- "회귀 테스트와 재테스트(re‑test)의 차이는?"
- "부분 회귀와 전체 회귀의 차이점을 설명하시오."

#### 🧠 용어 설명
- **회귀 테스트(Regression Test)**: 변경 후 기존 기능의 정상 작동 여부 확인
- **재테스트(Re-test)**: 특정 버그를 수정한 후, 그 버그만 재검증하는 테스트
- **전체 회귀 vs 부분 회귀**: 전체 기능 대상 또는 변경된 부분만 대상 테스트

---

## 🔹 219. 테스트 오라클 (Test Oracle)

#### 📘 정의
테스트 오라클은 **테스트 수행 시 기대 결과(정답 기준)를 제공하는 메커니즘 또는 기준**입니다.  
즉, 입력에 대한 올바른 출력 또는 동작의 기준을 정의하여 테스트 결과를 판단합니다.

#### 🧩 주요 유형
- **휴리스틱 오라클**: 경험 기반 판단 (예: "느려보인다", "이상없다" 등의 직관적 판단)
- **대조 오라클**: 기준 시스템이나 이전 버전과 결과 비교
- **사양 기반 오라클**: 요구사항/명세서에 명시된 결과와 비교
- **휴먼 오라클**: 사람에 의한 직접 확인과 검증
- **속성 기반 오라클**: 입력/출력 간 속성 관계(예: 파싱한 개수가 원본보다 많지 않다 등) 점검

#### 📝 출제 포인트
- 각각의 오라클 유형 정의와 특징 구분
- 테스트 설계 시 어떤 오라클을 사용할지 선택 문제
- 오라클의 한계 예: 휴리스틱 오라클은 주관성, 휴먼 오라클은 비용/시간 문제

#### 🧠 용어 요약
- **Oracles**: 테스트 결과의 정답 여부를 가늠하는 기준
- **Heuristic Oracle**: 경험/직관에 따라 결과를 판단
- **Golden Master**: 기준 시스템의 실행 결과
- **Specification-based Oracle**: 문서화된 사양 기준 판단
- **Consistency Oracle**: 속성 기반(입력 대비 요구 관계) 점검

---

## 🔹 220. 테스트 오라클의 종류

#### 📘 정의
테스트 오라클은 **테스트 결과가 올바른지 판단할 수 있는 기준**이며,  
**예상 결과(기대값)**와 실제 결과를 비교하여 **오류 여부를 판별**하는 역할을 한다.

#### 🧩 주요 오라클 종류

| 오라클 종류                              | 정의 | 특징 및 사용 상황 |
|-------------------------------------|------|------------------|
| **참 오라클 (True Oracle)**             | 모든 입력에 대해 정확한 기대 결과 제공 | 오류 검출률 높지만, 구현과 유지 비용이 매우 큼 |
| **샘플링 오라클 (Sampling Oracle)**       | 일부 입력 데이터에 대해서만 기대 결과 제공 | 전체 케이스가 불가능할 때 대표 케이스만 검증 |
| **휴리스틱(추정) 오라클 (Heuristic Oracle)** | 일부 정확한 결과 외에는 경험, 추정 등 직관에 의존 | 빠르지만 신뢰도 낮고 테스트자 주관 개입 가능성 있음 |
| **일관성 검사 오라클 (Consistent Oracle)**  | 이전 결과 또는 다른 시스템 결과와 비교 | 회귀 테스트, 버전 비교 등에 효과적 |
| **사양 기반 오라클 (Specified Oracle)**    | 요구사항 명세서나 설계서에 명시된 결과 기준 사용 | 문서 기반 자동 판단 가능, 명세 정확도에 의존 |

#### 🧩 기출 포맷 예시

- 다음 중 참 오라클(True Oracle)의 특징으로 가장 옳은 것은?
- 다음 중 일관성 검사 오라클의 활용 예로 적절한 것은?
- 휴리스틱 오라클의 한계로 옳지 않은 것은?

#### 🧠 용어 설명

- **오라클 (Oracle)**: 테스트 결과가 기대 결과와 일치하는지 판단하는 기준
- **참 오라클 (True Oracle)**: 모든 입력값에 대한 정확한 기대값 제공
- **샘플링 오라클**: 일부 테스트 케이스에만 기대값 제공
- **휴리스틱 오라클**: 경험·직관 기반으로 정답 유무를 추정
- **일관성 검사 오라클**: 기준 시스템과 결과 비교
- **사양 기반 오라클**: 문서화된 기능 명세서와 비교

---

## 🔹 221. 테스트 자동화 도구 (Test Automation Tool)

#### 📘 정의
테스트 자동화 도구는 **반복적이고 수동으로 수행하기 어려운 테스트를 자동화하여 효율성과 정확성을 높이는 도구**입니다.  
테스트 스크립트, 실행, 결과 비교, 품질 측정 등 다양한 활동을 지원합니다.

#### 🧩 테스트 자동화 도구의 주요 유형

| 유형 | 영어명 | 정의 및 특징 | 대표 도구 |
|------|--------|----------------|------------|
| **정적 분석 도구** | Static Analysis Tool | 코드 실행 없이 구조, 문법, 품질을 분석 | SonarQube, PMD, Cppcheck |
| **동적 분석 도구** | Dynamic Analysis Tool | 실행 중 오류, 누수 등 런타임 행위 분석 | Valgrind, Purify |
| **테스트 실행 도구** | Test Execution Tool | 자동화된 테스트 케이스를 실행하고 결과 비교 | JUnit, Selenium, TestNG |
| **테스트 커버리지 도구** | Test Coverage Tool | 테스트가 소스코드 어느 부분을 실행했는지 측정 | JaCoCo, Cobertura |
| **성능 테스트 도구** | Performance Test Tool | 부하, 응답 시간, 안정성 등을 측정 | Apache JMeter, LoadRunner |
| **테스트 관리 도구** | Test Management Tool | 테스트 계획, 실행, 결함 추적, 보고 등 종합 관리 | TestLink, HP ALM, Xray (JIRA) |

#### 🧩 보조 자동화 도구 및 구성요소

| 보조 도구 | 영어명 | 설명 | 대표 예시 |
|-----------|--------|------|------------|
| **테스트 하네스** | Test Harness | 자동화 환경 구성 요소 (드라이버, 스텁, 슈트 등 포함) | 개발자 정의 |
| **테스트 케이스 생성 도구** | Test Case Generation Tool | 요구사항 기반으로 테스트 케이스 자동 생성 | Tcases, EvoSuite |
| **결함 추적 도구** | Bug Tracking Tool | 결함 기록, 수정 이력 추적 및 관리 | Bugzilla, JIRA |
| **테스트 시나리오 도구** | Test Scenario Tool | 시나리오 기반 테스트 설계 도구 | QTest, TestRail |

#### 🧩 테스트 하네스 주요 구성 요소

- **드라이버 (Driver)**: 상위 모듈을 대체해 하위 모듈 호출
- **스텁 (Stub)**: 하위 모듈을 대체해 상위 모듈 응답
- **테스트 슈트 (Test Suite)**: 테스트 케이스의 집합
- **테스트 케이스 (Test Case)**: 입력, 기대 결과, 수행 조건을 포함한 테스트 단위
- **목 오브젝트 (Mock Object)**: 외부 시스템 대신 사용할 가상 객체

#### 📝 기출 포맷 예시

- 정적 분석 도구에 해당하는 것은?
- 테스트 하네스 구성 요소로 옳은 것은?
- 테스트 커버리지 도구의 역할은 무엇인가?
- 테스트 케이스 생성 도구에 대한 설명으로 적절한 것은?

#### 🧠 용어 설명

- **Test Automation Tool**: 반복 작업 자동화를 통한 테스트 효율 향상 도구
- **Static/Dynamic Analysis Tool**: 실행 전/중의 코드 품질 분석 도구
- **Test Execution Tool**: 테스트 자동 실행 및 결과 비교 도구
- **Test Case Generation Tool**: 테스트 케이스를 자동으로 생성하는 도구
- **Test Harness**: 테스트 자동화 환경 구성 세트 (Stub, Driver 등 포함)
- **Bug Tracking Tool**: 결함의 기록과 이력을 관리하는 도구

---

## 🔹 222. 테스트 하네스 구성 요소 (Test Harness Components)

#### 📘 정의
**테스트 하네스(Test Harness)**는 **모듈 단위 테스트 자동화 환경을 구성하는 도구 세트**로,  
테스트 대상 모듈을 실행하고 결과를 검증하는 데 필요한 요소들을 포함합니다.

#### 🧩 구성 요소

| 구성 요소        | 영어명         | 설명                               |
|--------------|-------------|----------------------------------|
| **드라이버**     | Driver      | 하위 모듈 테스트 시, **상위 모듈 역할**을 대신 수행 |
| **스텁**       | Stub        | 상위 모듈 테스트 시, **하위 모듈을 가상으로 대체**  |
| **테스트 슈트**   | Test Suite  | 여러 테스트 케이스들을 **논리적으로 묶은 집합**     |
| **테스트 케이스**  | Test Case   | 테스트 입력, 실행 조건, 기대 결과 등 정의        |
| **테스트 스크립트** | Test Script  | 실행 절차에 대한 명세서                    |
| **목 오브젝트**   | Mock Object | 외부 시스템과의 연동을 흉내 내는 **가짜 객체**     |

#### 📝 출제 포인트
- 드라이버와 스텁의 구분
- 테스트 하네스가 **단위 테스트 자동화 환경**이라는 키워드
- 목(Mock) 객체의 목적: 외부 의존성 제거

#### 🧠 용어 요약
- **Driver**: 하위 모듈 호출용 임시 상위 모듈
- **Stub**: 하위 모듈 대신 응답해주는 임시 구성
- **Mock**: 외부 시스템을 흉내 내는 객체 (테스트 용도)

---

## 🔹 223. 결함 (Defect, Fault, Bug)

#### 📘 정의
**결함(Defect)**이란 소프트웨어가 요구사항 명세와 다르게 동작하거나,  
의도한 결과를 제대로 생성하지 못하는 상태를 말합니다.  
오류(Error) → 결함(Fault) → 실패(Failure)로 이어지는 원인-결과 흐름에서 **결함은 구현상의 실수**입니다.

#### 🧩 용어 비교

| 용어 | 영어 | 정의 |
|------|------|------|
| **오류** | Error | 개발자의 **사고·개념적 실수** (논리, 수식 오류 등) |
| **결함** | Defect / Fault / Bug | 코드 또는 설계에 포함된 **실제 문제 요소** |
| **실패** | Failure | 결함이 실행되어 나타나는 **시스템의 잘못된 동작** |

> 💡 결함이 항상 실패로 이어지는 것은 아니며, 실행 환경이나 조건에 따라 드러날 수도 있고 아닐 수도 있음

#### 🧩 결함 유형

- **명세 결함**: 요구사항 문서 자체의 오류 또는 누락
- **설계 결함**: 아키텍처, 모듈 설계 등 구조적 실수
- **코드 결함**: 구현 코드에서 발생한 논리 오류, 조건 오류 등
- **자료 결함**: 테스트 데이터, 입력값 오류 등
- **환경 결함**: OS, DB, 네트워크 등 외부 환경 요소와의 충돌

#### 🧩 결함 생명주기

1. **결함 발견**: 테스트 중 문제 발생
2. **결함 등록**: 결함 관리 시스템에 기록
3. **결함 분석 및 재현**: 원인 분석 및 조건 확인
4. **결함 수정**: 개발자가 소스코드 수정
5. **결함 확인**: 테스트 재수행 (회귀 테스트 포함)
6. **결함 종료**: 해결 완료로 판단되면 종료 처리

#### 🧩 실무 연계 도구

- **Bugzilla**, **JIRA** 등: 결함의 등록·추적·상태 변경 등을 자동 관리

#### 📝 기출 포맷 예시

- 결함과 오류, 실패의 차이를 설명하시오
- 다음 중 명세 결함에 해당하는 것은?
- 결함 생명주기의 단계로 옳은 것은?

#### 🧠 용어 설명

- **Defect(Fault, Bug)**: 소프트웨어에 존재하는 코드 또는 설계의 문제점
- **Failure**: 결함이 실행되어 시스템이 잘못 작동하는 현상
- **Error**: 개발자의 사고 또는 개념적 실수
- **Regression Test**: 결함 수정 후 기존 기능을 다시 확인하는 테스트

---

## 🔹 224. 애플리케이션 성능 측정 지표 (Application Performance Metrics)

#### 📘 정의
애플리케이션의 성능 측정 지표는 **시스템이 얼마나 효율적으로 동작하는지 평가하는 기준**으로,  
성능 병목을 진단하고 품질을 객관적으로 관리하기 위해 사용됩니다.

#### 🧩 주요 성능 지표

| 지표명 | 영어 | 설명 |
|--------|------|------|
| **응답 시간** | Response Time | 사용자의 요청 후 응답이 시작되기까지의 시간. 네트워크 지연, 서버 처리 시간 등을 포함 :contentReference[oaicite:1]{index=1} |
| **처리량** | Throughput | 단위 시간당 시스템이 처리하는 작업 수 (예: TPS) :contentReference[oaicite:2]{index=2} |
| **경과 시간** | Turnaround Time | 작업 요청 시점부터 최종 출력 완료까지의 전체 소요 시간 :contentReference[oaicite:3]{index=3} |
| **자원 사용률** | Resource Utilization | CPU, 메모리, 네트워크 등 자원이 실제 얼마나 사용되는지 비율로 측정 :contentReference[oaicite:4]{index=4} |
| **가용성** | Availability | 시스템이 정상적으로 서비스된 시간의 비율로, SLA 준수 판단 기준 :contentReference[oaicite:5]{index=5} |

#### 🧩 출제 포인트
- **응답 시간 vs 처리량 vs 경과 시간**의 개념 및 차이
- **가용성(Availability)**의 정의와 수치 해석 (예: “five nines”의 의미)
- **자원 사용률**을 통해 병목 지점 분석
- 각 지표가 성능 테스트(예: JMeter 등)나 모니터링 도구에서 어떻게 측정되는지 이해

#### 🧠 용어 설명
- **Response Time**: 사용자 화면 기준 응답 시작 시간
- **Throughput**: 시스템 처리량 (transactions/sec)
- **Turnaround Time**: 전체 처리 시간 (요청부터 완료까지)
- **Resource Utilization**: 주요 자원(CPU, 메모리 등) 사용 비율
- **Availability**: 시스템 운영 가능 시간의 비율 (가용성)

---

## 🔹 225. 최악의 시간 복잡도 (Worst‑Case Time Complexity, Big O)

#### 📘 정의
**빅오 표기법(Big O notation)**은 알고리즘의 **최악 시간 복잡도**를 표현하며, 입력 크기 n이 커질 때의 수행 시간 상한선을 나타냅니다.  
즉, 어떤 입력이 들어와도 이 시간 이상 걸리지 않음(The upper bound)  
{cite}:contentReference[oaicite:2]{index=2}

#### 🧩 기본 규칙
- 상수 및 낮은 차수 항 무시:  
  e.g., T(n)=2n²+3n+5 ⇒ **O(n²)**
- 입력 크기 n이 무한히 클 때 지배적인 항만 고려
- 대소문자 기준: O(), Ω(), Θ() 중 **O( )는 상한(최악)**을 의미 {cite}:contentReference[oaicite:3]{index=3}

#### 🧩 주요 시간 복잡도 예시

| 알고리즘 유형                 | 예시 알고리즘       | 최악 시간 복잡도 |
|-----------------------------|--------------------|------------------|
| **O(1)** (상수 시간)           | 배열 인덱스 접근        | O(1)             |
| **O(log n)** (로그 시간)       | 이진 탐색              | O(log n)         |
| **O(n)** (선형 시간)           | 순차 탐색              | O(n)             |
| **O(n log n)** (선형로그 시간) | 병합정렬, 힙정렬        | O(n log n)       |
| **O(n²)** (이차 시간)          | 버블정렬, 선택정렬      | O(n²)            |
| **O(2ⁿ)** (지수 시간)          | 피보나치 재귀 구현     | O(2ⁿ)            |
| **O(n!)** (팩토리얼 시간)       | 브루트포스 순열 생성   | O(n!)            |

#### 🧩 시험 출제 포인트
- 알고리즘 유형별 평균 vs 최악 시간 복잡도 구분
- 상수, 로그, 선형, 이차, 지수 등 **대표 복잡도 등급 구분**
- 복잡도 공식 단순화: `T(n)=n + n log n + 5` → O(n log n)
- 빅오(O)와 빅오메가(Ω), 빅시그마(Θ)의 차이

#### 🧠 용어 요약
- **최악 시간 복잡도**: 어떤 입력도 이 시간 이상 걸리지 않음을 보장
- **O(f(n))**: 시간 상한선(Upper bound)
- **Ω(f(n))**: 시간 하한선(Lower bound)
- **Θ(f(n))**: 상하한이 동일한 경우(Tight bound)

---

## 🔹 226. 순환 복잡도 (Cyclomatic Complexity)

#### 📘 정의
순환 복잡도(Cyclomatic Complexity)는 **프로그램의 논리적 복잡도를 측정하는 지표**로,  
제어 흐름도 기반으로 계산되며, 모듈의 **독립 실행 경로 수**를 나타냅니다.

#### 🧩 계산 공식

- **V(G) = E – N + 2**
    - E = 제어 흐름 그래프의 간선(Edge) 수
    - N = 노드(Node) 수 :contentReference[oaicite:1]{index=1}
- 또는 **V(G) = P + 1**
    - P = 분기문(if, for, while 등)의 개수 :contentReference[oaicite:2]{index=2}
- 또 하나: 영역 수(R) 기반 계산
    - V(G) = R (제어 흐름 그래프의 영역 개수) :contentReference[oaicite:3]{index=3}

#### 🧩 주요 의미 및 활용

- **독립 실행 경로 수** = 필요한 최소 테스트 케이스 수 :contentReference[oaicite:4]{index=4}
- 복잡도가 높을수록 유지보수성 저하, 결함 확률 증가 :contentReference[oaicite:5]{index=5}
- 일반적인 기준:
    - V ≤ 10: 단순
    - 10 < V ≤ 20: 중간
    - V > 20: 복잡 :contentReference[oaicite:6]{index=6}

#### 📝 출제 포인트
- 순환 복잡도 계산식 공식 및 활용 방법
- 분기문 개수 P + 1 공식과 제어 흐름 그래프(E–N+2) 공식 구분
- 복잡도 수치를 기준으로 프로그램 복잡도 수준 판단
- 독립 경로 수가 의미하는 테스트 케이스 수

#### 🧠 용어 요약
- **Cyclomatic Complexity**: 제어 흐름 기반 경로 수 지표
- **V(G)**: 순환 복잡도 값
- **Edge (E)**: 제어 흐름의 연결선 수
- **Node (N)**: 명령어 또는 블록 수
- **Predicate (P)**: 분기문(if, for, while, switch의 case 등)

---

## 🔹 227. 소스 코드 최적화 (Source Code Optimization)

#### 📘 정의
소스 코드 최적화는 **코드의 실행 효율성과 유지보수성을 향상**시키기 위한 개선 작업입니다.  
이는 컴파일러 수준의 최적화와 개발자가 직접 수행하는 코드 리팩토링을 포함합니다.

#### 🧩 최적화 기법 유형

| 기법 | 설명 | 효과 |
|------|------|------|
| **알고리즘 개선** | 더 나은 시간·공간 복잡도를 가진 알고리즘 또는 자료구조 적용 | 처리 속도 향상 |
| **루프 최적화** | 루프 병합, 루프 언롤링 등 반복문 효율화 | 연산량 감소 |
| **메모리 접근 최적화** | 캐시 친화적 구조로 배열 구성 등 | 캐시 미스 감소, 성능 향상 |
| **데드 코드 제거** | 실행되지 않는 코드 제거 | 불필요한 코드 제거로 가독성 향상 |
| **인라인 함수 사용** | 작은 함수 호출을 직접 코드로 삽입 | 함수 호출 오버헤드 제거 |
| **지연 초기화 (Lazy Initialization)** | 객체를 필요할 때 생성 | 메모리 낭비 방지, 초기 부하 감소 |

#### 🧩 부적절한 코드 예시

| 용어 | 설명 |
|------|------|
| **스파게티 코드 (Spaghetti Code)** | 구조 없이 얽히고설킨 코드, 흐름을 따라가기 어려움 |
| **외계인 코드 (Alien Code)** | 작성자의 의도나 문맥을 파악하기 어려운 난해한 코드 |
| **데드 코드 (Dead Code)** | 실행되지 않거나 의미 없는 코드 조각 |

> 💡 스파게티 코드나 외계인 코드는 유지보수성 저하의 대표 사례로, 정처기에서 부적절한 코드 사례로 출제 가능

#### 📝 출제 포인트
- 루프 최적화, 데드 코드 제거의 목적과 효과
- 코드 최적화 전·후 성능 차이
- 스파게티 코드와 같은 **비효율 코드** 구별

#### 🧠 용어 요약
- **Dead Code**: 실행되지 않는 코드
- **Loop Unrolling**: 루프 반복 횟수 줄이기 위한 전개 방식
- **Inline Function**: 함수 호출 대신 함수 내용을 직접 삽입
- **Lazy Initialization**: 사용 시점에 객체 생성
- **Spaghetti Code**: 흐름이 꼬여 있는 유지보수 어려운 코드
- **Alien Code**: 남이 작성한 이해 안 되는 복잡한 코드

---

## 🔹 228. 클린 코드 작성 원칙 (Clean Code Principles)

#### 📘 정의
클린 코드는 **읽기 쉽고, 이해하기 쉽고, 유지보수하기 쉬운 코드**로,  
가독성과 안정성, 변경 용이성을 극대화하는 코딩 방식입니다.

#### 🧩 핵심 원칙 (정처기 + 국내 자료 기준)

| 원칙 | 설명 |
|------|------|
| **가독성 (Readability)** | 이해하기 쉬운 용어와 들여쓰기 유지 :contentReference[oaicite:2]{index=2} |
| **단순성 (Simplicity)** | 함수·클래스는 **한 가지 기능만 수행**, 작고 간결하게 :contentReference[oaicite:3]{index=3} |
| **의존성 배제 (Low Dependency)** | 다른 모듈에 미치는 영향을 최소화 :contentReference[oaicite:4]{index=4} |
| **중복 제거 (DRY: Don’t Repeat Yourself)** | 중복된 코드를 줄여 유지보수성 향상 :contentReference[oaicite:5]{index=5} |
| **추상화 (Abstraction)** | 동일 수준의 추상화 유지, 상세 구현은 하위 모듈에서 담당 :contentReference[oaicite:6]{index=6} |

#### 📝 시험 출제 포인트
- 다수 기출: “클린 코드 5가지 항목 쓰시오” → *가독성, 단순성, 의존성 배제, 중복 제거, 추상화* :contentReference[oaicite:9]{index=9}
- DRY·단일 책임 강조 문제

#### 🧠 용어 요약
- **Clean Code**: 단순·명료·읽기 쉬운 고품질 코드
- **Simplicity**: 불필요한 복잡성 제거
- **Abstraction**: 상위 기능은 간결히, 세부는 숨기기
- **DRY**: 코드 중복 방지  
