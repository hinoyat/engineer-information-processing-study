## 🔹 202. 애플리케이션 테스트의 기본 원리

#### 📘 정의
애플리케이션 테스트의 기본 원리는 **소프트웨어 테스트가 왜 필요한지, 테스트를 어떻게 해석해야 하는지에 대한 이론적 기반**을 의미한다.  
정보처리기사 실기에서는 **오류 존재 증명**, **결함 집중**, **완전 테스트 불가성**, **살충제 패러독스** 등 **6가지 원리**가 출제된다.

#### 🧩 테스트의 6대 기본 원리

| 원리명 | 설명 |
|--------|------|
| **1. 결함 존재의 원리**<br>(Testing shows the presence of defects) | 테스트는 결함의 존재를 밝힐 수는 있지만, **결함이 없음을 증명할 수는 없다.** |
| **2. 완전 테스트 불가능의 원리**<br>(Exhaustive testing is impossible) | 모든 입력값/경우를 다 테스트하는 것은 **비현실적**이며, 일부 샘플 기반 테스트로 **품질을 추정**할 수밖에 없다. |
| **3. 결함 집중의 원리**<br>(Defect clustering) | 대부분의 결함은 **일부 모듈, 기능, 구간**에 집중되며, **파레토 법칙(80:20)**처럼 특정 영역에 결함이 몰리는 경향이 있다. |
| **4. 살충제 패러독스**<br>(Pesticide paradox) | 같은 테스트 케이스로 반복 테스트하면 **더 이상 새로운 결함을 찾기 어려움** → 테스트 케이스 **주기적 수정·보완 필요** |
| **5. 테스트의 정황 의존성 원리**<br>(Testing is context dependent) | 테스트는 **소프트웨어의 성격, 목적, 도메인**에 따라 방식이 달라진다. (ex. 게임 vs 은행 시스템 테스트 방식 다름) |
| **6. 오류-부재의 궤변**<br>(Absence-of-errors fallacy) | 모든 기능이 정확히 작동해도, **사용자의 요구사항을 충족하지 못하면 테스트는 실패** → **요구사항 기반 테스트가 중요**

> 💡 실제 시험에서는 "살충제 패러독스", "오류-부재의 궤변", "완전 테스트 불가성"이 가장 자주 출제됨  
> 💡 시험 문제 유형: “다음 중 테스트 기본 원리에 해당하지 않는 것은?”, “설명에 맞는 테스트 원리를 고르시오” 등

#### 📝 기출 포맷 예시

- 다음 중 테스트 기본 원리와 거리가 먼 것은?
- 같은 테스트 반복 시 효과가 떨어지는 이유는?
- 테스트가 오류가 없음을 보장하지 못하는 이유는?

#### 🧠 용어 설명

- **결함 존재 원리**: 테스트는 결함이 *있음을* 확인하는 수단
- **결함 집중 원리**: 오류는 특정 영역에 집중되는 경향
- **살충제 패러독스**: 테스트 케이스가 고정되면 효과 감소
- **오류-부재 궤변**: 기능이 맞아도 요구를 못 맞추면 실패
- **테스트 정황 의존성**: 상황·도메인에 따라 테스트 전략이 다름
- **완전 테스트 불가능**: 모든 경우의 수를 다 테스트할 수는 없음

---

## 🔹 202. 애플리케이션 테스트의 기본 원리

#### 📘 정의
애플리케이션 테스트의 기본 원리는 **소프트웨어 테스트가 왜 필요한지, 테스트를 어떻게 해석해야 하는지에 대한 이론적 기반**을 의미한다.  
정보처리기사 실기에서는 **오류 존재 증명**, **결함 집중**, **완전 테스트 불가성**, **살충제 패러독스** 등 **6가지 원리**가 출제된다.

#### 🧩 테스트의 6대 기본 원리

| 원리명                                                          | 설명 |
|--------------------------------------------------------------|------|
| **1. 결함 존재의 원리**<br>(Testing shows the presence of defects)  | 테스트는 결함의 존재를 밝힐 수는 있지만, **결함이 없음을 증명할 수는 없다.** |
| **2. 완벽한 테스트 불가능의 원리**<br>(Exhaustive testing is impossible) | 모든 입력값/경우를 다 테스트하는 것은 **비현실적**이며, 일부 샘플 기반 테스트로 **품질을 추정**할 수밖에 없다. |
| **3. 결함 집중의 원리**<br>(Defect clustering)                      | 대부분의 결함은 **일부 모듈, 기능, 구간**에 집중되며, **파레토 법칙(80:20)**처럼 특정 영역에 결함이 몰리는 경향이 있다. |
| **4. 살충제 패러독스**<br>(Pesticide paradox)                       | 같은 테스트 케이스로 반복 테스트하면 **더 이상 새로운 결함을 찾기 어려움** → 테스트 케이스 **주기적 수정·보완 필요** |
| **5. 테스트의 정황 의존성 원리**<br>(Testing is context dependent)      | 테스트는 **소프트웨어의 성격, 목적, 도메인**에 따라 방식이 달라진다. (ex. 게임 vs 은행 시스템 테스트 방식 다름) |
| **6. 오류-부재의 궤변**<br>(Absence-of-errors fallacy)              | 모든 기능이 정확히 작동해도, **사용자의 요구사항을 충족하지 못하면 테스트는 실패** → **요구사항 기반 테스트가 중요**

> 💡 실제 시험에서는 "살충제 패러독스", "오류-부재의 궤변", "완전 테스트 불가성"이 가장 자주 출제됨  
> 💡 시험 문제 유형: “다음 중 테스트 기본 원리에 해당하지 않는 것은?”, “설명에 맞는 테스트 원리를 고르시오” 등

#### 📝 기출 포맷 예시

- 다음 중 테스트 기본 원리와 거리가 먼 것은?
- 같은 테스트 반복 시 효과가 떨어지는 이유는?
- 테스트가 오류가 없음을 보장하지 못하는 이유는?

#### 🧠 용어 설명

- **결함 존재 원리**: 테스트는 결함이 *있음을* 확인하는 수단
- **결함 집중 원리**: 오류는 특정 영역에 집중되는 경향
- **살충제 패러독스**: 테스트 케이스가 고정되면 효과 감소
- **오류-부재 궤변**: 기능이 맞아도 요구를 못 맞추면 실패
- **테스트 정황 의존성**: 상황·도메인에 따라 테스트 전략이 다름
- **완전 테스트 불가능**: 모든 경우의 수를 다 테스트할 수는 없음

---

## 🔹 203. 애플리케이션 테스트의 구분

#### 📘 정의
애플리케이션 테스트는 **목적, 실행 여부, 시점, 범위** 등에 따라 다양한 기준으로 구분된다.  
정보처리기사 실기에서는 **정적/동적 테스트**, **개발 단계별 테스트**, **목적 기반 테스트**, **레벨 기반 테스트**가 주로 출제된다.

#### 🧩 1. 실행 여부에 따른 구분

| 구분 | 설명 | 예시 |
|------|------|------|
| **정적 테스트** | 실행 없이 코드, 문서 등을 검토해 결함을 찾는 방법 | 코드 리뷰, 워크스루, 인스펙션 |
| **동적 테스트** | 애플리케이션을 **실행하여 동작을 검증** | 단위 테스트, 통합 테스트 등 |

> 💡 정적 테스트는 **비용이 저렴하고 초기 결함 검출**에 유리

#### 🧩 2. 개발 단계(시점)에 따른 구분

| 구분 | 설명 | 예시 |
|------|------|------|
| **개발자 테스트** | 개발자가 구현 후 자체 수행 | 단위 테스트 등 |
| **검증 테스트** | QA팀이 테스트 케이스 기반으로 검증 | 시스템 테스트 등 |
| **인수 테스트** | 사용자가 최종 수용 여부 판단 | 사용자 인수 테스트, 알파/베타 테스트 |

> 💡 실무에서는 **개발자 테스트 → 검증 테스트 → 인수 테스트** 순으로 진행

#### 🧩 3. 목적에 따른 구분

| 구분 | 설명 | 목적 |
|------|------|------|
| **기능 테스트** | 요구된 **기능 수행 여부** 확인 | 기능 동작 확인 |
| **성능 테스트** | **응답 시간, 처리량 등** 검증 | 비기능 요구 확인 |
| **보안 테스트** | 시스템의 **취약점 존재 여부** 확인 | 해킹, 침입 탐지 등 |
| **회귀 테스트** | 변경 후 **기존 기능이 잘 작동하는지** 재확인 | 유지보수 검증 |

> 💡 회귀 테스트는 **수정 후 영향도 최소화**를 위한 필수 단계

#### 🧩 4. 테스트 레벨에 따른 구분

| 테스트 수준 | 설명 | 대상 |
|-------------|------|------|
| **단위 테스트** | 모듈 또는 함수 단위로 수행 | 최소 기능 단위 |
| **통합 테스트** | 모듈 간 **연동**을 확인 | 인터페이스 |
| **시스템 테스트** | 전체 시스템 기준으로 테스트 | 전체 기능 |
| **인수 테스트** | 최종 사용자 입장에서 수용 여부 판단 | 실제 요구사항 만족 여부 |

> 💡 시험에서는 “테스트 수준”과 “단계별 수행자” 연결 문제가 자주 출제됨

#### 📝 기출 포맷 예시

- 다음 중 정적 테스트에 해당하는 것은?
- 테스트 목적에 따른 구분으로 옳은 것은?
- 단위 테스트와 통합 테스트의 차이를 설명하시오.

#### 🧠 용어 설명

- **정적 테스트**: 실행 없이 문서나 코드 구조 분석
- **동적 테스트**: 시스템 실행을 통해 결과 확인
- **성능 테스트**: 응답 시간, 처리 속도 등 검증
- **회귀 테스트**: 변경 이후 기존 기능 이상 여부 확인
- **인수 테스트**: 사용자가 최종 확인하는 단계

---

## 🔹 204. 시각에 따른 테스트 – 확인 / 검증

#### 📘 정의
시각에 따른 테스트는 **테스트 수행자가 소프트웨어를 바라보는 관점**에 따라 구분되며,  
정보처리기사 실기에서는 **확인(Verification)**과 **검증(Validation)**으로 구분된다.

#### 🧩 확인 (Verification)

- 소프트웨어가 **설계 명세서대로 올바르게 구현되었는지 확인**하는 과정
- **개발자 시각** 중심
- 코드, 설계 문서, 요구사항 분석서 등을 기반으로 정적 분석 수행
- 주로 **화이트박스 테스트** 활용

| 항목 | 설명 |
|------|------|
| 목적 | 요구사항이 **정확히 구현되었는가?** |
| 대상 | 설계 문서, 코드 |
| 방식 | 정적 테스트 중심 (리뷰, 코드 분석 등) |
| 예시 | 코드 리뷰, 유닛 테스트, 정적 분석 도구 활용 |

#### 🧩 검증 (Validation)

- 소프트웨어가 **사용자의 요구사항을 충족**하는지를 테스트하는 과정
- **사용자 시각** 중심
- 실제 동작을 테스트하여 기능 및 성능이 제대로 작동하는지 확인
- 주로 **블랙박스 테스트** 활용

| 항목 | 설명 |
|------|------|
| 목적 | 사용자가 **원하는 기능이 구현되었는가?** |
| 대상 | 실행 중인 시스템 |
| 방식 | 동적 테스트 중심 (실행 기반) |
| 예시 | 시스템 테스트, 인수 테스트 |


#### 🧩 관련 테스트 방식 연결

| 테스트 방식 | 확인 or 검증 | 설명 |
|-------------|---------------|------|
| 화이트박스 테스트 | 확인(Verification) | 내부 로직, 코드 검사 중심 |
| 블랙박스 테스트 | 검증(Validation) | 사용자 요구사항 만족 확인 |

> 💡 실기에서는 “검증 vs 확인”, “개발자 vs 사용자 시각”, “화이트박스 vs 블랙박스 대응 관계” 문제 자주 출제


#### 📝 기출 포맷 예시

- 다음 중 확인(Verification)에 해당하는 테스트는?
- 검증(Validation)의 정의로 옳은 것은?
- 화이트박스 테스트는 어떤 시각의 테스트인가?

#### 🧠 용어 설명

- **확인(Verification)**: 구현이 명세대로 되었는지 확인하는 활동
- **검증(Validation)**: 결과물이 사용자 요구를 충족하는지 점검
- **화이트박스 테스트**: 내부 구조 기반 테스트
- **블랙박스 테스트**: 입력-출력 기능 기반 테스트

---

## 🔹 205. 목적에 따른 테스트

#### 📘 정의
목적에 따른 테스트란, 소프트웨어가 특정 목표(예: 보안성, 성능, 회복력 등)를 얼마나 만족하는지를 평가하기 위해 수행하는 테스트 방법이다.  
정보처리기사 실기에서는 다음 7가지 유형이 핵심으로 다뤄진다.

#### 🧩 테스트 유형별 정리

| 테스트 명칭         | 설명 |
|---------------------|------|
| **회복 테스트 (Recovery Testing)** | 시스템에 장애나 오류를 인위적으로 발생시켜 **정상 상태로 복구되는지**를 확인하는 테스트. 백업, 자동 재시작, 복구 속도 등을 검증 |
| **보안 테스트 (Security Testing)** | **인증, 권한, 접근 통제, 취약점 존재 여부** 등을 테스트하여 데이터 유출이나 불법 침입에 대한 보호 능력을 평가 |
| **강도 테스트 (Stress Testing)** | 시스템에 **과도한 부하를 인위적으로 가해** 안정성, 처리 능력, 자원 관리 능력을 검증 |
| **성능 테스트 (Performance Testing)** | 시스템이 일정 시간 내 **응답 속도, 처리량, 자원 사용률** 등 요구 성능 조건을 만족하는지 확인 |
| **구조 테스트 (Structure Testing)** | 소프트웨어 내부 구조(모듈, 제어 흐름 등)를 분석하여 **논리적 결함이나 코드 복잡도** 등을 검증 |
| **회귀 테스트 (Regression Testing)** | 프로그램 수정, 기능 추가 등 변경이 발생한 뒤 **기존 기능이 정상 동작하는지** 확인하는 테스트 |
| **병행 테스트 (Parallel Testing)** | 변경 전 시스템과 변경 후 시스템에 동일 입력을 주고 **결과 일치 여부를 비교**하여 신뢰성 검증 |

#### 📝 기출 포맷 예시

- 회복 테스트는 무엇을 확인하는가?
- 다음 중 회귀 테스트의 설명으로 옳은 것은?
- 성능 테스트와 강도 테스트의 차이로 옳은 것은?

---

## 🔹 206. 화이트박스 테스트

#### 📘 정의
화이트박스 테스트는 소프트웨어의 **내부 구조(코드, 제어 흐름, 데이터 흐름 등)**를 직접 분석하고,  
**개발자 관점에서 논리, 로직, 경로** 등을 검증하는 테스트 방법이다.  
정보처리기사 실기에서는 주로 **코드 기반, 구조 중심 테스트**로 출제된다.

#### 🧩 특징
- **구조 기반 테스트**로 단위 및 통합 테스트 단계에서 수행
- **소스 코드와 설계 문서**를 기반으로 테스트 케이스 설계
- **제어 흐름, 조건, 데이터 흐름**에 초점
- 테스트의 완전도는 **커버리지 기준**으로 판단됨

#### 🧩 장점 / 단점

| 장점 | 단점 |
|------|------|
| 초기 결함 발견, 보안 취약점 탐지 유리 | 구현 의존적, 사용자 시나리오 검증 부족 |
| 코드 최적화, 내부 로직 개선 가능 | 코드 변경 시 테스트 유지보수 비용 발생 |

#### 🧩 적용 수준
- **단위 테스트(Unit Testing)**: 모듈 단위의 기능 검증
- **통합 테스트(Integration Testing)**: 모듈 간 인터페이스 및 데이터 흐름 검증
- (일부 경우) 시스템 테스트 수준에서도 내부 로직 기반 검증 수행 가능

#### 📝 시험 출제 예시
- 화이트박스 테스트의 특징은 무엇인가?
- WHB 테스트가 특히 어느 단계에서 수행되는가?
- WHB 테스트의 장단점을 비교 설명하시오

#### 🧠 용어 요약
- **구조 기반**: 내부 코드 구조·제어 흐름 중심 테스트
- **단위 중심**: 함수/모듈 단위로 실행 테스트
- **코드 커버리지**: 테스트 완전도 측정 기준 (문장, 분기 등)

---

## 🔹 207. 화이트박스 테스트의 종류

#### 📘 정의
화이트박스 테스트의 종류는 **코드 구조, 조건, 루프, 데이터 흐름** 등 소스 내부 특성에 따라 다양한 기법들을 활용하여 결함을 탐지하는 테스트 방법들을 의미합니다.

#### 🧩 주요 기법

| 기법명                  | 설명 |
|------------------------|------|
| **기초 경로 검사 (Base Path Testing)** | 프로그램의 제어 흐름 그래프 내 독립 경로를 모두 식별하고 테스트 케이스로 구성 |
| **제어 구조 테스트 (Control Structure Testing)** | 조건문, 반복문, 분기 등의 제어 흐름 요소에 대한 집중 테스트 |
| **데이터 흐름 테스트 (Data Flow Testing)** | 변수 선언, 할당, 사용 등의 흐름 간에 생기는 오류 검증 |
| **조건 테스트 (Condition Testing)** | 복합 조건 내 개별 조건 값의 참/거짓 경우를 모두 테스트 |
| **루프 테스트 (Loop Testing)** | 단일 루프, 중첩 루프, 경계 반복 횟수 등에 따라 다양한 루프 경로 검증 |
| **경로 테스트 (Path Testing)** | 가능한 모든 실행 경로를 따라 테스트 케이스 구성 |
| **예외 처리 테스트** | 예외 발생 조건과 예외 처리 흐름이 올바른지 확인 |

#### 📝 출제 예시
- "기초 경로 검사는 어떤 기준으로 테스트 경로를 선정하는가?"
- "데이터 흐름 테스트는 어떤 오류를 탐지하나요?"
- "루프 테스트는 어떤 상황에서 수행되나요?"

#### 🧠 용어 요약
- **기초 경로 검사**: 제어 흐름 그래프 기준 독립 경로 테스트
- **제어 구조 테스트**: 조건, 분기, 반복문 등 구조 요소 초점 테스트
- **데이터 흐름 테스트**: 변수의 라이프타입에 따른 흐름 오류 검증
- **조건 테스트**: 복합 조건 내 각각의 분기 조건별 검증
- **루프 테스트**: 최대/최소/중첩 반복 패턴에 따른 테스트
- **예외 처리 테스트**: 오류 발생 시 예외 처리 로직이 제대로 실행되는지 확인

---

## 🔹 208. 화이트박스 테스트의 검증 기준 (Coverage Criteria)

#### 📘 정의
화이트박스 테스트의 검증 기준이란, 테스트가 소스 코드의 내부를 **얼마나 철저하게 수행했는지를 정량적으로 평가하는 기준**이며,  
이를 **커버리지(Coverage)**라고 부른다.

#### 🧩 주요 커버리지 종류 (Coverage Types)

| 커버리지 종류 | 영어 명칭 | 설명 |
|---------------|-----------|------|
| 문장 커버리지 | Statement Coverage | 모든 코드 라인이 최소 1회 실행되었는지 확인 |
| 분기 커버리지 | Branch (Decision) Coverage | 모든 조건문의 참/거짓 분기 경로가 실행되었는지 확인 |
| 조건 커버리지 | Condition Coverage | 복합 조건 내 각 조건이 참/거짓 모두 수행되었는지 확인 |
| 조건-결정 커버리지 | Condition-Decision Coverage | 조건 커버리지 + 분기 커버리지 동시 만족 |
| 변경조건/결정 커버리지 | Modified Condition/Decision Coverage (MC/DC) | 각 조건이 결과에 독립적으로 영향 주는지 확인 |
| 다중 조건 커버리지 | Multiple Condition Coverage | 모든 조건 조합을 테스트 (가장 포괄적) |
| 경로 커버리지 | Path Coverage | 가능한 모든 제어 흐름 경로를 테스트 |

#### 🧠 커버리지 계층 구조 (Coverage Inclusion)

- **문장 ⊂ 분기 ⊂ 조건 ⊂ 조건-결정 ⊂ MC/DC ⊂ 다중 조건 ⊂ 경로**

#### 📝 기출 포맷 예시

- “MC/DC란 무엇인가?”
- “문장 커버리지보다 높은 수준의 커버리지는?”
- “모든 조건 조합을 테스트하는 커버리지는 무엇인가?”

#### 🧠 용어 요약

- **Coverage**: 테스트 수행의 범위를 수치로 표현한 기준
- **Statement**: 코드 라인의 실행 여부
- **Branch**: 조건문의 분기(True/False) 처리 여부
- **MC/DC**: 개별 조건이 결과에 영향을 주는지 검증

---

## 🔹 209. 블랙박스 테스트

#### 📘 정의
블랙박스 테스트(Black‑Box Testing)는 소프트웨어의 **내부 구조를 보지 않고**,  
**입력과 출력의 기능적 관계**만을 보고 시스템이 요구사항을 충족하는지를 검증하는 기법입니다.  
정보처리기사 실기에서는 이를 **기능 테스트**라고 지칭하며,  
**명세서 기반 실행 테스트**로 출제됩니다.

#### 🧩 특징
- **외부 관점**: 사용자나 인터페이스 관점에서 요구사항 준수 여부 확인
- **실행 기반**: 실제 입력값을 넣어 결과를 관찰하고 비교
- **비구조 중심**: 내부 코드나 구현 논리는 전혀 참조하지 않음
- **테스트 시점**: 통합 또는 시스템 테스트 단계에서 주로 사용

#### 📝 시험 출제 예시
- “블랙박스 테스트의 정의는 무엇인가?”
- “WHB 테스트와 BBT 테스트의 관점 차이를 설명하라.”
- “블랙박스 테스트는 어느 테스트 단계에서 수행되는가?”

#### 🧠 용어 요약
- **명세 기반**: 요구사항 문서나 설계서에 따라 테스트
- **기능 검증**: 실제 시스템을 실행해 기능 동작 여부 확인
- **사용자 시각**: 내부 구조 대신 입력/출력 흐름 중심 접근

---

## 🔹 210. 블랙박스 테스트의 종류

#### 📘 정의
블랙박스 테스트는 내부 구조를 보지 않고 **입력-출력 기능 중심**으로 시스템이 명세대로 동작하는지 검증하는 테스트 기법입니다.

#### 🧩 핵심 기법

| 기법명            | 영어명                     | 설명 |
|-------------------|----------------------------|------|
| 동등 분할         | Equivalence Partitioning   | 입력 영역을 유효/무효 그룹으로 나눠 대표값만 테스트 |
| 경계값 분석       | Boundary Value Analysis    | 최소/최대 경계 및 인근 값 중심으로 테스트 |
| 결정 테이블       | Decision Table Testing     | 조건-행동 조합을 표로 정리해 모든 조합 검증 |
| 상태 전이         | State Transition Testing   | 상태와 이벤트 흐름에 따라 상태 변화 검증 |
| 원인-효과 그래프  | Cause‑Effect Graphing      | 입력‑출력 관계를 논리 그래프로 시각화하여 테스트 |
| 비교 테스트       | Comparison Testing         | 다른 버전/시스템과 **동일 입력→결과 비교** 검증 |
| 오류 예측         | Error Guessing             | 경험 기반 직관으로 잠재 결함 예상 테스트 |

#### 🧠 정처기 출제 포인트
- 동등 분할 vs 경계값 분석 차이 이해
- 비교 테스트: 다른 시스템과 결과 비교 방식 ([시뮝 연구소](https://simuing.tistory.com/entry/2024-%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC-%EC%8B%A4%EA%B8%B0-%EB%B8%94%EB%9E%99%EB%B0%95%EC%8A%A4-%ED%85%8C%EC%8A%A4%ED%8A%B8?utm_source=chatgpt.com), [Devinus](https://devinus.tistory.com/6?utm_source=chatgpt.com) 등이 비교검사 언급)
- 오류 예측: 경험 기반 결함 검출 방식 강조

#### 📝 시험 예시
- “비교 테스트는 어떤 방식인가?”
- “오류 예측 테스트의 특징은?”
- “경계값 분석과 동등 분할의 차이는?”

#### 🧠 용어 요약
- **Comparison Testing**: 동일 입력을 다른 시스템/버전에서 실행해 결과 비교
- **Error Guessing**: 경험과 직관으로 결함 가능성을 추정하고 테스트 설계

---

## 🔹 211. 개발 단계에 따른 애플리케이션 테스트

#### 📘 정의
소프트웨어 개발 단계에 따라 테스트를 수행하는 방식으로,  
각 단계에서 생성된 산출물(요구사항, 설계 등)을 기준으로  
적절한 수준의 테스트를 대응시켜 소프트웨어 품질을 검증한다.  
정처기 실기에서는 **V-모델**과 함께 자주 출제된다.

#### 🧩 개발 단계와 테스트 단계의 대응 관계 (V-모델 기반)

| 개발 단계      | 대응 테스트 단계              | 설명 |
|------------|-------------------------------|------|
| 요구사항 분석    | 인수 테스트 (Acceptance Test) | 사용자의 요구사항이 모두 반영되었는지 확인 |
| 분석         | 시스템 테스트 (System Test)   | 전체 시스템이 요구 명세대로 동작하는지 검증 |
| 설계 | 통합 테스트 (Integration Test)| 모듈 간 연결과 데이터 흐름의 정확성 확인 |
| 구현 (코딩)    | 단위 테스트 (Unit Test)       | 개별 모듈 내부 로직과 기능의 정확성 검증 |

→ **개발은 위에서 아래로**, **테스트는 아래에서 위로** 진행되며,  
→ **V 형태의 흐름**으로 시각화됨

#### 🧩 테스트 단계 핵심 요약

| 테스트 단계        | 설명 |
|--------------------|------|
| **단위 테스트**       | - 함수, 모듈 등 **최소 단위**의 기능 검증<br>- 내부 로직, 경로, 조건 검사 중심 |
| **통합 테스트**       | - 모듈 간 인터페이스 및 데이터 흐름 확인<br>- 상향식 / 하향식 / 빅뱅 방식 |
| **시스템 테스트**     | - 전체 시스템이 기능·비기능 요구사항 충족 여부 검증 |
| **인수 테스트**       | - 실제 운영 환경에서 사용자 요구사항이 만족되는지 확인<br>- 고객/사용자 중심 테스트 |

#### 📝 기출 포맷 예시
- V-모델에서 시스템 설계에 대응하는 테스트는?
- 다음 중 통합 테스트의 대상에 해당하는 것은?
- 개발 단계와 테스트 단계의 연결로 옳은 것은?

#### 🧠 용어 설명
- **V-모델**: 개발 단계와 테스트 단계가 1:1로 대응되는 구조
- **단위 테스트**: 모듈 단위의 내부 로직 검사
- **통합 테스트**: 모듈 간 연결 및 인터페이스 검증
- **시스템 테스트**: 전체 시스템의 기능성/성능 검증
- **인수 테스트**: 사용자 요구사항 기준 최종 검토

---

## 🔹 212. 단위 테스트 (Unit Test)

#### 📘 정의
단위 테스트는 **소프트웨어의 가장 작은 단위(모듈, 함수, 클래스 등)**를 개발자가 직접 테스트하여  
내부 로직, 인터페이스, 예외 처리 등을 검증하는 테스트 단계입니다.  
주로 구현 직후 수행되며, 결함을 조기에 발견하는 데 목적이 있습니다.

#### 🧩 주요 특징
- **목적**: 기능이 명세대로 동작하는지 확인, 내부 오류 조기 검출
- **수행 주체**: 개발자
- **테스트 범위**: 개별 모듈, 함수, 클래스 수준
- **검증 대상**: 인터페이스, 자료 구조, 조건문, 경로 흐름, 예외 처리
- **테스트 방식**:
    - 화이트박스 테스트(내부 로직 기반)
    - 경우에 따라 블랙박스 테스트(명세 기반)도 병행
- **자동화 도구**: JUnit(Java), pytest(Python), CppUnit(C++) 등
- **테스트 커버리지 측정 가능**: 명령문 커버리지, 분기 커버리지 등

#### 📝 출제 포인트
- **단위 테스트 = 개발자 주도, 모듈 내부 로직 검증**
- 주로 **화이트박스 테스트 기법** 적용됨
- **테스트 자동화 도구** 관련 문제 자주 출제됨
- **커버리지 기준**(라인, 분기 등) 구분 문제 가능

#### 🧠 용어 요약
- **단위 테스트**: 모듈 또는 함수 단위의 코드 검증
- **화이트박스 테스트**: 내부 구조를 기준으로 테스트
- **테스트 커버리지**: 코드 실행 범위를 측정하는 지표
- **테스트 오라클**: 테스트 결과의 정답 여부를 판단하는 기준
- **회귀 테스트**: 수정된 코드가 기존 기능에 영향을 미치지 않는지 확인

---

## 🔹 213. 통합 테스트 (Integration Test)

#### 📘 정의
단위 테스트가 완료된 모듈들을 결합하여 **모듈 간 인터페이스와 데이터 흐름**이 올바른지 검증하는 테스트입니다.  
정보처리기사 실기에서는 **불완전 통합(빅뱅)**과 **점진적 통합(하향식, 상향식, 혼합식)** 방식으로 자주 출제됩니다.

#### 🧩 주요 통합 방식

- **비점진적 통합 - 빅뱅 통합 (Big‑Bang Integration)**  
  모든 모듈을 한꺼번에 결합해 테스트.
    - 장점: 소규모 시스템에 빠르게 적용
    - 단점: 결함 원인 추적 어려움

- **점진적 통합 (Incremental Integration)**  
  모듈을 단계별로 결합하며 테스트
    - **하향식 (Top‑Down)**  
      상위 모듈부터 시작, **스텁(Stub)**으로 하위 모듈 대체  
      제어 흐름 테스트에 유리
    - **상향식 (Bottom‑Up)**  
      하위 모듈부터 결합, **드라이버(Driver)**로 상위 모듈 대체  
      데이터 흐름 테스트에 유리
    - **혼합식 (Sandwich/Hybrid)**  
      상향식과 하향식을 절충하여 동시에 적용

#### 📝 출제 포인트
- 각 통합 방식의 특징 및 장단점 비교
- 스텁/드라이버의 역할 이해
- 빅뱅 통합의 문제점 예시

#### 🧠 용어 요약
- **스텁(Stub)**: 하위 모듈이 준비되지 않았을 때 임시로 사용하는 대체 코드
- **드라이버(Driver)**: 상위 모듈이 없을 때 대체하는 테스트 호출 코드
- **빅뱅**: 모듈 전체 한 번에 결합 테스트
- **하향식**: 상위→하위 순서로 모듈 결합
- **상향식**: 하위→상위 순서로 모듈 결합
- **혼합식**: 두 방식을 동시에 사용

---

## 🔹 214. 시스템 테스트 (System Test)

#### 📘 정의
통합된 전체 시스템이 **기능 및 비기능 요구사항을 충족하는지 확인**하는 테스트입니다.  
실제 운영 환경 또는 이에 준하는 환경에서, 전체 애플리케이션의 동작을 종합적으로 검증합니다.  
정보처리기사 실기에서는 **블랙박스 방식**이 주로 사용되며, **명세 기반 기능 테스트 + 성능/보안 등 비기능 테스트** 구분이 중요합니다.
개발된 소프트웨어가 해당 컴퓨터 시스템에서 완벽하게 수행되는가

#### 🧩 주요 특징
- **대상**: 전체 시스템의 모든 기능 및 비기능 요소
- **목적**:
    - 기능 테스트: 요구사항에 따른 기능 수행 여부
    - 비기능 테스트: 성능, 보안, 안정성, 신뢰성 등 검증
- **테스트 방식**: E2E 관점, 블랙박스 방식
- **실행 환경**: 운영 환경과 유사한 테스트 환경에서 수행
- **수행 주체**: QA팀 또는 독립 테스터

#### 📝 시험 출제 포인트
- 시스템 테스트는 **기능 + 비기능 테스트 모두 포함**
- 성능 테스트 유형: 부하, 스트레스, 내구성 테스트
- **보안 테스트, 신뢰성 테스트**도 포함되어 출제됨
- **통합 테스트와 시스템 테스트의 차이** 이해 필요

#### 🧠 용어 요약
- **시스템 테스트(String Test)**: 전체 시스템이 명세와 일치하는지 검증
- **기능 테스트(Functional Test)**: 기능 요구사항 중심
- **성능 테스트(Performance Test)**: 처리 속도·용량·반응 시간 등 평가
- **보안 테스트(Security Test)**: 인증·접근 통제·취약점 점검
- **신뢰성 테스트(Reliability Test)**: 장애 발생 및 복구 능력 검증

---

## 🔹 215. 인수 테스트 (Acceptance Test)

#### 📘 정의
인수 테스트는 **최종 사용자 또는 고객이 실제 시스템을 운영 환경에서 평가**하는 단계입니다.  
요구사항이 제대로 반영되었고, 실 사용 환경에서 안정적으로 동작하는지를 검증하는 **최종 승인 절차**입니다.

#### 🧩 주요 특징
- **검증 주체**: 최종 사용자, 고객 또는 이해관계자
- **대상**: 완성된 시스템, 실사용 데이터 및 환경
- **목적**:
    - 요구사항 충족 여부 확인
    - 실제 운영 환경에서의 **안정성, 호환성, 사용성** 평가
- **테스트 방식**: 요구사항 기반 명세용 블랙박스 테스트
- **완료 기준**: 사용자 또는 고객의 **체크리스트 기반 승인** 후 시스템 인수

#### 📝 시험 출제 포인트
- 인수 테스트와 시스템 테스트의 차이 설명
- **UAT(User Acceptance Test)**와 연관 개념
- 인수 테스트 합격 기준 및 사후 대응 절차

#### 🧠 용어 요약
- **인수 테스트 (Acceptance Test)**: 고객이 참가해 실제 요구사항 평가
- **UAT(User Acceptance Test)**: 최종 사용자 주도의 인수 테스트
- **인수 승인 기준**: 요구사항 만족, 결함 허용 범위, 사용성 테스트 결과 등  

---

