## 096. 뷰 (View)

- [ ] **하나 이상의 테이블로부터 유도된 가상의 테이블**
- [ ] **실제 데이터 저장하지 않고**, **SELECT문 형태로 정의**
- [ ] **보안성 강화** (민감한 열/행 감춤), **논리적 독립성** 제공
- [ ] **CREATE VIEW 뷰이름 AS SELECT...**로 생성
- [ ] **복잡한 뷰는 삽입/갱신 제한** 있음

---

## 097. 파티션의 종류

- [ ] 대용량 테이블을 **논리적으로 분할**하여 **성능 향상과 관리 효율성** 확보
- [ ] **Range Partition**: 값 **범위**에 따라 분할 (날짜, 숫자)
- [ ] **List Partition**: **명시적 목록**에 따라 분할 (지역코드, 등급)
- [ ] **Hash Partition**: **해시 함수**로 **균등 분할**
- [ ] **Composite Partition**: **2개 이상 방식 결합** (Range+Hash, Range+List)

---

## 098. 분산 데이터베이스의 목표

- [ ] **여러 장소 분산된 DB**를 **하나의 논리적 시스템**처럼 운영
- [ ] **4대 투명성**: 위치, 중복, 병행, 장애 투명성
- [ ] **위치 투명성**: 데이터 **실제 위치 인식 않고** 접근
- [ ] **중복 투명성**: **여러 곳 중복 저장**되어도 **하나처럼 동작**
- [ ] **병행/장애 투명성**: 동시 접근/일부 장애에도 **정상 동작**

---

## 099. RTO / RPO

- [ ] **장애 발생 시 복구 목표**를 수치로 정의한 지표
- [ ] **RTO (Recovery Time Objective)**: **복구 시간 목표** - 언제까지 복구
- [ ] **RPO (Recovery Point Objective)**: **복구 시점 목표** - 얼마 전 시점까지 복구
- [ ] **RTO↓, RPO↓**일수록 요구 성능 높아짐 → 투자 비용 증가
- [ ] **업무 연속성(BCP)**과 **재해 복구(DR)** 계획 수립에 필수

---

## 100. 암호화

- [ ] **평문을 특정 알고리즘과 키**로 **암호문으로 변환**하는 과정
- [ ] **대칭 키**: 암호화/복호화에 **동일한 키** 사용 (속도 빠름, 키 분배 어려움)
- [ ] **비대칭 키**: **공개키/개인키** 각각 사용 (보안성 우수, 속도 느림)
- [ ] **스트림 암호**: 1비트/1바이트 단위 연속 암호화
- [ ] **블록 암호**: 고정 크기 블록 단위 (64/128비트) 암호화

---

## 101. 임의 접근 통제 (DAC)

- [ ] **자원 소유자가 임의로 접근 권한** 부여·제어하는 방식
- [ ] **유연성 높음**, 관리 편리, **권한 전이 가능** → 보안 취약
- [ ] **구현 방식**: 접근 제어 행렬, ACL(Access Control List), Capability List
- [ ] **ACL**: 각 객체별 접근 가능한 주체와 권한 목록
- [ ] 주로 **일반 운영체제 파일 시스템**에서 사용

---

## 102. 강제 접근 통제 (MAC)

- [ ] **보안 정책**에 따라 **시스템이 강제로** 접근 권한 제어
- [ ] **보안 등급 기반** 통제, **자원 소유자가 권한 설정 불가**
- [ ] **읽기**: 주체 등급 ≥ 객체 등급 ("위로 읽기")
- [ ] **쓰기**: 주체 등급 ≤ 객체 등급 ("아래로 쓰기")
- [ ] **군사, 국방, 기밀 시스템**에서 사용, **권한 위임 금지**

---

## 103. 역할기반 접근 통제 (RBAC)

- [ ] **사용자 → 역할 → 권한** 구조로 접근 권한 관리
- [ ] **직무 중심** 권한 관리, **역할 단위**로 일괄 권한 설정
- [ ] **다중 프로그래밍 환경** 최적화, **중앙관리자가 통제**
- [ ] **최소 권한 원칙** 및 **업무 분리 원칙** 구현 가능
- [ ] **DAC와 MAC 단점 보완**, 대규모 시스템에서 **관리 효율성** 높음

---

## 104. DAS (Direct Attached Storage)

- [ ] **서버에 직접 연결**되는 저장 장치 (SCSI, SATA 등)
- [ ] **1:1 구조**, 네트워크 거치지 않음 → **빠른 접근 속도**
- [ ] **블록 단위** 접근, **서버 OS가 파일 시스템** 관리
- [ ] **확장성과 공유성 낮음** (하나의 서버만 접근)
- [ ] 내부 HDD, SSD, 외장 하드, USB 등

---

## 105. NAS (Network Attached Storage)

- [ ] **네트워크 연결** 스토리지, **파일 단위** 저장 및 접근
- [ ] **전용 OS** 내장 → **자체 파일 시스템** 운영
- [ ] **TCP/IP 기반 네트워크**로 연결, **여러 사용자 동시 접근**
- [ ] **공유 드라이브, 파일 백업 서버** 용도
- [ ] **네트워크 기반 파일 저장** 서버

---

## 106. SAN (Storage Area Network)

- [ ] **스토리지 전용 고속 네트워크**, **블록 단위** 데이터 전송
- [ ] **광채널(Fibre Channel), iSCSI** 등 고속 네트워크 사용
- [ ] **서버 OS가 파일 시스템** 관리, 서버에서는 **로컬 디스크처럼** 인식
- [ ] **고비용/고확장/고성능** 특화, 대형 데이터센터에 적합
- [ ] **DAS**(직접연결), **NAS**(파일단위), **SAN**(블록단위/전용네트워크)

---

## 107. 자료 구조의 분류

- [ ] **효율적 데이터 저장, 조직화, 관리** 방법
- [ ] **형태**: 선형 구조(1:1 순차) vs 비선형 구조(1:多, 多:多)
- [ ] **메모리 할당**: 정적 구조(컴파일시 크기 고정) vs 동적 구조(실행시 가변)
- [ ] **저장 방식**: 순차 구조(연속 위치) vs 연결 구조(포인터 연결)
- [ ] **배열**(선형+정적+순차), **연결리스트**(선형+동적+연결), **트리/그래프**(비선형+동적+연결)

---

## 108. 스택 (Stack)

- [ ] **후입선출(LIFO)** 구조의 선형 자료구조
- [ ] **주요 연산**: push(삽입), pop(삭제), peek/top(조회)
- [ ] **한쪽 끝(top)**에서만 삽입/삭제
- [ ] **오버플로우**(가득참+push), **언더플로우**(비어있음+pop)
- [ ] **활용**: 괄호 검사, 수식 계산, 되돌리기, 재귀 호출 처리

---

## 109. 데크 (Deque)

- [ ] **Double-Ended Queue**, **양쪽(앞/뒤) 모두** 삽입/삭제 가능
- [ ] **스택과 큐 기능** 모두 포함한 구조
- [ ] **주요 연산**: addFront, addRear, removeFront, removeRear
- [ ] **입력제한**(한쪽 입력, 양쪽 출력), **출력제한**(양쪽 입력, 한쪽 출력)
- [ ] **양방향 입출력** 지원으로 유연한 처리

---

## 110. 방향 / 무방향 그래프의 최대 간선 수

- [ ] **정점 n개**일 때 연결 가능한 **최대 간선 수** (자기 루프 없음 기준)
- [ ] **무방향 그래프**: n(n-1)/2 (간선 양방향 중복 없음)
- [ ] **방향 그래프**: n(n-1) (A→B, B→A 별도 인정)
- [ ] **자기 루프 허용시**: 각 정점당 +1개씩 추가 (방향 그래프 총 n²)
- [ ] 예: 정점 5개 무방향 → 10개, 정점 4개 방향 → 12개

---

## 111. 트리 (Tree)

- [ ] **사이클 없는 비선형** 자료구조, **계층적 구조**
- [ ] **하나의 루트 노드**에서 시작, **부모-자식 관계**로 연결
- [ ] **N개 노드 = N-1개 간선**, **루프(순환) 없음**
- [ ] **이진 트리**: 최대 2개 자식, **포화**: 모든 레벨 가득, **완전**: 왼쪽부터 채움
- [ ] **편향 트리**: 한쪽 자식만 가지는 구조

---

## 112. 트리 관련 용어

- [ ] **루트 노드**: 최상위 노드, 부모 없음
- [ ] **단말 노드(Leaf)**: 자식 없는 노드
- [ ] **차수(Degree)**: 노드가 가진 자식 수, **트리의 차수**: 가장 큰 노드 차수
- [ ] **레벨**: 루트에서 해당 노드까지 거리 (루트=레벨 1)
- [ ] **높이(Height)**: 트리의 최대 레벨 값

---

## 113. Preorder 순회법 (전위 순회)

- [ ] **루트 → 왼쪽 서브트리 → 오른쪽 서브트리** 순으로 방문
- [ ] **루트를 먼저** 방문하는 순회 방식
- [ ] **재귀적 순회**: 같은 방식으로 하위 트리 반복 순회
- [ ] 예시 A(B(D,E),C(,F)) → **A → B → D → E → C → F**
- [ ] **전위 순회** = 루트 우선 방문

---

## 114. Inorder 순회법 (중위 순회)

- [ ] **왼쪽 서브트리 → 루트 → 오른쪽 서브트리** 순으로 방문
- [ ] **이진 탐색 트리(BST)** 중위 순회 시 **오름차순 정렬** 결과
- [ ] **좌우 자식 사이**에서 루트 방문
- [ ] 예시 A(B(D,E),C(,F)) → **D → B → E → A → C → F**
- [ ] **중위 순회** = 좌우 사이 루트 방문

---

## 115. Postorder 순회법 (후위 순회)

- [ ] **왼쪽 서브트리 → 오른쪽 서브트리 → 루트** 순으로 방문
- [ ] **모든 자식 방문 후** 루트 방문
- [ ] **수식 트리 평가**, **재귀적 구조 처리**에 활용
- [ ] 예시 A(B(D,E),C(,F)) → **D → E → B → F → C → A**
- [ ] **후위 순회** = 자식 후 루트 방문

---

## 116. 중위 → 전위 표기법 변환

- [ ] **Infix**(연산자가 피연산자 사이) → **Prefix**(연산자가 앞)
- [ ] **연산자 우선순위, 괄호 구조** 따라 변환
- [ ] 변환 과정: 괄호 우선 → 곱/나눗셈 → 덧/뺄셈 순서
- [ ] 예: A + B * (C - D) → **+ A * B - C D**
- [ ] **우선순위**: 괄호 > 곱/나눗셈 > 덧/뺄셈

---

## 117. 중위 → 후위 표기법 변환

- [ ] **Infix** → **Postfix**(연산자가 피연산자 뒤)
- [ ] **괄호 없이도** 연산자 우선순위 명확, **컴파일러/계산기**에 사용
- [ ] 연산자가 **피연산자 뒤**로 이동, **괄호는 최종 제거**
- [ ] 예: A + B * (C - D) → **A B C D - * +**
- [ ] **후위 표기** = 피연산자 뒤 연산자

---

## 118. Postfix → Infix 변환

- [ ] **후위 표기식**을 **중위 표기식**으로 변환
- [ ] **스택 활용**: 피연산자 push, 연산자 만나면 2개 pop하여 결합
- [ ] 변환 과정: `(좌 피연산자 연산자 우 피연산자)` 형태로 결합
- [ ] 예: A B C * + → **(A + (B * C))**
- [ ] **괄호 사용**으로 우선순위 보존 필수

---

## 119. 삽입 정렬 (Insertion Sort)

- [ ] **현재 값을 앞의 정렬된 값들과 비교**해 **알맞은 위치에 삽입**
- [ ] **왼쪽부터 오른쪽**으로 순차 진행, **큰 값은 오른쪽으로 밀고** 삽입
- [ ] **시간복잡도**: 최선 O(n), 평균/최악 O(n²)
- [ ] **안정 정렬**, **제자리 정렬**, **거의 정렬된 상태에서 효율적**
- [ ] 카드 정렬처럼 **한 장씩 끼워넣는** 방식

---

## 120. 선택 정렬 (Selection Sort)

- [ ] **전체 중 가장 작은 값 선택**하여 **맨 앞과 교환**
- [ ] 각 회차마다 **최솟값을 선택** → 정렬되지 않은 영역 첫째와 교환
- [ ] **시간복잡도**: 모든 경우 **O(n²)** (비교 횟수 항상 일정)
- [ ] **비안정 정렬**, **제자리 정렬**, **교환 횟수 최소화**
- [ ] **가장 작은 값을 골라** 앞으로 보내는 방식

---

## 121. 버블 정렬 (Bubble Sort)

- [ ] **인접한 두 값 비교**하여 **조건 맞지 않으면 교환**
- [ ] **큰 값이 뒤쪽**으로 이동, **거품이 떠오르듯** 반복 이동
- [ ] **시간복잡도**: 최선 O(n), 평균/최악 O(n²)
- [ ] **안정 정렬**, **제자리 정렬**, **가장 단순**하지만 비효율적
- [ ] **인접 요소 비교**하며 큰 값을 뒤로

---

## 122. 퀵 정렬 (Quick Sort)

- [ ] **기준값(Pivot)** 중심으로 **작은 값 왼쪽, 큰 값 오른쪽** 분할
- [ ] **분할 정복** 알고리즘, **재귀적** 정렬 반복
- [ ] **시간복잡도**: 최선/평균 O(n log n), 최악 O(n²)
- [ ] **비안정 정렬**, **제자리 정렬**, **대규모 데이터** 적합
- [ ] **Pivot 선택**이 성능에 중요한 영향

---

## 123. 힙 정렬 (Heap Sort)

- [ ] **완전이진트리 기반 힙 자료구조** 이용한 정렬
- [ ] **최대/최소값 효율적 추출** 특성 활용
- [ ] 과정: 힙 구성 → 루트(최댓값) 추출 → 재정렬(heapify) 반복
- [ ] **시간복잡도**: 모든 경우 **O(n log n)** 보장
- [ ] **비안정 정렬**, **제자리 정렬**, **최악에도 성능 보장**

---

## 124. 2-WAY 합병 정렬 (Merge Sort)

- [ ] **정렬된 두 리스트를 하나로 합치는 방식** 반복
- [ ] **분할 정복** 원리: **작은 정렬 → 병합** 과정
- [ ] 과정: 1개 단위 분할 → 인접 두 리스트 정렬 병합 → 반복
- [ ] **시간복잡도**: 모든 경우 **O(n log n)**
- [ ] **안정 정렬**, **추가 메모리 필요**, **대용량 외부 정렬** 효과적