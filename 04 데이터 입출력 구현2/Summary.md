### 096. 뷰 (View)

#### 📘 정의
**뷰(View)**는 **하나 이상의 테이블로부터 유도된 가상의 테이블**로,  
**실제 데이터를 저장하지 않고 SELECT문 형태로 정의**된다.  
→ **사용자에게 필요한 데이터만 보여주는 논리적 구조**로, 보안과 편의성 향상에 사용된다.

#### 🧩 주요 특징

- **실제 데이터를 저장하지 않음** (가상 테이블)
- **테이블처럼 SELECT, JOIN 가능**
- **보안성 강화**: 민감한 열/행을 감춤
- **논리적 독립성 제공**: 원본 테이블 변경에도 영향 최소화
- **읽기 전용 뷰**는 삽입/갱신 불가 (복잡한 뷰는 제한 있음)

#### 🧩 문법 예시

```sql
-- 뷰 생성
CREATE VIEW 뷰이름 AS
SELECT 열1, 열2 FROM 테이블명
WHERE 조건;

-- 뷰 사용
SELECT * FROM 뷰이름;

-- 뷰 삭제
DROP VIEW 뷰이름;
```

#### 🧩 예시

```sql
-- 학생 테이블에서 학번, 이름만 보여주는 뷰
CREATE VIEW student_view AS
SELECT 학번, 이름
FROM 학생
WHERE 학년 = 4;
```

#### 📝 기출 포맷 예시

- 뷰(View)의 특징으로 옳지 않은 것은?
- 뷰를 정의할 때 사용하는 SQL 명령어는?
- 뷰를 사용하는 목적으로 적절하지 않은 것은?

#### 🧠 용어 설명

- **뷰(View)**: SELECT문으로 정의된 가상의 테이블
- **기본 테이블(Base Table)**: 뷰가 참조하는 실제 테이블
- **논리적 독립성**: 원본 테이블 변경이 뷰 사용자에게 영향을 주지 않음
- **읽기 전용 뷰**: 복잡하거나 조인을 포함해 DML이 불가능한 뷰

---

### 097. 파티션의 종류

#### 📘 정의
**파티션(Partition)**은 대용량 테이블 또는 인덱스를 **논리적으로 분할하여 관리**할 수 있도록 하는 기능이다.  
→ 데이터를 **조건에 따라 나누어 저장**함으로써 **성능 향상과 관리 효율성**을 얻을 수 있다.

#### 🧩 파티션의 종류

| 구분                                    | 설명 |
|---------------------------------------|------|
| **Range Partition (범위 분할)**           | 특정 컬럼의 **값 범위**에 따라 파티션 분할 (예: 날짜, 숫자) |
| **List Partition (목록 분할)**            | 컬럼 값의 **명시적 목록**에 따라 분할 (예: 지역 코드, 등급 등) |
| **Hash Partition (해시 분할)**            | 해시 함수를 사용해 **균등하게 분할**, 데이터 분포가 일정치 않을 때 사용 |
| **Composite Partition (조합 or 복합 분할)** | **2개 이상의 방식**을 결합 (보통 Range + Hash 또는 Range + List) |

#### 🧩 특징 요약

- 파티션은 **물리적 분산 없이 논리적 분할**만 수행
- 파티션별 **데이터 독립 처리 가능** → 질의 성능 개선
- 주로 **대용량 테이블**에서 사용
- **파티션 키**는 WHERE 절 조건 최적화에 기여

#### 🧩 예시

- `Range`: 날짜 기준 → 2023년, 2024년, 2025년 테이블 분리
- `List`: 지역코드 기준 → 서울, 경기, 부산
- `Hash`: 사용자 ID를 해시로 균등 분산
- `Composite`: 연도(Range) + 지역(List) 복합 분할

#### 📝 기출 포맷 예시

- 파티션 기법 중 **해시 분할의 특징**으로 옳은 것은?
- 다음 중 **목록 분할 방식(List Partitioning)**에 해당하는 예시는?
- **복합 파티션(Composite Partition)**의 설명으로 적절한 것은?

#### 🧠 용어 설명

- **파티션(Partition)**: 논리적으로 데이터를 나눠 저장하는 기술
- **Range Partition**: 범위 기준 분할 (예: 날짜, 연도 등)
- **List Partition**: 목록 기준 분할 (명시적 값 그룹)
- **Hash Partition**: 해시 함수로 분할, 균등 분포 목적
- **Composite Partition**: 두 가지 방식 이상을 결합한 분할 방법

---

### 098. 분산 데이터베이스의 목표

#### 📘 정의
**분산 데이터베이스(Distributed Database)**는 **여러 장소에 분산된 데이터베이스를 하나의 논리적 시스템처럼 운영**할 수 있도록 하는 시스템이다.  
→ 데이터가 물리적으로 분산되어 있어도, **사용자에게는 하나의 통합된 DB처럼 동작**한다.

#### 🧩 분산 데이터베이스의 4대 목표 (4대 투명성)

| 투명성 | 설명 |
|--------|------|
| **위치 투명성 (Location Transparency)** | 사용자가 **데이터의 실제 위치를 인식하지 않고** 접근 가능 |
| **중복 투명성 (Replication Transparency)** | **데이터가 여러 곳에 중복 저장**되어도 **하나처럼 보이고 동작** |
| **병행 투명성 (Concurrency Transparency)** | 여러 사용자가 동시에 접근해도 **정상적으로 일관성 있게 처리** |
| **장애 투명성 (Failure Transparency)** | 일부 시스템에 **장애가 발생해도 전체 DB가 정상 동작**처럼 보이도록 처리 |

#### 🧩 특징 요약

- **데이터 분산 저장 + 논리적 통합 사용**
- 사용자 입장에서 **하나의 DB처럼 사용**
- **분산 투명성 보장**이 핵심 목표
- 시스템 확장성과 지역 분산 처리 가능

#### 🧩 예시

- 위치 투명성: 사용자가 데이터가 서울에 있든 부산에 있든 관계없이 사용
- 중복 투명성: 동일한 고객 정보가 여러 노드에 있어도 일관되게 조회됨
- 병행 투명성: 다수 사용자 동시 주문 → 충돌 없이 처리
- 장애 투명성: 한 서버 장애 → 다른 노드에서 자동 처리

#### 📝 기출 포맷 예시

- 다음 중 **분산 데이터베이스의 주요 목표**가 아닌 것은?
- **중복 투명성(Replication Transparency)**의 설명으로 적절한 것은?
- **위치 투명성**의 의미로 알맞은 것은?

#### 🧠 용어 설명

- **분산 DB**: 물리적으로 분산, 논리적으로 통합된 데이터베이스 시스템
- **위치 투명성**: 실제 저장 장소와 무관한 접근 가능
- **중복 투명성**: 여러 사본 존재 시에도 하나처럼 보이도록 함
- **병행 투명성**: 동시 작업에도 일관된 처리 보장
- **장애 투명성**: 장애 발생 시 대체 경로 처리

---

### 099. RTO / RPO

#### 📘 정의
RTO와 RPO는 **장애 발생 시 정보 시스템의 복구 목표를 수치로 정의**한 지표로,  
**업무 연속성(BCP)과 재해 복구(DR)** 계획 수립에 필수적으로 사용된다.

- **RTO (Recovery Time Objective)**: **복구 시간 목표**  
  → 시스템이 **장애 발생 후 언제까지 복구되어야 하는지**를 나타냄
- **RPO (Recovery Point Objective)**: **복구 시점 목표**  
  → 장애 발생 시 **데이터를 얼마 전 시점까지 복구해야 하는지**를 나타냄

#### 🧩 비교 표

| 항목 | RTO | RPO |
|------|-----|-----|
| 정의 | 복구 완료까지의 목표 시간 | 복구 가능한 데이터 손실 허용 범위 |
| 의미 | 서비스 재개까지 걸리는 시간 | 데이터 복구 가능한 마지막 시점 |
| 단위 | 시간 (분, 시간 등) | 시간 (초, 분, 시간 등) |
| 예시 | “4시간 이내 복구” | “5분 전까지의 데이터는 복구해야 함” |

#### 🧩 특징 요약

- **RTO↓, RPO↓일수록** 복구 성능 요구가 높아짐 → 투자 비용 증가
- **RTO = 0** : 무중단 서비스 지향
- **RPO = 0** : 데이터 손실 없는 복구 (실시간 복제)

#### 🧩 예시 상황

- RTO 2시간: 장애 발생 후 2시간 안에 시스템 복구되어야 함
- RPO 10분: 최근 10분간의 데이터는 유실될 수 있음

#### 📝 기출 포맷 예시

- 다음 중 **RTO에 대한 설명**으로 옳은 것은?
- **장애 발생 직전 시점까지의 데이터 복구**를 의미하는 용어는?
- **RTO와 RPO의 차이**로 적절한 설명은?

#### 🧠 용어 설명

- **RTO (복구 시간 목표)**: 장애 발생 후, 복구까지 걸리는 최대 허용 시간
- **RPO (복구 시점 목표)**: 장애 발생 시 복구 가능한 데이터의 최대 손실 허용 시점
- **BCP (Business Continuity Planning)**: 비즈니스 연속성 계획
- **DR (Disaster Recovery)**: 재해 복구 계획

---

### 100. 암호화

#### 📘 정의
**암호화(Encryption)**는 평문(원본 데이터)을 **특정 알고리즘과 키를 사용해 암호문으로 변환**하는 과정이다.  
→ **데이터 기밀성 확보**를 목적으로 하며, 인가되지 않은 사용자의 접근을 방지하는 대표적 보호 기법이다.

#### 🔄 암호화 과정

1. **평문 입력**: 원래 데이터
2. **암호화 알고리즘 + 키 사용**: 암호문 생성
3. **암호문 출력 및 전송/저장**
4. **수신자 복호화**: 암호문 + 키 사용 → 평문 복원

#### 🔄 복호화
**복호화(Decryption)**는 암호문을 **키와 알고리즘을 통해** 다시 **평문으로 되돌리는 과정**이다.

#### 🧩 암호화 기법 분류

| 구분 | 방식 | 설명 |
|------|------|------|
| **키 기반** | **대칭 키 방식** | 암호화와 복호화에 **동일한 키** 사용<br>속도 빠르나 키 분배 어려움 |
|  | **비대칭 키 방식** | **공개키/개인키**를 각각 사용하여 암·복호화<br>보안성 우수, 속도 느림 |
| **단위 기반** | **스트림 암호** | 1비트 또는 1바이트 단위로 연속적으로 암호화<br>실시간 통신에 적절 |
|  | **블록 암호** | 고정 크기의 블록 단위(예: 64·128비트)로 암호화<br>구조적 보안성 높음 |

#### 🧩 주요 비교

| 항목 | 대칭 키 방식 | 비대칭 키 방식 |
|------|--------------|----------------|
| 키 종류 | 단일 키 | 공개키 + 개인키 |
| 처리 속도 | 매우 빠름 | 느림 |
| 보안성 | 중간 (키 유출 위험) | 높음 |
| 대표 알고리즘 | AES, DES, 3DES | RSA, ECC, DSA |

#### 📌 용어 설명

- **평문(Plaintext)**: 암호화 전 원본 데이터
- **암호문(Ciphertext)**: 암호화된 데이터
- **키(Key)**: 암호화·복호화에 필요한 비밀 값
- **암호화 알고리즘**: 데이터를 암호화·복호화 하는 수학적 절차
- **전자서명(Digital Signature)**: 비대칭키로 생성한 서명, 위·변조 검증 목적

#### 📝 기출 포맷 예시

- 다음 중 **복호화(Decryption)** 과정에 대한 설명으로 옳은 것은?
- **대칭 키 방식**과 **비대칭 키 방식**의 차이점은?
- **스트림 암호**의 특징에 대한 설명으로 적절하지 않은 것은?

#### 🧠 핵심 요약

- **암호화** = 평문 → 암호문, **복호화** = 암호문 → 평문
- **대칭 암호**: 속도 ↑, 키 관리 ↓
- **비대칭 암호**: 보안 ↑, 속도 ↓
- **스트림 vs 블록 암호**: 단위 처리 방식에 따라 용도 구분

---

### 101. 임의 접근 통제 (DAC: Discretionary Access Control)

#### 📘 정의
**임의 접근 통제(DAC)**는 **자원 소유자가 임의로 접근 권한을 부여·제어**할 수 있는 방식이다.  
→ **사용자 또는 소유자가 파일/자원에 대한 접근 권한을 설정**하며, 유연성이 크지만 보안성이 낮을 수 있다.

#### 🧩 주요 개념

- **주체(Subject)**: 자원에 접근하려는 사용자 또는 프로세스
- **객체(Object)**: 보호 대상 자원 (예: 파일, 디렉터리, DB 등)
- **접근 권한**: 읽기(Read), 쓰기(Write), 실행(Execute) 등

#### 🧩 접근 제어 구현 방식

| 방식 | 설명 |
|------|------|
| **접근 제어 행렬 (Access Control Matrix)** | 주체-객체-권한을 2차원 행렬로 표현 |
| **ACL (Access Control List)** | 각 객체에 대해 접근 가능한 주체와 권한 목록을 저장 |
| **Capability List** | 주체가 접근 가능한 객체 목록과 권한을 저장 |

#### 🧩 특징 요약

- **자원 소유자가 권한을 직접 관리**
- **유연성 높음**, 관리 편리
- **권한 전이 가능** → 보안에 취약
- 주로 **일반 운영체제 파일 시스템**에서 사용됨

#### 📝 기출 포맷 예시

- 다음 중 **임의 접근 통제(DAC)**의 특징으로 옳은 것은?
- DAC에서 **접근 제어를 수행하는 주체**는 누구인가?
- **접근 제어 행렬/ACL**과 관련된 설명으로 적절한 것은?

#### 🧠 용어 설명

- **임의 접근 통제(DAC)**: 자원 소유자가 접근 권한을 지정
- **ACL (Access Control List)**: 객체 기준 접근 통제 목록
- **Capability List**: 주체 기준 접근 통제 목록
- **접근 제어 행렬**: 주체-객체-권한 관계를 행렬로 표현

---

### 102. 강제 접근 통제 (MAC: Mandatory Access Control)

#### 📘 정의
**강제 접근 통제(MAC)**는 **보안 정책에 따라 시스템이 강제로 접근 권한을 제어**하는 방식이다.  
→ 자원 소유자의 의사와 관계없이, **시스템 관리자 또는 정책이 정의한 등급 기준에 따라 접근 여부가 결정**된다.
-> 객체별로 보안 등급 부여 가능

#### 🧩 주요 개념

- **보안 등급(Sensitivity Level)**: 주체와 객체에 부여되는 보안 등급 (예: 일급비밀, 비밀, 일반 등)
- **비가변 정책**: 사용자가 권한을 변경하거나 위임할 수 없음
- **주체(Subject)**: 사용자 또는 프로세스
- **객체(Object)**: 파일, DB 등 보호 대상 자원

#### 🧩 접근 정책 원칙

| 정책 | 설명 |
|------|------|
| **읽기 허용 조건** | 주체의 보안 등급 ≥ 객체의 등급 ("위로 읽기") |
| **쓰기 허용 조건** | 주체의 보안 등급 ≤ 객체의 등급 ("아래로 쓰기") |

→ **읽기: 같거나 높은 등급만 읽기 가능**  
→ **쓰기: 같거나 낮은 등급만 쓰기 가능**

#### 🧩 특징 요약

- **보안 등급 기반 통제**
- **자원 소유자가 권한 설정 불가**
- **권한 위임 금지 (비가변성)**
- **군사, 국방, 기밀 시스템 등에서 사용**

#### 📝 기출 포맷 예시

- 다음 중 **강제 접근 통제(MAC)**의 특징으로 옳은 것은?
- MAC에서 **사용자가 직접 권한을 설정할 수 없는 이유**는?
- “위로 읽기, 아래로 쓰기”가 의미하는 것은?

#### 🧠 용어 설명

- **강제 접근 통제(MAC)**: 보안 정책에 따라 자동 제어되는 통제 방식
- **보안 등급**: 자원 및 사용자의 보안 수준 표시
- **비가변 정책**: 사용자가 권한을 변경하거나 위임할 수 없음
- **위로 읽기 / 아래로 쓰기**: MAC 정책의 기본 원칙

---

### 103. 역할기반 접근 통제 (RBAC: Role-Based Access Control)

#### 📘 정의
**역할기반 접근 통제(RBAC)**는 **사용자에게 직접 권한을 부여하지 않고**,  
**사용자 → 역할 → 권한**의 구조로 접근 권한을 관리하는 방식이다.  
→ 대규모 시스템에서 **권한 관리 효율성과 보안성**을 동시에 높이기 위해 사용됨.
-> 임의 접근통제와 강제 접근통제 단점 보완. 다중 프로그래밍 환경 최적화, 중앙관리자가 통제

#### 🧩 구성 요소

| 요소 | 설명 |
|------|------|
| **사용자(User)** | 시스템을 사용하는 주체 |
| **역할(Role)** | 직무 또는 책임 단위 (예: 관리자, 회계팀, 개발자 등) |
| **권한(Permission)** | 객체에 대한 접근 권한 (읽기, 쓰기 등) |
| **세션(Session)** | 사용자-역할 간의 실행 중 연결 관계 |

#### 🧩 역할 매핑 구조

- **사용자 ↔ 역할**: 사용자는 하나 이상의 역할을 가질 수 있음
- **역할 ↔ 권한**: 역할은 하나 이상의 권한을 포함함
- ⇒ **사용자 → 역할 → 권한** 경로를 따라 접근 통제 수행

#### 🧩 특징 요약

- **직무 중심의 권한 관리**
- **역할 단위로 일괄 권한 설정 가능**
- 사용자 수가 많아도 **관리 효율성 높음**
- **최소 권한 원칙** 및 **업무 분리 원칙** 구현 가능

#### 📝 기출 포맷 예시

- 다음 중 **RBAC의 특징**으로 옳지 않은 것은?
- 역할기반 접근 통제에서 **권한 부여 과정의 올바른 순서**는?
- **최소 권한 원칙 구현이 가능한 접근 통제 방식**은?

#### 🧠 용어 설명

- **RBAC**: 역할을 매개로 사용자에게 권한을 부여하는 방식
- **역할(Role)**: 특정 직무 또는 책임 단위
- **최소 권한 원칙**: 업무 수행에 필요한 최소한의 권한만 부여
- **업무 분리 원칙**: 특정 사용자에게 모든 권한이 집중되지 않도록 제한

---

### 104. DAS (Direct Attached Storage)

#### 📘 정의
**DAS (직접 연결 스토리지)**는 **서버나 컴퓨터에 직접 연결되는 저장 장치**를 말한다.  
→ **스토리지와 서버가 1:1 구조로 연결**되며, 네트워크를 거치지 않음.

#### 🧩 주요 특징

- **서버에 직접 연결** (SCSI, SATA 등)
- 네트워크를 통하지 않음 → **빠른 접근 속도**
- **확장성과 공유성 낮음** → 하나의 서버만 접근 가능
- **파일 시스템은 서버 OS가 관리**

#### 🧩 DAS 사용 예시

- 내부 HDD, SSD, 외장 하드, USB 등
- 서버 내부에 물리적으로 장착된 디스크

#### 🧩 DAS 중심 비교 요약

- **구성**: 서버 ↔ DAS (직접 연결)
- **접근 방식**: 블록 단위
- **운영 체계**: 서버 OS가 파일 시스템 직접 관리
- **용도**: 단일 서버, 소규모 환경에 적합

#### 📝 기출 포맷 예시

- 다음 중 **DAS의 특징**으로 옳지 않은 것은?
- DAS는 **어떤 방식으로 연결**되는 저장장치인가?
- DAS는 **어떤 단위로 데이터 접근**을 수행하는가?

#### 🧠 용어 설명

- **DAS**: 서버에 직접 연결된 스토리지 (Direct Attached Storage)
- **블록 스토리지**: 운영체제가 직접 블록 단위로 접근하는 저장 구조
- **파일 시스템**: 데이터를 논리적으로 구조화하여 저장/관리하는 방식 (예: NTFS, ext4)

---

### 105. NAS (Network Attached Storage)

#### 📘 정의
**NAS (네트워크 연결 스토리지)**는 **파일 단위 저장 장치로, 전용 OS가 탑재된 파일 서버를 네트워크를 통해 제공**하는 스토리지다.  
→ 사용자는 마치 공유 폴더처럼 접근하며, 파일 단위로 데이터를 주고받는다.

#### 🧩 주요 특징

- **TCP/IP 기반 네트워크로 연결**
- **파일 단위 저장 및 접근** (File Level)
- **전용 OS(리눅스 기반 등)** 내장 → 자체 파일 시스템 운영
- **여러 사용자가 동시에 접근 가능** (공유 스토리지)

#### 🧩 NAS 사용 예시

- 사무실 내부의 **공유 드라이브**
- 가정용/기업용 **파일 백업 서버**

#### 🧩 NAS 중심 비교 요약

- **구성**: NAS 장비 ↔ 네트워크 ↔ 사용자
- **접근 방식**: 파일 단위
- **운영 체계**: NAS 전용 OS가 파일 시스템 관리
- **용도**: 파일 공유, 백업, 멀티미디어 저장 등

#### 📝 기출 포맷 예시

- 다음 중 **NAS의 특징**으로 옳지 않은 것은?
- NAS는 데이터를 어떤 **단위로 저장/전송**하는가?
- NAS는 **파일 시스템을 어디서 관리**하는가?

#### 🧠 용어 설명

- **NAS**: 네트워크 기반 파일 저장 서버 (Network Attached Storage)
- **파일 스토리지**: 사용자 입장에서 파일 단위로 접근하는 저장 방식
- **전용 OS**: NAS 장비 내부에 설치된 운영 체제 (파일 시스템 관리 목적)

---

### 106. SAN (Storage Area Network)

#### 📘 정의
**SAN (스토리지 전용 네트워크)**는 **스토리지와 서버 간에 고속 전용 네트워크를 구성해, 블록 단위로 데이터를 전송하는 저장 장치 시스템**이다.  
→ 대규모 시스템에서 고성능, 고확장성을 제공하는 **전문 스토리지 네트워크** 구조다.

#### 🧩 주요 특징

- **광채널(Fibre Channel), iSCSI 등 고속 네트워크 사용**
- **블록 단위 접근** → DAS와 유사하지만 **물리적으로 분리됨**
- **스토리지 장비는 독립적으로 구성**, 서버에서는 로컬 디스크처럼 인식
- **고비용 / 고확장 / 고성능** 특화

#### 🧩 SAN 사용 예시

- 대형 데이터센터, 금융기관, 기업용 고성능 백업 시스템

#### 🧩 SAN 중심 비교 요약

- **구성**: 서버 ↔ SAN 스토리지 (전용 네트워크)
- **접근 방식**: 블록 단위
- **운영 체계**: 서버 OS가 파일 시스템 관리
- **용도**: 고성능 트랜잭션 처리, 대용량 스토리지

---

### 📊 DAS / NAS / SAN 비교

| 항목 | DAS | NAS | SAN |
|------|-----|-----|-----|
| **접속 방식** | 직접 연결 | 네트워크 (LAN) | 전용 네트워크 (FC, iSCSI 등) |
| **접근 단위** | 블록 단위 | 파일 단위 | 블록 단위 |
| **파일 시스템 관리 주체** | 서버 OS | NAS 장비 자체 OS | 서버 OS |
| **공유성** | 낮음 | 높음 | 높음 |
| **속도** | 빠름 | 중간 | 매우 빠름 |
| **용도** | 단일 서버 | 파일 공유, 백업 | 고성능, 대용량 처리 |
| **비용/확장성** | 저비용 / 제한적 | 중간 / 적당 | 고비용 / 고확장 |

---

#### 📝 기출 포맷 예시

- 다음 중 **SAN의 특징**으로 옳지 않은 것은?
- **파일 시스템을 자체적으로 운영**하지 않는 스토리지는?
- **DAS / NAS / SAN 비교**에서 적절하지 않은 항목은?

#### 🧠 용어 설명

- **SAN**: 스토리지 전용 고속 네트워크 (Storage Area Network)
- **블록 스토리지**: 운영체제가 블록 단위로 직접 제어하는 방식
- **Fibre Channel / iSCSI**: SAN 구성 시 사용하는 전용 프로토콜
- **스토리지 네트워크**: 서버와 저장장치를 연결하는 별도 네트워크

---

### 107. 자료 구조의 분류

#### 📘 정의
**자료 구조(Data Structure)**는 데이터를 **효율적으로 저장, 조직화, 관리하는 방법**을 의미한다.  
→ 프로그램에서 **데이터의 삽입, 삭제, 탐색, 수정** 등의 연산을 효율적으로 수행하기 위한 **데이터 저장 및 조직 방식**

#### 🧩 핵심 개념 요약

**분류 기준 3가지**
1. **형태에 따른 분류**: 선형 구조 vs 비선형 구조
2. **메모리 할당 방식**: 정적 구조 vs 동적 구조
3. **저장 방식**: 순차 구조 vs 연결 구조

#### 🧩 도식 / 비교표

| 분류 기준 | 유형 | 특징 | 대표 자료구조 |
|-----------|------|------|---------------|
| **형태** | **선형 구조** | 데이터가 **1:1 순차적 연결** | 배열, 스택, 큐, 연결리스트 |
|  | **비선형 구조** | 데이터가 **1:多 또는 多:多 연결** | 트리, 그래프 |
| **메모리 할당** | **정적 구조** | 컴파일 시 **크기 고정**, 실행 중 변경 불가 | 배열 |
|  | **동적 구조** | 실행 시 **크기 가변**, 필요에 따라 할당/해제 | 연결리스트, 트리, 그래프 |
| **저장 방식** | **순차 구조** | 메모리상 **연속된 위치**에 저장 | 배열 |
|  | **연결 구조** | **포인터(링크)**로 연결된 불연속 저장 | 연결리스트, 트리, 그래프 |

**자료구조별 특성 조합**
- **배열**: 선형 + 정적 + 순차
- **연결리스트**: 선형 + 동적 + 연결
- **스택/큐**: 선형 + (배열 또는 연결리스트로 구현 가능)
- **트리**: 비선형 + 동적 + 연결
- **그래프**: 비선형 + 동적 + 연결

#### 📝 기출 포맷 예시
- 다음 중 **비선형 자료구조**에 해당하는 것은?
- **정적 자료구조**의 특징으로 옳은 것은?
- **선형 자료구조**와 **비선형 자료구조**의 차이점을 설명하시오.
- 연결리스트는 어떤 **저장 방식 및 메모리 할당 방식**을 사용하는가?

#### 🧠 용어 설명
- **선형 구조**: 데이터 요소들이 **순차적으로 나열**되어 **첫 번째와 마지막 요소를 제외하고 모든 요소가 하나의 선행자와 하나의 후행자**를 가지는 구조
- **비선형 구조**: 하나의 데이터 요소가 **여러 개의 다른 데이터 요소와 연결**될 수 있는 구조 (계층적, 망형)
- **정적 구조**: **컴파일 시간에 메모리 크기가 결정**되어 프로그램 실행 중 변경할 수 없는 구조
- **동적 구조**: **프로그램 실행 중에 필요에 따라 메모리를 할당하거나 해제**할 수 있는 구조
- **순차 구조**: 데이터들이 **메모리상에 연속적으로 저장**되는 구조 (물리적 순서 = 논리적 순서)
- **연결 구조**: **포인터나 링크를 이용하여 데이터들을 연결**한 구조 (물리적 순서 ≠ 논리적 순서)

---

### 108. 스택 (Stack)

#### 📘 정의
**스택(Stack)**은 **후입선출(LIFO: Last In, First Out)** 구조를 가지는 선형 자료구조이다.  
→ **나중에 들어온 데이터가 먼저 처리**된다.

#### 🧩 주요 연산

| 연산 | 설명 |
|------|------|
| **push** | 스택의 맨 위에 데이터 삽입 |
| **pop** | 스택의 맨 위 데이터를 제거 및 반환 |
| **peek(top)** | 삭제 없이 맨 위 데이터 조회 (읽기만 함)

#### 🧩 예외 조건

- **오버플로우(Overflow)**: 스택이 가득 찬 상태에서 push 시도
- **언더플로우(Underflow)**: 스택이 비어있는데 pop 시도

#### 🧩 특징 요약

- **LIFO 구조**
- **한쪽 끝(top)**에서만 삽입/삭제
- **배열 또는 연결 리스트**로 구현 가능 (시험엔 개념만 필요)

#### 🧩 활용 예시

- 괄호 검사, 수식 계산 (후위표기식), 되돌리기(Undo), 웹 브라우저 뒤로 가기, 재귀 호출 처리

#### 📝 기출 포맷 예시

- 다음 중 **스택의 특징**으로 옳지 않은 것은?
- **스택 언더플로우**는 어떤 경우에 발생하는가?
- **LIFO 구조**를 갖는 자료구조는?

#### 🧠 용어 설명

- **LIFO**: 나중에 들어간 데이터가 먼저 나오는 구조
- **push/pop/peek**: 삽입 / 삭제 / 조회 연산
- **오버플로우/언더플로우**: 삽입·삭제 예외 상황

---

### 109. 데크 (Deque: Double-Ended Queue)

#### 📘 정의
**데크(Deque)**는 **양쪽(앞/뒤) 모두에서 삽입과 삭제가 가능한 선형 자료구조**이다.  
→ **스택과 큐의 기능을 모두 포함**한 구조로, 유연한 입출력이 가능하다.
-> 입력이 한쪽에서만 발생하고 출력은 양쪽에서 일어날 수 있는 입력제한과, 입력은 양쪽에서 일어나고 출력은 한 곳에서만 이루어지는 출력 제한이 있다.

#### 🧩 주요 연산

| 연산 | 설명 |
|------|------|
| **addFront** | 전단(앞)에 데이터 삽입 |
| **addRear** | 후단(뒤)에 데이터 삽입 |
| **removeFront** | 전단에서 데이터 삭제 |
| **removeRear** | 후단에서 데이터 삭제 |

#### 🧩 특징 요약

- **양방향 입출력 지원 (스택 + 큐)**
- 삽입/삭제가 **전단·후단 모두에서 가능**
- **원형 큐 또는 연결 리스트 기반**으로 구현 가능
- **스택/큐보다 유연하지만, 정처기 실기에서는 구조 파악 중심**

#### 🧩 덱 vs 큐 vs 스택 비교

| 자료구조 | 삽입/삭제 위치 | 구조적 특징 |
|----------|----------------|--------------|
| **스택** | 후단(Top)만 | LIFO |
| **큐** | 전단 삭제 / 후단 삽입 | FIFO |
| **데크** | 전단/후단 모두 | 양방향 입출력 지원 |

#### 📝 기출 포맷 예시

- 다음 중 **데크의 특징**으로 옳지 않은 것은?
- **데크는 어떤 자료구조의 장점을 동시에 갖는가?**
- **후단과 전단 모두 삽입/삭제가 가능한 구조**는?

#### 🧠 용어 설명

- **Deque**: Double-Ended Queue의 약자
- **전단(Front)** / **후단(Rear)**: 삽입/삭제가 가능한 양쪽 끝
- **양방향 큐**: 앞뒤 모두 입출력 가능한 큐 구조

### 110. 방향 / 무방향 그래프의 최대 간선 수

#### 📘 정의
그래프에서 **정점(Vertex)의 개수 n**에 따라 연결할 수 있는 **최대 간선 수**는  
**방향 그래프**와 **무방향 그래프**에서 서로 다르며, **중복·자기 루프 여부**에 따라 수식이 달라진다.

---

#### 🧩 최대 간선 수 공식 (자기 루프 없음 기준)

| 그래프 종류 | 최대 간선 수 (정점 n개) | 설명 |
|-------------|---------------------------|------|
| **무방향 그래프** | n(n - 1) / 2 | 간선은 양방향 중복 없음 |
| **방향 그래프** | n(n - 1) | 간선은 방향 구분 → A→B, B→A 별도 인정 |

→ **자기 루프 허용 시**, 각 정점당 1개씩 추가 가능  
 → 무방향: +n / 방향: +n → 총 n² (방향 그래프 기준)

---

#### 🧩 예시

- 정점이 5개인 무방향 그래프  
 → 최대 간선 수: 5×(5−1)/2 = **10**

- 정점이 4개인 방향 그래프  
 → 최대 간선 수: 4×(4−1) = **12**

---

#### 📝 기출 포맷 예시

- 정점 6개인 **무방향 그래프**의 최대 간선 수는?
- **방향 그래프**의 최대 간선 수 공식은?
- 자기 루프를 포함할 경우 **방향 그래프 최대 간선 수**는?

#### 🧠 용어 설명

- **무방향 그래프**: 간선에 방향 없음, A–B와 B–A 동일
- **방향 그래프**: 간선에 방향 있음, A→B ≠ B→A
- **정점(Vertex)**: 그래프에서의 노드
- **간선(Edge)**: 정점을 잇는 선
- **자기 루프(Self-loop)**: 자기 자신을 가리키는 간선

---

### 111. 트리 (Tree)

#### 📘 정의
**트리(Tree)**는 **사이클이 없는 비선형 자료구조**로,  
**하나의 루트 노드에서 시작하여 자식 노드로 분기되는 계층적 구조**를 갖는다.  
→ 노드 간 관계가 **1:N 구조(부모 → 자식)**로 이루어지며, **루프(순환)**이 없다.

---

#### 🧩 트리 구조의 특징

- **계층적 구조** (Hierarchical)
- **최상위 루트 노드(Root) 존재**, 단 하나
- **부모-자식 관계**로 연결
- **사이클 없음 (비순환성)**
- **N개의 노드는 항상 N-1개의 간선**

---

#### 🧩 트리 종류 (시험 출제 기준)

| 종류 | 설명 |
|------|------|
| **이진 트리** | 모든 노드가 최대 2개의 자식 노드를 가짐 |
| **포화 이진 트리** | 모든 레벨에 노드가 가득 찬 이진 트리 |
| **완전 이진 트리** | 마지막 레벨을 제외하고 노드가 꽉 차 있으며, 왼쪽부터 채워진 트리 |
| **편향 트리** | 모든 노드가 한쪽 자식만 가지는 트리 (왼쪽 또는 오른쪽만) |

---

#### 📝 기출 포맷 예시

- 다음 중 **트리의 특징**으로 옳지 않은 것은?
- **N개의 노드를 가진 트리**의 간선 개수는?
- 트리는 왜 **사이클이 없는 구조**인가?

#### 🧠 용어 설명 (※ 용어 세부 정리는 112번에서 별도 정리)

- **트리(Tree)**: 계층적, 비순환, 1:N 관계 자료구조
- **루트 노드(Root Node)**: 트리의 최상위 노드
- **사이클 없음**: 반복 연결 구조가 없음 (유향 비순환 그래프)

---

### 112. 트리 관련 용어 (시험 핵심만)

#### 📘 정의
트리 구조에서 **정보처리기사 실기 시험에 출제되는 핵심 용어만** 정리한 내용이다.

---

#### 🧩 필수 용어 정리

| 용어 | 설명 |
|------|------|
| **루트 노드(Root Node)** | 트리의 최상위 노드, 부모가 없음 |
| **단말 노드(Leaf Node)** | 자식이 없는 노드 (말단 노드) |
| **서브트리(Subtree)** | 어떤 노드를 루트로 하는 부분 트리 |
| **차수(Degree)** | 노드가 가진 자식 노드 수 |
| **트리의 차수** | 트리 전체에서 가장 큰 노드 차수 |
| **레벨(Level)** | 루트에서 해당 노드까지의 거리 (루트는 레벨 1) |
| **높이(Height)** | 트리의 최대 레벨 값, 루트 → 가장 먼 단말 노드 거리

---

#### 📝 기출 포맷 예시

- 다음 중 **단말 노드의 정의**로 옳은 것은?
- 트리에서 **루트 노드의 레벨**은 몇인가?
- 트리의 **높이와 차수의 차이**를 설명하시오

#### 🧠 핵심 요약

- 루트는 최상위 노드, 단말은 자식이 없음
- 차수 = 자식 수 / 높이 = 깊이
- 서브트리는 언제든 노드를 기준으로 잘라서 구성

---

### 113. Preorder 순회법 (전위 순회)

#### 📘 정의
**Preorder(전위) 순회**는 **트리 순회 방식 중 하나**로,  
**루트 → 왼쪽 서브트리 → 오른쪽 서브트리** 순으로 방문하는 방식이다.

---

#### 🧩 방문 순서 규칙

1. **루트 방문**
2. **왼쪽 자식(서브트리) 재귀적으로 방문**
3. **오른쪽 자식(서브트리) 재귀적으로 방문**

---

#### 🧩 예시 트리 구조

```
      A
     / \
    B   C
   / \   \
  D   E   F
```

- **Preorder 방문 순서**:  
  `A → B → D → E → C → F`

---

#### 📝 기출 포맷 예시

- 다음 트리의 **Preorder 순회 결과**로 옳은 것은?
- **Preorder 순회 방식의 방문 순서**는?

#### 🧠 용어 설명

- **Preorder 순회**: 루트를 먼저 방문하는 순회 방식
- **전위 순회**: 루트 → 왼쪽 → 오른쪽
- **재귀적 순회**: 같은 방식으로 하위 트리 반복 순회

---

### 114. Inorder 순회법 (중위 순회)

#### 📘 정의
**Inorder(중위) 순회**는 **트리 순회 방식 중 하나**로,  
**왼쪽 서브트리 → 루트 → 오른쪽 서브트리** 순으로 노드를 방문하는 방식이다.  
→ 이진 탐색 트리(BST)에서는 **Inorder 순회 시 오름차순 정렬된 결과**가 나온다.

---

#### 🧩 방문 순서 규칙

1. **왼쪽 자식(서브트리) 재귀적으로 방문**
2. **루트 노드 방문**
3. **오른쪽 자식(서브트리) 재귀적으로 방문**

---

#### 🧩 예시 트리 구조

```
      A
     / \
    B   C
   / \   \
  D   E   F
```

- **Inorder 방문 순서**:  
  `D → B → E → A → C → F`

---

#### 📝 기출 포맷 예시

- 다음 트리의 **Inorder 순회 결과**로 옳은 것은?
- **이진 탐색 트리를 중위 순회**할 경우 어떤 결과가 나오는가?

#### 🧠 용어 설명

- **Inorder 순회**: 왼쪽 → 루트 → 오른쪽 순서
- **중위 순회**: 노드의 좌우 자식 사이에서 루트를 방문
- **BST 오름차순 순회**: Inorder 순회를 통해 정렬된 데이터 획득

---

### 115. Postorder 순회법 (후위 순회)

#### 📘 정의
**Postorder(후위) 순회**는 **트리 순회 방식 중 하나**로,  
**왼쪽 서브트리 → 오른쪽 서브트리 → 루트** 순으로 노드를 방문하는 방식이다.  
→ 컴파일러의 **식 계산**, **수식 트리 평가**, **재귀적 구조 처리** 등에 활용된다.

---

#### 🧩 방문 순서 규칙

1. **왼쪽 자식(서브트리) 재귀적으로 방문**
2. **오른쪽 자식(서브트리) 재귀적으로 방문**
3. **루트 노드 방문**

---

#### 🧩 예시 트리 구조

```
      A
     / \
    B   C
   / \   \
  D   E   F
```

- **Postorder 방문 순서**:  
  `D → E → B → F → C → A`

---

#### 📝 기출 포맷 예시

- 다음 트리의 **Postorder 순회 결과**로 옳은 것은?
- 후위 순회를 사용할 때 **루트 노드는 언제 방문**되는가?

#### 🧠 용어 설명

- **Postorder 순회**: 왼쪽 → 오른쪽 → 루트
- **후위 순회**: 모든 자식을 방문한 후 루트 방문
- **수식 트리 평가**: 후위 순회를 통해 연산 수행

---

### 116. 중위 → 전위 표기법 변환 (Infix → Prefix)

#### 📘 정의
중위 표기식(Infix)은 연산자가 피연산자 사이에 위치하며,  
전위 표기식(Prefix)은 연산자가 피연산자 앞에 위치하는 수식 표현 방식이다.  
→ 연산자 우선순위, 괄호 구조에 따라 변환 순서 결정

---

#### 🧩 전위 변환 단계 예시

예시 수식: `A + B * (C - D)`

| 단계 | 설명 | 표현식 |
|------|------|--------|
| ① | 중위 수식 입력 | `A + B * (C - D)` |
| ② | 괄호 우선 처리 | `A + B * (- C D)` |
| ③ | 곱셈 처리 | `A + (* B - C D)` |
| ④ | 덧셈 처리 | `+ A * B - C D` |
| ✅ | **최종 전위 표기식** | `+ A * B - C D` |

---

#### 📝 기출 포맷 예시

- `A + B * (C - D)`의 전위 표현은?
- 전위 표기식의 특징 중 틀린 것은?

#### 🧠 용어 설명

- **Infix**: 연산자가 피연산자 사이 (`A + B`)
- **Prefix**: 연산자가 앞에 위치 (`+ A B`)
- **우선순위 고려**: 괄호 제거 시 순서 유지

---

### 117. 중위 → 후위 표기법 변환 (Infix → Postfix)

#### 📘 정의
**중위 표기식(Infix)**은 연산자가 피연산자 사이에 위치한 일반적 수식 형태이고,  
**후위 표기식(Postfix)**은 연산자가 피연산자 **뒤에 위치**하는 표기법이다.  
→ 괄호 없이도 연산자 우선순위가 명확하여 컴파일러, 계산기 등에 많이 사용됨

---

#### 🧩 변환 원칙 요약

- **연산자 우선순위**에 따라 연산 순서를 재배치
- 괄호는 연산자 우선순위 판단용으로만 사용되며 **최종 수식에는 제거**
- 연산자가 **피연산자 뒤**로 이동

---

#### 🧩 주요 연산자 우선순위

1. 괄호 `()`
2. 곱셈 / 나눗셈 `* /`
3. 덧셈 / 뺄셈 `+ -`

---

#### 🧩 후위 변환 단계 예시

예시 수식: `A + B * (C - D)`

| 단계 | 설명 | 표현식 |
|------|------|--------|
| ① | 중위 수식 입력 | `A + B * (C - D)` |
| ② | 괄호 우선 처리 | `A + B * (C D -)` |
| ③ | 곱셈 우선 처리 | `A + B C D - *` |
| ④ | 덧셈 처리 | `A B C D - * +` |
| ✅ | **최종 후위 표기식** | `A B C D - * +` |

---

#### 🧠 용어 설명

- **Infix**: 피연산자 사이에 연산자 (`A + B`)
- **Postfix**: 피연산자 뒤에 연산자 (`A B +`)
- **연산자 우선순위**: 괄호 > 곱/나눗셈 > 덧/뺄셈
- **괄호 제거**: 후위 표기에서는 괄호 없이도 연산 순서 보장

---

#### 📝 기출 포맷 예시

- 중위 수식 `A + B * (C - D)`의 후위 표현은?
- 후위 표기식의 **특징 또는 장점**으로 옳은 것은?
- 후위 표기법의 **우선순위 처리 방식**은?

---

### 118. Postfix로 표기된 수식을 Infix로 바꾸기

#### 📘 정의
**후위 표기식(Postfix)**은 연산자가 피연산자 뒤에 위치하는 형태로,  
이를 사람이 읽기 쉬운 **중위 표기식(Infix)**으로 변환하려면  
**연산자 우선순위와 괄호를 고려한 재구성**이 필요하다.

→ 보통 **스택(Stack)**을 활용해 순차적으로 변환한다.

---

#### 🧩 변환 방식 (스택 기반)

1. 수식을 **왼쪽부터 오른쪽으로** 읽는다.
2. **피연산자**를 만나면 스택에 push한다.
3. **연산자**를 만나면 스택에서 피연산자 2개를 pop하고,  
   `"(좌 피연산자 연산자 우 피연산자)"` 형태로 결합하여 다시 push
4. 최종적으로 스택에 남은 하나의 요소가 Infix 수식이다.

---

#### 🧩 단계별 예시

Postfix 수식: `A B C * +`

| 단계 | 입력 기호 | 스택 상태 | 설명 |
|------|------------|----------------|------|
| ① | `A` | `A` | 피연산자 push |
| ② | `B` | `A B` | 피연산자 push |
| ③ | `C` | `A B C` | 피연산자 push |
| ④ | `*` | `A (B * C)` | B, C pop → `(B * C)` push |
| ⑤ | `+` | `(A + (B * C))` | A, (B * C) pop → 결합 후 push |

✅ 최종 Infix 수식: `(A + (B * C))`

※ 괄호는 **연산 순서 보장을 위해 반드시 포함**

---

#### 🧠 용어 설명

- **Postfix(후위)**: 연산자가 피연산자 뒤 (`A B +`)
- **Infix(중위)**: 연산자가 피연산자 사이 (`A + B`)
- **우선순위 보존**: 곱셈·나눗셈이 덧셈보다 우선
- **괄호 사용**: 우선순위가 변경되지 않도록 괄호로 그룹화
- **스택**: 후위 → 중위, 후위 계산 등에 활용되는 자료구조

---

#### 📝 기출 포맷 예시

- 후위 표기식 `A B C * +`를 중위 표기식으로 바르게 변환한 것은?
- 후위 표기식에서 중위 표기식으로 변환할 때 사용되는 자료구조는?
- 후위 표기식의 연산자 우선순위가 Infix에서 어떻게 처리되는가?

