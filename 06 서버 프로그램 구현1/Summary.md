## 🔹 134. 소프트웨어 아키텍처

#### 📘 정의
소프트웨어 아키텍처(Software Architecture)란,
**소프트웨어 시스템을 구성하는 요소들과 이들 간의 관계를 체계적으로 설계한 고수준 구조 또는 구조체**를 의미한다.  
**전체 시스템 구조, 구성 요소 간의 인터페이스 및 상호작용 방식**, 그리고 **비기능 요구사항(성능, 보안 등)**을 만족시키는 것이 목적이다.

#### 🧩 주요 목적
- **시스템 구조의 명확화** 및 설계 품질 향상
- **재사용성, 확장성, 유지보수성 확보**
- **비기능 요구사항 충족** (성능, 보안, 신뢰성 등)
- 개발자 간 **효율적인 의사소통 기반 제공**

#### 🧩 주요 구성 요소

| 구성 요소 | 설명 |
|------------|------|
| **컴포넌트(Component)** | 시스템 기능을 수행하는 단위 모듈 |
| **커넥터(Connector)** | 컴포넌트 간 데이터 또는 제어 흐름을 전달하는 통신 수단 |

#### 🧩 주요 아키텍처 스타일

| 스타일 | 설명 |
|--------|------|
| **계층형(Layered)** | 기능을 계층으로 분리하여 독립성과 재사용성 향상 |
| **클라이언트-서버(Client-Server)** | 서비스 제공자와 요청자 간 구조 |
| **MVC (Model-View-Controller)** | 데이터, UI, 로직을 분리하여 유지보수성 강화 |
| **마이크로서비스(MSA)** | 작고 독립적인 단위 서비스를 조합해 시스템 구성 |

#### 📝 기출 포맷 예시
- 소프트웨어 아키텍처의 **구성 요소가 아닌 것**은?
- 아키텍처 스타일에 대한 **설명으로 옳지 않은 것**은?
- 소프트웨어 아키텍처의 **주요 목적**으로 옳은 것은?

#### 🧠 용어 설명
- **소프트웨어 아키텍처**: 시스템의 구조와 요소 간 관계를 정의하는 설계
- **컴포넌트**: 독립된 기능을 수행하는 소프트웨어 단위
- **커넥터**: 컴포넌트 간 통신 및 제어 전달 수단
- **MVC**: 모델, 뷰, 컨트롤러로 역할을 분리한 구조
- **MSA**: 마이크로 단위로 서비스화한 분산 시스템 구조

---

## 🔹 135. 모듈화 (Modularity)

#### 📘 정의
모듈화(Modularity)란, **소프트웨어를 독립된 기능 단위(모듈)로 분할하여 개발하는 설계 원칙**이다.  
각 모듈은 **하나의 기능만 수행**하며, 다른 모듈과 **최소한의 연결성(Coupling)**만 가지도록 구성한다.  
모듈화의 궁극적 목적은 **응집도(Cohesion)는 높이고, 결합도(Coupling)는 낮추는 것**이다.

#### 🧩 모듈화의 장점

- **개발 생산성 향상**: 모듈 단위 개발로 병렬 작업 가능
- **유지보수 용이성**: 결함 수정 및 기능 개선 시 영향 범위 축소
- **재사용성 향상**: 독립된 모듈을 다른 시스템에서 재활용 가능
- **이식성 증가**: 모듈 단위로 플랫폼 간 이식 용이

#### 🧩 모듈화의 핵심 원리

| 원리 | 설명 |
|------|------|
| **고응집도 (High Cohesion)** | 하나의 모듈이 **하나의 목적**에 집중하도록 구성 |
| **저결합도 (Low Coupling)** | 모듈 간 **의존성을 최소화**하여 독립성 확보 |

> ✅ 실제 시험에서는 응집도와 결합도의 정의 및 비교가 자주 출제됨

#### 📝 기출 포맷 예시

- 다음 중 **모듈화의 장점**이 아닌 것은?
- **응집도와 결합도**에 대한 설명으로 옳은 것은?
- 소프트웨어 개발 시 **모듈화가 필요한 이유**로 가장 적절한 것은?

#### 🧠 용어 설명

- **모듈화(Modularity)**: 소프트웨어를 독립된 기능 단위로 나누는 설계 방식
- **모듈(Module)**: 하나의 기능을 담당하는 독립적 구성 단위
- **응집도(Cohesion)**: 모듈 내부 구성 요소 간의 관련성
- **결합도(Coupling)**: 모듈 간의 상호 의존성

---

## 🔹 136. 추상화 (Abstraction)

#### 📘 정의
추상화(Abstraction)란, **복잡한 시스템에서 핵심적인 정보만을 표현하고, 불필요한 세부 사항은 감추는 설계 기법**이다.  
소프트웨어를 구성할 때 중요한 요소만을 중심으로 **단순화된 모델**을 구성하여 **이해도, 재사용성, 유지보수성**을 향상시킨다.
-> 전체적이고 포괄적인 개념 설계 후 세분화 하여 구체화 시키는 것
#### 🧩 추상화의 유형 (정보처리기사 시험 기준)

| 유형 | 설명 | 예시 |
|------|------|------|
| **자료 추상화** | 데이터의 핵심 속성만 공개하고, 불필요한 세부 정보는 은닉 | 고객 객체에서 이름, 연락처만 제공하고 주민번호는 숨김 |
| **제어 추상화** | 제어 흐름의 구체적인 동작을 감추고, 전체 흐름만 제공 | 반복문, 조건문, 함수 호출로 내부 제어 흐름 캡슐화 |
| **과정 추상화** | 일련의 처리 과정을 하나의 절차 단위로 캡슐화 | '로그인 처리' 기능으로 여러 내부 절차를 묶어 제공 |

#### 🧩 추상화의 효과

- **복잡도 감소**: 핵심 개념 중심으로 시스템 이해 용이
- **유지보수성 향상**: 내부 구현 변경 시 외부 영향 최소화
- **재사용성 향상**: 공통된 개념 중심으로 범용 기능 분리

#### 📝 기출 포맷 예시

- 다음 중 **소프트웨어 추상화의 유형**으로 옳지 않은 것은?
- **과정/제어/자료 추상화**에 대한 설명으로 적절하지 않은 것은?
- 추상화 적용 예시로 **옳은 것 또는 틀린 것**은?

#### 🧠 용어 설명

- **추상화**: 핵심 개념만 표현하고 나머지는 감추는 설계 원리
- **자료 추상화**: 필요한 데이터 속성만 외부에 공개
- **제어 추상화**: 조건, 반복 등 제어 흐름을 단순화
- **과정 추상화**: 여러 처리 단계를 하나의 절차로 묶음

---

## 🔹 137. 단계적 분해 (Stepwise Refinement)

#### 📘 정의
단계적 분해란, **복잡한 문제를 상위 수준에서 시작해 점차 세부 수준으로 나누어 설계하는 기법**이다.  
즉, 전체 시스템을 기능 단위로 나누고, 이를 다시 더 작고 구체적인 하위 기능들로 분해하여 **계층적 구조로 설계**한다.
-> Niklaus Wirth에 의해 제안. 알고리즘, 자료 구조 등은 뒤로 미루어 진행
#### 🧩 단계적 분해의 목적

- **복잡도 감소**: 큰 문제를 작게 나누어 이해 용이
- **구조적 설계 기반** 마련: 각 단계별 책임과 기능이 명확
- **유지보수성 및 확장성 향상**: 모듈 단위로 수정 가능
- **재사용성 향상**: 공통 기능을 별도로 설계해 여러 곳에 활용 가능

#### 🧩 단계적 분해 vs 추상화 비교

| 구분 | 단계적 분해 | 추상화 |
|------|--------------|--------|
| 방향 | **상위 → 하위 단계로 세분화** | **세부 정보 → 핵심 정보로 단순화** |
| 목적 | 문제를 나누어 해결 | 중요한 것만 강조하여 복잡도 감소 |
| 적용 방식 | 설계 시 기능을 분할 | 인터페이스 또는 정보 구조 단순화 |

> ✅ 시험에서는 둘의 차이점을 묻는 문제가 자주 출제됨

#### 📝 기출 포맷 예시

- 다음 중 **단계적 분해의 개념 또는 효과**로 옳지 않은 것은?
- 추상화와 단계적 분해의 **차이점**으로 적절한 설명은?
- **단계적 분해 기법 적용 사례**로 알맞은 것은?

#### 🧠 용어 설명

- **단계적 분해(Stepwise Refinement)**: 시스템을 상위 수준에서 점진적으로 구체화하여 설계하는 기법
- **구조적 설계**: 체계적이고 계층적인 방식으로 소프트웨어를 설계하는 접근
- **기능 분할**: 하나의 기능을 하위 기능으로 나누는 작업

---

## 🔹 137. 단계적 분해 (Stepwise Refinement)

#### 📘 정의
단계적 분해란, **복잡한 문제를 상위 수준에서 시작해 점차 세부 수준으로 나누어 설계하는 기법**이다.  
즉, 전체 시스템을 기능 단위로 나누고, 이를 다시 더 작고 구체적인 하위 기능들로 분해하여 **계층적 구조로 설계**한다.

#### 🧩 단계적 분해의 목적

- **복잡도 감소**: 큰 문제를 작게 나누어 이해 용이
- **구조적 설계 기반** 마련: 각 단계별 책임과 기능이 명확
- **유지보수성 및 확장성 향상**: 모듈 단위로 수정 가능
- **재사용성 향상**: 공통 기능을 별도로 설계해 여러 곳에 활용 가능

#### 🧩 단계적 분해 vs 추상화 비교

| 구분 | 단계적 분해 | 추상화 |
|------|--------------|--------|
| 방향 | **상위 → 하위 단계로 세분화** | **세부 정보 → 핵심 정보로 단순화** |
| 목적 | 문제를 나누어 해결 | 중요한 것만 강조하여 복잡도 감소 |
| 적용 방식 | 설계 시 기능을 분할 | 인터페이스 또는 정보 구조 단순화 |

> ✅ 시험에서는 둘의 차이점을 묻는 문제가 자주 출제됨

#### 📝 기출 포맷 예시

- 다음 중 **단계적 분해의 개념 또는 효과**로 옳지 않은 것은?
- 추상화와 단계적 분해의 **차이점**으로 적절한 설명은?
- **단계적 분해 기법 적용 사례**로 알맞은 것은?

#### 🧠 용어 설명

- **단계적 분해(Stepwise Refinement)**: 시스템을 상위 수준에서 점진적으로 구체화하여 설계하는 기법
- **구조적 설계**: 체계적이고 계층적인 방식으로 소프트웨어를 설계하는 접근
- **기능 분할**: 하나의 기능을 하위 기능으로 나누는 작업

---

## 🔹 139. 협약에 의한 설계 (Design by Contract)

#### 📘 정의
협약에 의한 설계(Design by Contract, DBC)란, **모듈 간의 상호 작용에서 지켜야 할 규칙을 '계약'으로 명시하여 소프트웨어를 설계하는 방식**이다.  
각 모듈은 계약 조건에 따라 자신이 만족시켜야 할 요구사항을 책임지며, 이로써 **모듈 간 신뢰성과 안정성**을 확보할 수 있다.  
계약은 **선행 조건, 결과 조건, 불변 조건**의 세 가지로 구성된다.

#### 🧩 계약 조건의 구성 요소

| 계약 요소 | 설명 |
|-----------|------|
| **선행 조건 (Precondition)** | 모듈 또는 연산이 실행되기 전에 반드시 참이어야 하는 조건 |
| **결과 조건 (Postcondition)** | 모듈 또는 연산 실행 후 반드시 만족해야 하는 조건 |
| **불변 조건 (Invariant)** | 모듈 실행 전후 또는 전체 실행 과정 동안 항상 유지되어야 하는 조건 |

#### 🧩 협약에 의한 설계의 효과

- **모듈 간 책임 분담 명확화**
- **인터페이스 안정성 향상**
- **예외 상황 방지 및 오류 감소**
- **사양 기반 테스트 및 명세 문서화 용이**

#### 📝 기출 포맷 예시

- 다음 중 **협약에 의한 설계의 구성 요소**가 아닌 것은?
- **선행 조건, 결과 조건, 불변 조건**의 의미로 적절하지 않은 것은?
- 협약 기반 설계의 **효과로 옳은 것**은?

#### 🧠 용어 설명

- **협약에 의한 설계 (Design by Contract)**: 조건 기반 계약을 통해 안정적 소프트웨어 동작을 보장하는 설계 기법
- **선행 조건 (Precondition)**: 연산 수행 전에 반드시 만족해야 하는 조건
- **결과 조건 (Postcondition)**: 연산 수행 후 반드시 충족되어야 하는 조건
- **불변 조건 (Invariant)**: 시스템 상태가 변하지 않고 항상 유지되어야 하는 조건

---

## 🔹 140. 아키텍처 패턴 (Architecture Pattern)

#### 📘 정의
아키텍처 패턴이란, **소프트웨어 시스템 설계 시 반복적으로 사용되는 구조적 설계 해결 방식**이다.  
전체 시스템을 구성할 때 **모듈 간 배치, 책임 분담, 데이터 흐름 구조** 등을 정의하여, **효율적인 구조와 품질 확보**를 가능하게 한다.

#### 🧩 주요 아키텍처 패턴

| 패턴 | 설명 |
|------|------|
| **계층형 패턴 (Layered Pattern)** | 기능을 계층으로 분리하여 구성 (UI → 비즈니스 로직 → 데이터 접근) |
| **클라이언트-서버 패턴 (Client-Server Pattern)** | 서비스 요청자(클라이언트)와 제공자(서버)로 나눔 |
| **MVC 패턴 (Model-View-Controller)** | 데이터(Model), UI(View), 제어(Controller)를 분리 |
| **마이크로서비스 패턴 (Microservice Architecture, MSA)** | 서비스 단위를 독립적으로 배포 가능한 작은 단위로 분할 |
| **파이프-필터 패턴 (Pipe and Filter)** | 처리 과정을 필터 단위로 분리하고 파이프로 연결하여 순차 처리 |

> ✅ 시험에서는 위 패턴의 구조적 특징 또는 장단점을 묻는 문제가 자주 출제됨

#### 🧩 패턴 적용 시 장점

- **구조적 일관성 확보**
- **모듈화, 재사용성, 유지보수성 향상**
- **품질 속성(성능, 보안 등) 충족 유도**
- **시스템 확장성 및 관리 용이성 증가**

#### 📝 기출 포맷 예시

- 다음 중 **아키텍처 패턴**에 해당하지 않는 것은?
- **MVC 패턴의 구성 요소**로 옳지 않은 것은?
- **마이크로서비스 아키텍처의 특징**으로 알맞은 것은?

#### 🧠 용어 설명

- **아키텍처 패턴**: 구조적 설계 문제 해결을 위한 재사용 가능한 설계 구조
- **계층형 패턴**: 각 계층 간 역할 분리 및 독립성 확보
- **MVC**: 데이터, UI, 제어 로직을 분리하여 유지보수성 향상
- **MSA**: 서비스 단위를 분리하여 독립 배포 및 운영 가능
- **파이프-필터**: 데이터를 연속적 처리 단계로 나누어 구성

---

## 🔹 141. 레이어 패턴 (Layered Pattern)

#### 📘 정의
레이어 패턴(Layered Pattern)은 **기능별로 시스템을 계층(레이어) 구조로 분리하여 구성하는 아키텍처 설계 방식**이다.  
각 계층은 **명확한 역할과 책임을 가지며**, **하위 계층의 서비스만을 이용**하도록 설계된다.  
→ 대표적인 예: **프리젠테이션 계층, 비즈니스 계층, 데이터 접근 계층**

#### 🧩 레이어 구조 예시

| 계층 | 역할 |
|------|------|
| **프리젠테이션 계층** | 사용자 인터페이스 처리 (UI, 화면 등) |
| **비즈니스 계층** | 애플리케이션의 핵심 로직 처리 |
| **데이터 접근 계층 (DAO)** | DB, 파일 등 데이터 저장소에 접근 및 처리 |

> ✅ 시험에서는 "다음 중 레이어 패턴의 구성 계층이 아닌 것" 또는 "비즈니스 계층의 역할은?" 형식으로 출제됨

#### 🧩 레이어 패턴의 특징

- **역할별 책임 분리**로 설계 명확화
- **모듈화 향상** → 유지보수 용이
- **하위 계층 독립적 설계** 가능
- **테스트 및 디버깅 효율 향상**

#### 🧩 장점 vs 단점

| 항목 | 내용 |
|------|------|
| **장점** | 구조 명확, 재사용성 향상, 계층 간 독립성 |
| **단점** | 계층이 많아지면 **성능 저하**, 복잡도 증가 가능 |

#### 📝 기출 포맷 예시

- 다음 중 **레이어 패턴의 계층 구조에 포함되지 않는 것**은?
- **비즈니스 계층의 역할**로 옳지 않은 것은?
- 레이어 패턴 적용의 **장점 또는 단점**에 대한 설명으로 옳은 것은?

#### 🧠 용어 설명

- **레이어 패턴**: 시스템을 계층화하여 기능을 분리하고 각 계층 간 역할을 명확히 하는 설계 방식
- **프리젠테이션 계층**: 사용자와 상호작용하는 화면/UI 처리 담당
- **비즈니스 계층**: 업무 규칙과 처리 로직을 수행
- **데이터 접근 계층**: DB나 외부 저장소와의 연동 처리 담당

---

## 🔹 142. 클라이언트-서버 패턴 (Client-Server Pattern)

#### 📘 정의
클라이언트-서버 패턴은 **서비스를 요청하는 클라이언트와, 요청을 처리하는 서버를 명확히 분리하여 구성하는 아키텍처 설계 방식**이다.  
시스템을 **요청자(클라이언트)**와 **응답자(서버)** 구조로 나누어, 각자의 역할에 따라 독립적으로 관리할 수 있도록 한다.

#### 🧩 구조 구성

| 구성 요소 | 역할 |
|-----------|------|
| **클라이언트(Client)** | 사용자 인터페이스 제공, 서버에 서비스 요청 전송 |
| **서버(Server)** | 요청 처리 및 결과 반환, 데이터 저장 및 관리 담당 |

> ✅ 시험에서는 구성 요소 역할, 특징 비교가 빈출

#### 🧩 특징

- **역할 분리**: 클라이언트와 서버 간 기능 명확히 구분
- **중앙 집중 처리 구조**: 서버가 로직·데이터 처리 중심
- **다수 클라이언트 지원 가능**
- **보안, 확장성, 유지보수 용이**

#### 🧩 장단점 비교

| 항목 | 장점 | 단점 |
|------|------|------|
| **클라이언트-서버 패턴** | 처리 분산, 관리 용이, 보안 적용 용이 | 서버 과부하 시 성능 저하 발생 가능 |

#### 📝 기출 포맷 예시

- 다음 중 **클라이언트-서버 패턴의 특징**으로 옳지 않은 것은?
- **서버의 역할**로 적절하지 않은 것은?
- 클라이언트-서버 구조의 **장단점 비교 설명 중 옳은 것**은?

#### 🧠 용어 설명

- **클라이언트-서버 패턴**: 요청-응답 구조로 시스템을 분리한 아키텍처 설계
- **클라이언트**: 사용자 요청을 생성하여 서버로 전송하는 주체
- **서버**: 클라이언트 요청을 받아 처리하고 응답을 반환하는 시스템

---

## 🔹 143. 파이프-필터 패턴 (Pipe and Filter Pattern)

#### 📘 정의
파이프-필터 패턴은 **데이터 처리 과정을 여러 단계(필터)로 분할하고, 각 단계를 파이프를 통해 연결하여 순차적으로 처리하는 아키텍처 설계 방식**이다.  
각 필터는 **독립된 데이터 처리 기능을 수행**하며, 파이프는 **데이터 흐름 경로**를 담당한다.

#### 🧩 구조 구성

| 구성 요소 | 역할 |
|-----------|------|
| **필터(Filter)** | 입력 데이터를 가공하여 출력 데이터를 생성 (처리 단위) |
| **파이프(Pipe)** | 필터 간 데이터 전달 통로 (데이터 흐름 연결) |

> ✅ 시험에서는 "필터의 역할은?", "파이프-필터 구조 설명 중 틀린 것" 형태로 자주 출제됨

#### 🧩 특징

- **단계별 처리 분리** → 유지보수 용이
- **필터의 독립성 확보** → 재사용성 향상
- **처리 파이프라인 구성 용이**
- **병렬 처리 가능성 존재**

#### 🧩 대표 활용 예시

- **UNIX Shell 명령어 파이프라인**: `cat file.txt | grep "error" | sort`
- **멀티미디어 데이터 처리 시스템**
- **컴파일러의 전처리기 → 파서 → 코드 생성기 등**

#### 📝 기출 포맷 예시

- 파이프-필터 패턴의 **구성 요소**로 옳지 않은 것은?
- 필터와 파이프의 **역할 설명** 중 적절한 것은?
- 파이프-필터 패턴의 **적용 장점**이 아닌 것은?

#### 🧠 용어 설명

- **파이프-필터 패턴**: 처리 단계를 나누고, 각 단계를 직렬로 연결하는 구조
- **필터(Filter)**: 입력을 받아 가공하고 출력하는 독립 모듈
- **파이프(Pipe)**: 필터 간 데이터 흐름을 연결하는 경로

---

## 🔹 144. 모델-뷰-컨트롤러 패턴 (MVC 패턴)

#### 📘 정의
MVC 패턴은 **사용자 인터페이스(UI)와 비즈니스 로직, 데이터 처리를 분리**하여 설계하는 아키텍처 패턴이다.  
**모델(Model), 뷰(View), 컨트롤러(Controller)**의 세 구성 요소로 나뉘며, **유지보수성과 확장성**을 향상시키는 데 목적이 있다.

#### 🧩 구성 요소 및 역할

| 구성 요소 | 역할 |
|------------|------|
| **모델(Model)** | 데이터 처리 및 비즈니스 로직 담당 |
| **뷰(View)** | 사용자 인터페이스 출력 및 화면 구성 |
| **컨트롤러(Controller)** | 사용자 입력을 해석하고 처리 흐름 제어 (모델/뷰 연결 역할) |

> ✅ 시험에서는 각 요소의 역할 설명, MVC 구조 흐름 문제가 자주 출제됨

#### 🧩 특징

- **역할 분리**를 통해 변경 영향 최소화
- **유지보수성 향상**: 화면/UI 변경 시 비즈니스 로직 영향 없음
- **테스트 용이성 향상**
- **컴포넌트 재사용 가능성 증가**

#### 🧩 데이터 흐름 예시
```
사용자 입력 → [Controller] → [Model] → 데이터 처리
↓
[View] 화면 출력
```


#### 📝 기출 포맷 예시

- 다음 중 **MVC 패턴의 구성 요소**가 아닌 것은?
- **컨트롤러의 역할**로 적절하지 않은 것은?
- MVC 패턴의 **장점 또는 특징**으로 옳은 것을 고르시오

#### 🧠 용어 설명

- **MVC 패턴**: 사용자 인터페이스와 로직을 분리하는 대표적 아키텍처 패턴
- **모델(Model)**: 데이터 및 비즈니스 처리 로직 담당
- **뷰(View)**: 사용자에게 정보 출력 (화면 구성)
- **컨트롤러(Controller)**: 사용자 입력을 처리하고 모델·뷰 연결 제어

---

## 🔹 145. 기타 패턴

#### 📘 정의
기타 패턴은 일반적인 아키텍처 패턴 외에도, **특정 상황이나 시스템 구조에 적합하게 사용되는 설계 방식**을 말한다.  
정보처리기사 실기에서는 대표적으로 다음과 같은 패턴들이 출제 대상이다.

---

### 🧩 1. 마이크로서비스 패턴 (Microservice Architecture, MSA)

- 애플리케이션을 **작고 독립적인 서비스 단위로 분할**하여 구성
- 각 서비스는 **자율적 배포/개발/운영** 가능
- **API 또는 메시징 기반 통신**

| 장점 | 단점 |
|------|------|
| 서비스 독립성, 배포 유연성, 확장성 | 복잡한 운영, 서비스 간 통신 비용 증가 |

---

### 🧩 2. 블랙보드 패턴 (Blackboard Pattern)

- 문제 해결을 위한 **공동 데이터 저장소(블랙보드)**와  
  그 데이터를 사용하는 **모듈(전문가)**로 구성
- **AI, 음성 인식 등 비정형 문제 해결에 활용**

---

### 🧩 3. 브로커 패턴 (Broker Pattern)

- 클라이언트와 서버 사이에 **중간 매개체(브로커)**를 두어  
  **분산 객체 간 통신을 중재**
- RMI, CORBA, MOM 등에서 활용

---

### 🧩 4. 점진적 개선 패턴 (Incremental Pattern)

- 전체 시스템을 한 번에 만들지 않고  
  **기능을 점진적으로 추가하며 완성**해 나가는 방식
- 반복적 개발, 점진적 테스트에 유리

---

### 🧩 5. 마스터-슬레이브 패턴 (Master-Slave Pattern)

- **마스터**가 전체 작업을 제어하고,  
  **슬레이브**들이 하위 작업을 병렬 수행
- 병렬 처리, 로드 분산, 백업 시스템 등에서 활용

---

### 🧩 6. 피어 투 피어 패턴 (P2P Pattern)

- **모든 노드가 대등한 위치에서 직접 통신**
- 중앙 서버 없이 자원 공유 가능
- 예: 토렌트, 분산 파일 공유

---

### 🧩 7. 이벤트 버스 패턴 (Event Bus Pattern)

- **이벤트 발생 → 버스 전달 → 구독자 처리** 구조
- **컴포넌트 간 느슨한 결합** 구현 가능
- 비동기 이벤트 처리 구조에 활용

---

### 🧩 8. 인터프리터 패턴 (Interpreter Pattern)

- **문법 규칙을 해석하여 명령 실행**
- 도메인 특화 언어(DSL), 수식 계산기 등에서 사용
- 구문 트리 기반 처리

---

#### 📝 기출 포맷 예시

- 다음 중 **마이크로서비스 패턴의 특징**으로 옳지 않은 것은?
- **블랙보드/브로커 패턴의 개념 설명** 중 틀린 것은?
- **P2P와 마스터-슬레이브 패턴의 구조 차이**에 대한 설명으로 옳은 것은?

#### 🧠 용어 설명

- **마이크로서비스 패턴**: 독립적인 서비스 단위로 구성된 분산 아키텍처
- **블랙보드 패턴**: 공유 데이터 공간과 전문가 모듈이 상호작용
- **브로커 패턴**: 분산 환경에서 중재자 역할의 구성 방식
- **점진적 개선**: 반복적이고 단계적인 기능 완성 방식
- **마스터-슬레이브**: 제어와 실행 역할을 분리한 처리 구조
- **P2P**: 참여 노드 간 직접 연결 통신 구조
- **이벤트 버스**: 이벤트 기반의 비동기 구조
- **인터프리터**: 명령어 또는 스크립트 해석 실행 구조
