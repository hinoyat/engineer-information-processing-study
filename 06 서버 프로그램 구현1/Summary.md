## 🔹 134. 소프트웨어 아키텍처

#### 📘 정의
소프트웨어 아키텍처(Software Architecture)란,
**소프트웨어 시스템을 구성하는 요소들과 이들 간의 관계를 체계적으로 설계한 고수준 구조 또는 구조체**를 의미한다.  
**전체 시스템 구조, 구성 요소 간의 인터페이스 및 상호작용 방식**, 그리고 **비기능 요구사항(성능, 보안 등)**을 만족시키는 것이 목적이다.

#### 🧩 주요 목적
- **시스템 구조의 명확화** 및 설계 품질 향상
- **재사용성, 확장성, 유지보수성 확보**
- **비기능 요구사항 충족** (성능, 보안, 신뢰성 등)
- 개발자 간 **효율적인 의사소통 기반 제공**

#### 🧩 주요 구성 요소

| 구성 요소 | 설명 |
|------------|------|
| **컴포넌트(Component)** | 시스템 기능을 수행하는 단위 모듈 |
| **커넥터(Connector)** | 컴포넌트 간 데이터 또는 제어 흐름을 전달하는 통신 수단 |

#### 🧩 주요 아키텍처 스타일

| 스타일 | 설명 |
|--------|------|
| **계층형(Layered)** | 기능을 계층으로 분리하여 독립성과 재사용성 향상 |
| **클라이언트-서버(Client-Server)** | 서비스 제공자와 요청자 간 구조 |
| **MVC (Model-View-Controller)** | 데이터, UI, 로직을 분리하여 유지보수성 강화 |
| **마이크로서비스(MSA)** | 작고 독립적인 단위 서비스를 조합해 시스템 구성 |

#### 📝 기출 포맷 예시
- 소프트웨어 아키텍처의 **구성 요소가 아닌 것**은?
- 아키텍처 스타일에 대한 **설명으로 옳지 않은 것**은?
- 소프트웨어 아키텍처의 **주요 목적**으로 옳은 것은?

#### 🧠 용어 설명
- **소프트웨어 아키텍처**: 시스템의 구조와 요소 간 관계를 정의하는 설계
- **컴포넌트**: 독립된 기능을 수행하는 소프트웨어 단위
- **커넥터**: 컴포넌트 간 통신 및 제어 전달 수단
- **MVC**: 모델, 뷰, 컨트롤러로 역할을 분리한 구조
- **MSA**: 마이크로 단위로 서비스화한 분산 시스템 구조

---

## 🔹 135. 모듈화 (Modularity)

#### 📘 정의
모듈화(Modularity)란, **소프트웨어를 독립된 기능 단위(모듈)로 분할하여 개발하는 설계 원칙**이다.  
각 모듈은 **하나의 기능만 수행**하며, 다른 모듈과 **최소한의 연결성(Coupling)**만 가지도록 구성한다.  
모듈화의 궁극적 목적은 **응집도(Cohesion)는 높이고, 결합도(Coupling)는 낮추는 것**이다.

#### 🧩 모듈화의 장점

- **개발 생산성 향상**: 모듈 단위 개발로 병렬 작업 가능
- **유지보수 용이성**: 결함 수정 및 기능 개선 시 영향 범위 축소
- **재사용성 향상**: 독립된 모듈을 다른 시스템에서 재활용 가능
- **이식성 증가**: 모듈 단위로 플랫폼 간 이식 용이

#### 🧩 모듈화의 핵심 원리

| 원리 | 설명 |
|------|------|
| **고응집도 (High Cohesion)** | 하나의 모듈이 **하나의 목적**에 집중하도록 구성 |
| **저결합도 (Low Coupling)** | 모듈 간 **의존성을 최소화**하여 독립성 확보 |

> ✅ 실제 시험에서는 응집도와 결합도의 정의 및 비교가 자주 출제됨

#### 📝 기출 포맷 예시

- 다음 중 **모듈화의 장점**이 아닌 것은?
- **응집도와 결합도**에 대한 설명으로 옳은 것은?
- 소프트웨어 개발 시 **모듈화가 필요한 이유**로 가장 적절한 것은?

#### 🧠 용어 설명

- **모듈화(Modularity)**: 소프트웨어를 독립된 기능 단위로 나누는 설계 방식
- **모듈(Module)**: 하나의 기능을 담당하는 독립적 구성 단위
- **응집도(Cohesion)**: 모듈 내부 구성 요소 간의 관련성
- **결합도(Coupling)**: 모듈 간의 상호 의존성

---

## 🔹 136. 추상화 (Abstraction)

#### 📘 정의
추상화(Abstraction)란, **복잡한 시스템에서 핵심적인 정보만을 표현하고, 불필요한 세부 사항은 감추는 설계 기법**이다.  
소프트웨어를 구성할 때 중요한 요소만을 중심으로 **단순화된 모델**을 구성하여 **이해도, 재사용성, 유지보수성**을 향상시킨다.
-> 전체적이고 포괄적인 개념 설계 후 세분화 하여 구체화 시키는 것
#### 🧩 추상화의 유형 (정보처리기사 시험 기준)

| 유형 | 설명 | 예시 |
|------|------|------|
| **자료 추상화** | 데이터의 핵심 속성만 공개하고, 불필요한 세부 정보는 은닉 | 고객 객체에서 이름, 연락처만 제공하고 주민번호는 숨김 |
| **제어 추상화** | 제어 흐름의 구체적인 동작을 감추고, 전체 흐름만 제공 | 반복문, 조건문, 함수 호출로 내부 제어 흐름 캡슐화 |
| **과정 추상화** | 일련의 처리 과정을 하나의 절차 단위로 캡슐화 | '로그인 처리' 기능으로 여러 내부 절차를 묶어 제공 |

#### 🧩 추상화의 효과

- **복잡도 감소**: 핵심 개념 중심으로 시스템 이해 용이
- **유지보수성 향상**: 내부 구현 변경 시 외부 영향 최소화
- **재사용성 향상**: 공통된 개념 중심으로 범용 기능 분리

#### 📝 기출 포맷 예시

- 다음 중 **소프트웨어 추상화의 유형**으로 옳지 않은 것은?
- **과정/제어/자료 추상화**에 대한 설명으로 적절하지 않은 것은?
- 추상화 적용 예시로 **옳은 것 또는 틀린 것**은?

#### 🧠 용어 설명

- **추상화**: 핵심 개념만 표현하고 나머지는 감추는 설계 원리
- **자료 추상화**: 필요한 데이터 속성만 외부에 공개
- **제어 추상화**: 조건, 반복 등 제어 흐름을 단순화
- **과정 추상화**: 여러 처리 단계를 하나의 절차로 묶음

---

## 🔹 137. 단계적 분해 (Stepwise Refinement)

#### 📘 정의
단계적 분해란, **복잡한 문제를 상위 수준에서 시작해 점차 세부 수준으로 나누어 설계하는 기법**이다.  
즉, 전체 시스템을 기능 단위로 나누고, 이를 다시 더 작고 구체적인 하위 기능들로 분해하여 **계층적 구조로 설계**한다.
-> Niklaus Wirth에 의해 제안. 알고리즘, 자료 구조 등은 뒤로 미루어 진행
#### 🧩 단계적 분해의 목적

- **복잡도 감소**: 큰 문제를 작게 나누어 이해 용이
- **구조적 설계 기반** 마련: 각 단계별 책임과 기능이 명확
- **유지보수성 및 확장성 향상**: 모듈 단위로 수정 가능
- **재사용성 향상**: 공통 기능을 별도로 설계해 여러 곳에 활용 가능

#### 🧩 단계적 분해 vs 추상화 비교

| 구분 | 단계적 분해 | 추상화 |
|------|--------------|--------|
| 방향 | **상위 → 하위 단계로 세분화** | **세부 정보 → 핵심 정보로 단순화** |
| 목적 | 문제를 나누어 해결 | 중요한 것만 강조하여 복잡도 감소 |
| 적용 방식 | 설계 시 기능을 분할 | 인터페이스 또는 정보 구조 단순화 |

> ✅ 시험에서는 둘의 차이점을 묻는 문제가 자주 출제됨

#### 📝 기출 포맷 예시

- 다음 중 **단계적 분해의 개념 또는 효과**로 옳지 않은 것은?
- 추상화와 단계적 분해의 **차이점**으로 적절한 설명은?
- **단계적 분해 기법 적용 사례**로 알맞은 것은?

#### 🧠 용어 설명

- **단계적 분해(Stepwise Refinement)**: 시스템을 상위 수준에서 점진적으로 구체화하여 설계하는 기법
- **구조적 설계**: 체계적이고 계층적인 방식으로 소프트웨어를 설계하는 접근
- **기능 분할**: 하나의 기능을 하위 기능으로 나누는 작업

---

## 🔹 137. 단계적 분해 (Stepwise Refinement)

#### 📘 정의
단계적 분해란, **복잡한 문제를 상위 수준에서 시작해 점차 세부 수준으로 나누어 설계하는 기법**이다.  
즉, 전체 시스템을 기능 단위로 나누고, 이를 다시 더 작고 구체적인 하위 기능들로 분해하여 **계층적 구조로 설계**한다.

#### 🧩 단계적 분해의 목적

- **복잡도 감소**: 큰 문제를 작게 나누어 이해 용이
- **구조적 설계 기반** 마련: 각 단계별 책임과 기능이 명확
- **유지보수성 및 확장성 향상**: 모듈 단위로 수정 가능
- **재사용성 향상**: 공통 기능을 별도로 설계해 여러 곳에 활용 가능

#### 🧩 단계적 분해 vs 추상화 비교

| 구분 | 단계적 분해 | 추상화 |
|------|--------------|--------|
| 방향 | **상위 → 하위 단계로 세분화** | **세부 정보 → 핵심 정보로 단순화** |
| 목적 | 문제를 나누어 해결 | 중요한 것만 강조하여 복잡도 감소 |
| 적용 방식 | 설계 시 기능을 분할 | 인터페이스 또는 정보 구조 단순화 |

> ✅ 시험에서는 둘의 차이점을 묻는 문제가 자주 출제됨

#### 📝 기출 포맷 예시

- 다음 중 **단계적 분해의 개념 또는 효과**로 옳지 않은 것은?
- 추상화와 단계적 분해의 **차이점**으로 적절한 설명은?
- **단계적 분해 기법 적용 사례**로 알맞은 것은?

#### 🧠 용어 설명

- **단계적 분해(Stepwise Refinement)**: 시스템을 상위 수준에서 점진적으로 구체화하여 설계하는 기법
- **구조적 설계**: 체계적이고 계층적인 방식으로 소프트웨어를 설계하는 접근
- **기능 분할**: 하나의 기능을 하위 기능으로 나누는 작업

---

## 🔹 139. 협약에 의한 설계 (Design by Contract)

#### 📘 정의
협약에 의한 설계(Design by Contract, DBC)란, **모듈 간의 상호 작용에서 지켜야 할 규칙을 '계약'으로 명시하여 소프트웨어를 설계하는 방식**이다.  
각 모듈은 계약 조건에 따라 자신이 만족시켜야 할 요구사항을 책임지며, 이로써 **모듈 간 신뢰성과 안정성**을 확보할 수 있다.  
계약은 **선행 조건, 결과 조건, 불변 조건**의 세 가지로 구성된다.

#### 🧩 계약 조건의 구성 요소

| 계약 요소 | 설명 |
|-----------|------|
| **선행 조건 (Precondition)** | 모듈 또는 연산이 실행되기 전에 반드시 참이어야 하는 조건 |
| **결과 조건 (Postcondition)** | 모듈 또는 연산 실행 후 반드시 만족해야 하는 조건 |
| **불변 조건 (Invariant)** | 모듈 실행 전후 또는 전체 실행 과정 동안 항상 유지되어야 하는 조건 |

#### 🧩 협약에 의한 설계의 효과

- **모듈 간 책임 분담 명확화**
- **인터페이스 안정성 향상**
- **예외 상황 방지 및 오류 감소**
- **사양 기반 테스트 및 명세 문서화 용이**

#### 📝 기출 포맷 예시

- 다음 중 **협약에 의한 설계의 구성 요소**가 아닌 것은?
- **선행 조건, 결과 조건, 불변 조건**의 의미로 적절하지 않은 것은?
- 협약 기반 설계의 **효과로 옳은 것**은?

#### 🧠 용어 설명

- **협약에 의한 설계 (Design by Contract)**: 조건 기반 계약을 통해 안정적 소프트웨어 동작을 보장하는 설계 기법
- **선행 조건 (Precondition)**: 연산 수행 전에 반드시 만족해야 하는 조건
- **결과 조건 (Postcondition)**: 연산 수행 후 반드시 충족되어야 하는 조건
- **불변 조건 (Invariant)**: 시스템 상태가 변하지 않고 항상 유지되어야 하는 조건

---

## 🔹 140. 아키텍처 패턴 (Architecture Pattern)

#### 📘 정의
아키텍처 패턴이란, **소프트웨어 시스템 설계 시 반복적으로 사용되는 구조적 설계 해결 방식**이다.  
전체 시스템을 구성할 때 **모듈 간 배치, 책임 분담, 데이터 흐름 구조** 등을 정의하여, **효율적인 구조와 품질 확보**를 가능하게 한다.

#### 🧩 주요 아키텍처 패턴

| 패턴 | 설명 |
|------|------|
| **계층형 패턴 (Layered Pattern)** | 기능을 계층으로 분리하여 구성 (UI → 비즈니스 로직 → 데이터 접근) |
| **클라이언트-서버 패턴 (Client-Server Pattern)** | 서비스 요청자(클라이언트)와 제공자(서버)로 나눔 |
| **MVC 패턴 (Model-View-Controller)** | 데이터(Model), UI(View), 제어(Controller)를 분리 |
| **마이크로서비스 패턴 (Microservice Architecture, MSA)** | 서비스 단위를 독립적으로 배포 가능한 작은 단위로 분할 |
| **파이프-필터 패턴 (Pipe and Filter)** | 처리 과정을 필터 단위로 분리하고 파이프로 연결하여 순차 처리 |

> ✅ 시험에서는 위 패턴의 구조적 특징 또는 장단점을 묻는 문제가 자주 출제됨

#### 🧩 패턴 적용 시 장점

- **구조적 일관성 확보**
- **모듈화, 재사용성, 유지보수성 향상**
- **품질 속성(성능, 보안 등) 충족 유도**
- **시스템 확장성 및 관리 용이성 증가**

#### 📝 기출 포맷 예시

- 다음 중 **아키텍처 패턴**에 해당하지 않는 것은?
- **MVC 패턴의 구성 요소**로 옳지 않은 것은?
- **마이크로서비스 아키텍처의 특징**으로 알맞은 것은?

#### 🧠 용어 설명

- **아키텍처 패턴**: 구조적 설계 문제 해결을 위한 재사용 가능한 설계 구조
- **계층형 패턴**: 각 계층 간 역할 분리 및 독립성 확보
- **MVC**: 데이터, UI, 제어 로직을 분리하여 유지보수성 향상
- **MSA**: 서비스 단위를 분리하여 독립 배포 및 운영 가능
- **파이프-필터**: 데이터를 연속적 처리 단계로 나누어 구성

---

## 🔹 141. 레이어 패턴 (Layered Pattern)

#### 📘 정의
레이어 패턴(Layered Pattern)은 **기능별로 시스템을 계층(레이어) 구조로 분리하여 구성하는 아키텍처 설계 방식**이다.  
각 계층은 **명확한 역할과 책임을 가지며**, **하위 계층의 서비스만을 이용**하도록 설계된다.  
→ 대표적인 예: **프리젠테이션 계층, 비즈니스 계층, 데이터 접근 계층**

#### 🧩 레이어 구조 예시

| 계층 | 역할 |
|------|------|
| **프리젠테이션 계층** | 사용자 인터페이스 처리 (UI, 화면 등) |
| **비즈니스 계층** | 애플리케이션의 핵심 로직 처리 |
| **데이터 접근 계층 (DAO)** | DB, 파일 등 데이터 저장소에 접근 및 처리 |

> ✅ 시험에서는 "다음 중 레이어 패턴의 구성 계층이 아닌 것" 또는 "비즈니스 계층의 역할은?" 형식으로 출제됨

#### 🧩 레이어 패턴의 특징

- **역할별 책임 분리**로 설계 명확화
- **모듈화 향상** → 유지보수 용이
- **하위 계층 독립적 설계** 가능
- **테스트 및 디버깅 효율 향상**

#### 🧩 장점 vs 단점

| 항목 | 내용 |
|------|------|
| **장점** | 구조 명확, 재사용성 향상, 계층 간 독립성 |
| **단점** | 계층이 많아지면 **성능 저하**, 복잡도 증가 가능 |

#### 📝 기출 포맷 예시

- 다음 중 **레이어 패턴의 계층 구조에 포함되지 않는 것**은?
- **비즈니스 계층의 역할**로 옳지 않은 것은?
- 레이어 패턴 적용의 **장점 또는 단점**에 대한 설명으로 옳은 것은?

#### 🧠 용어 설명

- **레이어 패턴**: 시스템을 계층화하여 기능을 분리하고 각 계층 간 역할을 명확히 하는 설계 방식
- **프리젠테이션 계층**: 사용자와 상호작용하는 화면/UI 처리 담당
- **비즈니스 계층**: 업무 규칙과 처리 로직을 수행
- **데이터 접근 계층**: DB나 외부 저장소와의 연동 처리 담당

---

## 🔹 142. 클라이언트-서버 패턴 (Client-Server Pattern)

#### 📘 정의
클라이언트-서버 패턴은 **서비스를 요청하는 클라이언트와, 요청을 처리하는 서버를 명확히 분리하여 구성하는 아키텍처 설계 방식**이다.  
시스템을 **요청자(클라이언트)**와 **응답자(서버)** 구조로 나누어, 각자의 역할에 따라 독립적으로 관리할 수 있도록 한다.

#### 🧩 구조 구성

| 구성 요소 | 역할 |
|-----------|------|
| **클라이언트(Client)** | 사용자 인터페이스 제공, 서버에 서비스 요청 전송 |
| **서버(Server)** | 요청 처리 및 결과 반환, 데이터 저장 및 관리 담당 |

> ✅ 시험에서는 구성 요소 역할, 특징 비교가 빈출

#### 🧩 특징

- **역할 분리**: 클라이언트와 서버 간 기능 명확히 구분
- **중앙 집중 처리 구조**: 서버가 로직·데이터 처리 중심
- **다수 클라이언트 지원 가능**
- **보안, 확장성, 유지보수 용이**

#### 🧩 장단점 비교

| 항목 | 장점 | 단점 |
|------|------|------|
| **클라이언트-서버 패턴** | 처리 분산, 관리 용이, 보안 적용 용이 | 서버 과부하 시 성능 저하 발생 가능 |

#### 📝 기출 포맷 예시

- 다음 중 **클라이언트-서버 패턴의 특징**으로 옳지 않은 것은?
- **서버의 역할**로 적절하지 않은 것은?
- 클라이언트-서버 구조의 **장단점 비교 설명 중 옳은 것**은?

#### 🧠 용어 설명

- **클라이언트-서버 패턴**: 요청-응답 구조로 시스템을 분리한 아키텍처 설계
- **클라이언트**: 사용자 요청을 생성하여 서버로 전송하는 주체
- **서버**: 클라이언트 요청을 받아 처리하고 응답을 반환하는 시스템

---

## 🔹 143. 파이프-필터 패턴 (Pipe and Filter Pattern)

#### 📘 정의
파이프-필터 패턴은 **데이터 처리 과정을 여러 단계(필터)로 분할하고, 각 단계를 파이프를 통해 연결하여 순차적으로 처리하는 아키텍처 설계 방식**이다.  
각 필터는 **독립된 데이터 처리 기능을 수행**하며, 파이프는 **데이터 흐름 경로**를 담당한다.

#### 🧩 구조 구성

| 구성 요소 | 역할 |
|-----------|------|
| **필터(Filter)** | 입력 데이터를 가공하여 출력 데이터를 생성 (처리 단위) |
| **파이프(Pipe)** | 필터 간 데이터 전달 통로 (데이터 흐름 연결) |

> ✅ 시험에서는 "필터의 역할은?", "파이프-필터 구조 설명 중 틀린 것" 형태로 자주 출제됨

#### 🧩 특징

- **단계별 처리 분리** → 유지보수 용이
- **필터의 독립성 확보** → 재사용성 향상
- **처리 파이프라인 구성 용이**
- **병렬 처리 가능성 존재**

#### 🧩 대표 활용 예시

- **UNIX Shell 명령어 파이프라인**: `cat file.txt | grep "error" | sort`
- **멀티미디어 데이터 처리 시스템**
- **컴파일러의 전처리기 → 파서 → 코드 생성기 등**

#### 📝 기출 포맷 예시

- 파이프-필터 패턴의 **구성 요소**로 옳지 않은 것은?
- 필터와 파이프의 **역할 설명** 중 적절한 것은?
- 파이프-필터 패턴의 **적용 장점**이 아닌 것은?

#### 🧠 용어 설명

- **파이프-필터 패턴**: 처리 단계를 나누고, 각 단계를 직렬로 연결하는 구조
- **필터(Filter)**: 입력을 받아 가공하고 출력하는 독립 모듈
- **파이프(Pipe)**: 필터 간 데이터 흐름을 연결하는 경로

---

## 🔹 144. 모델-뷰-컨트롤러 패턴 (MVC 패턴)

#### 📘 정의
MVC 패턴은 **사용자 인터페이스(UI)와 비즈니스 로직, 데이터 처리를 분리**하여 설계하는 아키텍처 패턴이다.  
**모델(Model), 뷰(View), 컨트롤러(Controller)**의 세 구성 요소로 나뉘며, **유지보수성과 확장성**을 향상시키는 데 목적이 있다.

#### 🧩 구성 요소 및 역할

| 구성 요소 | 역할 |
|------------|------|
| **모델(Model)** | 데이터 처리 및 비즈니스 로직 담당 |
| **뷰(View)** | 사용자 인터페이스 출력 및 화면 구성 |
| **컨트롤러(Controller)** | 사용자 입력을 해석하고 처리 흐름 제어 (모델/뷰 연결 역할) |

> ✅ 시험에서는 각 요소의 역할 설명, MVC 구조 흐름 문제가 자주 출제됨

#### 🧩 특징

- **역할 분리**를 통해 변경 영향 최소화
- **유지보수성 향상**: 화면/UI 변경 시 비즈니스 로직 영향 없음
- **테스트 용이성 향상**
- **컴포넌트 재사용 가능성 증가**

#### 🧩 데이터 흐름 예시
```
사용자 입력 → [Controller] → [Model] → 데이터 처리
↓
[View] 화면 출력
```


#### 📝 기출 포맷 예시

- 다음 중 **MVC 패턴의 구성 요소**가 아닌 것은?
- **컨트롤러의 역할**로 적절하지 않은 것은?
- MVC 패턴의 **장점 또는 특징**으로 옳은 것을 고르시오

#### 🧠 용어 설명

- **MVC 패턴**: 사용자 인터페이스와 로직을 분리하는 대표적 아키텍처 패턴
- **모델(Model)**: 데이터 및 비즈니스 처리 로직 담당
- **뷰(View)**: 사용자에게 정보 출력 (화면 구성)
- **컨트롤러(Controller)**: 사용자 입력을 처리하고 모델·뷰 연결 제어

---

## 🔹 145. 기타 패턴

#### 📘 정의
기타 패턴은 일반적인 아키텍처 패턴 외에도, **특정 상황이나 시스템 구조에 적합하게 사용되는 설계 방식**을 말한다.  
정보처리기사 실기에서는 대표적으로 다음과 같은 패턴들이 출제 대상이다.

---

### 🧩 1. 마이크로서비스 패턴 (Microservice Architecture, MSA)

- 애플리케이션을 **작고 독립적인 서비스 단위로 분할**하여 구성
- 각 서비스는 **자율적 배포/개발/운영** 가능
- **API 또는 메시징 기반 통신**

| 장점 | 단점 |
|------|------|
| 서비스 독립성, 배포 유연성, 확장성 | 복잡한 운영, 서비스 간 통신 비용 증가 |

---

### 🧩 2. 블랙보드 패턴 (Blackboard Pattern)

- 문제 해결을 위한 **공동 데이터 저장소(블랙보드)**와  
  그 데이터를 사용하는 **모듈(전문가)**로 구성
- **AI, 음성 인식 등 비정형 문제 해결에 활용**

---

### 🧩 3. 브로커 패턴 (Broker Pattern)

- 클라이언트와 서버 사이에 **중간 매개체(브로커)**를 두어  
  **분산 객체 간 통신을 중재**
- RMI, CORBA, MOM 등에서 활용

---

### 🧩 4. 점진적 개선 패턴 (Incremental Pattern)

- 전체 시스템을 한 번에 만들지 않고  
  **기능을 점진적으로 추가하며 완성**해 나가는 방식
- 반복적 개발, 점진적 테스트에 유리

---

### 🧩 5. 마스터-슬레이브 패턴 (Master-Slave Pattern)

- **마스터**가 전체 작업을 제어하고,  
  **슬레이브**들이 하위 작업을 병렬 수행
- 병렬 처리, 로드 분산, 백업 시스템 등에서 활용

---

### 🧩 6. 피어 투 피어 패턴 (P2P Pattern)

- **모든 노드가 대등한 위치에서 직접 통신**
- 중앙 서버 없이 자원 공유 가능
- 예: 토렌트, 분산 파일 공유

---

### 🧩 7. 이벤트 버스 패턴 (Event Bus Pattern)

- **이벤트 발생 → 버스 전달 → 구독자 처리** 구조
- **컴포넌트 간 느슨한 결합** 구현 가능
- 비동기 이벤트 처리 구조에 활용

---

### 🧩 8. 인터프리터 패턴 (Interpreter Pattern)

- **문법 규칙을 해석하여 명령 실행**
- 도메인 특화 언어(DSL), 수식 계산기 등에서 사용
- 구문 트리 기반 처리

---

#### 📝 기출 포맷 예시

- 다음 중 **마이크로서비스 패턴의 특징**으로 옳지 않은 것은?
- **블랙보드/브로커 패턴의 개념 설명** 중 틀린 것은?
- **P2P와 마스터-슬레이브 패턴의 구조 차이**에 대한 설명으로 옳은 것은?

#### 🧠 용어 설명

- **마이크로서비스 패턴**: 독립적인 서비스 단위로 구성된 분산 아키텍처
- **블랙보드 패턴**: 공유 데이터 공간과 전문가 모듈이 상호작용
- **브로커 패턴**: 분산 환경에서 중재자 역할의 구성 방식
- **점진적 개선**: 반복적이고 단계적인 기능 완성 방식
- **마스터-슬레이브**: 제어와 실행 역할을 분리한 처리 구조
- **P2P**: 참여 노드 간 직접 연결 통신 구조
- **이벤트 버스**: 이벤트 기반의 비동기 구조
- **인터프리터**: 명령어 또는 스크립트 해석 실행 구조

---

## 🔹 146. 객체지향 (Object-Oriented)

#### 📘 정의
객체지향(Object-Oriented)이란, **현실 세계를 객체 단위로 모델링하여 소프트웨어를 구성하는 설계 및 프로그래밍 방식**이다.  
**객체, 클래스, 메시지, 캡슐화, 상속, 다형성** 등의 개념을 기반으로 하며,  
**재사용성, 유지보수성, 확장성**을 높이기 위한 핵심 패러다임이다.

#### 🧩 객체지향의 핵심 구성 요소

| 구성 요소 | 설명 |
|-----------|------|
| **객체(Object)** | 데이터(속성)와 기능(메서드)을 함께 가지는 독립 실행 단위 |
| **클래스(Class)** | 객체를 생성하기 위한 설계도 (객체의 속성과 동작 정의) |
| **메시지(Message)** | 객체 간 상호작용 방법 (메서드 호출)

#### 🧩 객체지향의 주요 특성 (4대 특징)

| 특성 | 설명 |
|------|------|
| **캡슐화(Encapsulation)** | 데이터와 기능을 하나로 묶고, 외부에서 내부 정보 은닉 |
| **상속(Inheritance)** | 기존 클래스의 속성과 기능을 새로운 클래스가 확장 |
| **다형성(Polymorphism)** | 동일한 메시지에 대해 다양한 동작을 수행 |
| **추상화(Abstraction)** | 불필요한 세부사항을 감추고 핵심만 표현
-> 책에서는 추상화 대신 연관성이라는데 찾으면 추상화가 들어가야 함

#### 🧩 객체지향의 장점

- **재사용성**: 클래스/객체 단위 재사용 가능
- **유지보수성**: 변경 영향 최소화
- **확장성**: 구조 변경 없이 기능 추가 가능
- **모델링 용이**: 현실 세계 반영 쉬움

#### 📝 기출 포맷 예시

- 다음 중 **객체지향의 4대 특성**이 아닌 것은?
- 객체지향의 구성 요소 중 **메시지의 역할**은?
- **객체지향 설계의 장점**으로 적절하지 않은 것은?

#### 🧠 용어 설명

- **객체지향**: 객체 단위로 구성된 소프트웨어 설계 패러다임
- **객체**: 속성과 동작을 가진 독립 단위
- **클래스**: 객체를 정의하는 설계도
- **메시지**: 객체 간의 메서드 호출 방식
- **캡슐화/상속/다형성/추상화**: 객체지향의 4대 핵심 특성

---

## 🔹 147. 객체 (Object)

#### 📘 정의
객체(Object)란, **속성(데이터)과 행위(메서드)를 함께 포함하는 소프트웨어의 기본 구성 단위**이다.  
현실 세계의 사물 또는 개념을 **프로그래밍적으로 추상화**한 존재로,  
**클래스를 기반으로 생성**되며, 실행 시 메모리에 할당된다.
데이터와 이를 처리하기 위한 함수를 묶어 놓은 소프트웨어 모듈

#### 🧩 객체의 구성 요소

| 구성 요소 | 설명 |
|-----------|------|
| **속성 (Attribute)** | 객체가 가지는 데이터 (상태) |
| **메서드 (Method)** | 객체가 수행할 수 있는 기능 또는 동작 |
| **식별자 (ID)** | 객체를 구별하기 위한 고유 이름 또는 참조값

#### 🧩 객체의 특징

- **고유성**: 다른 객체와 구별되는 식별성 존재
- **캡슐화**: 데이터와 기능을 하나로 묶음
- **상호작용**: 메시지를 통해 다른 객체와 통신
- **동적 생성**: 클래스 기반으로 런타임 시 생성됨

#### 🧩 객체 vs 클래스 비교

| 항목 | 객체 | 클래스 |
|------|------|--------|
| 의미 | 실체(인스턴스) | 설계도 |
| 존재 시점 | 실행 시 생성 | 코드 작성 시 정의 |
| 역할 | 메모리상 동작 주체 | 객체 생성을 위한 틀 |

#### 📝 기출 포맷 예시

- 다음 중 **객체의 구성 요소**가 아닌 것은?
- 객체와 클래스의 **차이점 설명** 중 옳지 않은 것은?
- 객체의 **특징**으로 알맞은 것을 고르시오

#### 🧠 용어 설명

- **객체(Object)**: 속성과 행위를 가지는 독립 실행 단위
- **속성(Attribute)**: 객체의 상태를 표현하는 변수
- **메서드(Method)**: 객체가 수행하는 기능
- **식별자(ID)**: 객체를 고유하게 구분하는 값

---

## 🔹 148. 클래스 (Class)

#### 📘 정의
클래스(Class)란, **객체를 생성하기 위한 설계도 또는 틀**을 의미한다.  
객체가 가져야 할 **속성과 메서드(기능)**를 정의하며,  
**동일한 구조와 동작을 갖는 객체들을 생성**하는 데 사용된다.

#### 🧩 클래스의 구성 요소

| 구성 요소 | 설명 |
|-----------|------|
| **속성 (Attribute)** | 객체가 가질 데이터 항목 (변수, 상태값 등) |
| **메서드 (Method)** | 객체가 수행할 기능 또는 동작 |
| **생성자 (Constructor)** | 객체 생성 시 호출되는 초기화 함수 (시험 출제 가능) |

#### 🧩 클래스의 특징

- **객체 생성의 틀**로 사용됨
- **정보은닉**과 **캡슐화**를 지원
- **재사용 가능**한 코드 구조 제공
- **상속, 다형성** 등의 객체지향 특성을 적용 가능

#### 🧩 클래스 vs 객체 비교

| 구분 | 클래스 | 객체 |
|------|--------|------|
| 정의 | 객체 생성 설계도 | 클래스 기반으로 생성된 실체 |
| 시점 | 코드 작성 시 정의 | 실행 시 생성됨 |
| 수량 | 하나의 클래스 정의 | 여러 객체 생성 가능 |

#### 📝 기출 포맷 예시

- 다음 중 **클래스의 역할 또는 특징**으로 옳지 않은 것은?
- 클래스와 객체의 **차이 설명 중** 틀린 것은?
- 클래스의 **구성 요소**로 올바르지 않은 것은?

#### 🧠 용어 설명

- **클래스(Class)**: 동일한 속성과 기능을 갖는 객체들을 생성하기 위한 설계도
- **속성(Attribute)**: 객체의 데이터 항목을 정의하는 구성요소
- **메서드(Method)**: 객체가 수행할 수 있는 동작
- **생성자(Constructor)**: 객체 생성 시 자동으로 호출되어 초기화 수행

---

## 🔹 149. 메시지 (Message)

#### 📘 정의
메시지(Message)란, **객체 간에 상호작용을 위해 주고받는 요청 또는 명령**을 의미한다.  
한 객체가 다른 객체에게 **메서드 실행을 요청하는 형태**로 전달되며,  
객체지향 시스템에서 **객체 간 통신 수단**으로 사용된다.

#### 🧩 메시지의 구성 요소

| 구성 요소 | 설명 |
|-----------|------|
| **수신자 (Receiver)** | 메시지를 받는 객체 |
| **메시지 이름 (Name)** | 호출될 메서드 또는 명령 이름 |
| **인자 (Argument)** | 전달될 입력값 (옵션) |

> 예: `객체.메서드(인자)` → 객체에게 메서드 실행을 요청하는 메시지 전송

#### 🧩 메시지의 특징

- **객체 간 상호작용의 핵심 수단**
- **캡슐화된 기능을 외부에서 호출**하는 방식
- **결합도 낮추는 구조 구현 가능** (인터페이스 중심 호출)
- **다형성** 실현의 전제 조건 (동일 메시지, 다른 동작)

#### 🧩 메시지 전달 예시

```plaintext
사용자 → 로그인 버튼 클릭  
↓  
Controller 객체 → login() 메시지 전달  
↓  
UserService 객체 → 인증 처리 수행
```

#### 📝 기출 포맷 예시

* 다음 중 **객체 간 메시지 전달에 대한 설명**으로 옳지 않은 것은?
* 메시지의 **구성 요소**가 아닌 것은?
* 메시지를 통해 **객체 간 어떤 작용이 발생하는가?**

#### 🧠 용어 설명

* **메시지(Message)**: 객체 간 상호작용을 위한 메서드 실행 요청
* **수신자**: 메시지를 전달받는 객체
* **인자(Argument)**: 메시지와 함께 전달되는 값
* **메서드(Method)**: 메시지를 수신한 객체가 실행하는 기능

---

## 🔹 150. 캡슐화 (Encapsulation)

#### 📘 정의
캡슐화(Encapsulation)란, **데이터(속성)와 이를 처리하는 메서드(기능)를 하나의 단위로 묶고**,  
**외부에서는 내부 구현을 직접 접근하지 못하도록 숨기는 객체지향의 핵심 특성**이다.  
이를 통해 **정보 은닉**, **접근 제어**, **결합도 감소**를 실현할 수 있다.

#### 🧩 캡슐화의 목적

- **내부 구현 보호**: 외부에서 직접 접근하지 못하게 함
- **정보 은닉**: 객체의 상태나 로직을 감추고 필요한 인터페이스만 공개
- **유지보수 용이**: 내부 변경 시 외부 영향 최소화
- **보안성 향상**: 잘못된 접근을 방지

#### 🧩 캡슐화 구현 방법

| 방법 | 설명 |
|------|------|
| **접근 제어자 사용** | private, protected, public 등을 통해 외부 접근 제한 |
| **Getter/Setter 제공** | 필요한 정보만 간접적으로 접근 가능하도록 메서드 제공 |
| **인터페이스 기반 설계** | 구현을 숨기고 동작만 정의

#### 📝 기출 포맷 예시

- 다음 중 **캡슐화의 목적 또는 효과**로 옳지 않은 것은?
- 캡슐화를 **구현하기 위한 방법**으로 적절하지 않은 것은?
- 캡슐화의 **정의나 개념**에 대한 설명으로 맞는 것은?

#### 🧠 용어 설명

- **캡슐화(Encapsulation)**: 데이터와 기능을 하나의 단위로 묶고 외부로부터 숨기는 객체지향 특성
- **정보 은닉**: 외부에 불필요한 정보를 공개하지 않는 설계 원칙
- **접근 제어자**: 외부 접근을 제한하기 위한 키워드 (private, public 등)
- **Getter/Setter**: 캡슐화된 속성에 접근하는 간접적인 메서드

---

## 🔹 151. 상속 (Inheritance)

#### 📘 정의
상속(Inheritance)이란, **기존 클래스(부모)의 속성과 메서드를 새로운 클래스(자식)가 물려받아 재사용하거나 확장하는 객체지향의 특성**이다.  
코드의 **재사용성과 유지보수성**을 높이고, **계층적 구조 설계**를 가능하게 한다.

#### 🧩 상속의 특징

- **코드 재사용성 증가**: 공통 기능을 상위 클래스에 정의하고 하위 클래스에서 재사용
- **확장성 향상**: 하위 클래스에서 새로운 기능 추가 가능
- **유지보수 용이**: 변경 시 상위 클래스만 수정하면 하위 클래스에도 적용
- **계층적 구조 설계**: 일반화/특수화 구조 표현 가능

#### 🧩 상속 관련 용어

| 용어 | 설명 |
|------|------|
| **부모 클래스 (Super Class)** | 상속을 제공하는 기존 클래스 |
| **자식 클래스 (Sub Class)** | 상속을 받는 새로운 클래스 |
| **오버라이딩 (Overriding)** | 상속받은 메서드를 자식 클래스에서 재정의하는 것 |

> ✅ 시험에서는 "오버라이딩", "코드 재사용", "계층 구조" 등의 키워드와 함께 자주 출제됨

#### 🧩 상속의 한계

- **다중 상속 미지원 (Java 기준)**: 하나의 클래스만 상속 가능
- **상속 관계가 복잡할 경우 오류 전파 위험 존재**
- **부모 클래스 변경 시 자식 클래스에 영향 발생 가능**

#### 📝 기출 포맷 예시

- 다음 중 **상속의 장점**으로 적절하지 않은 것은?
- **상속 관련 용어**의 정의로 옳은 것은?
- **상속과 오버라이딩**의 관계에 대한 설명으로 알맞은 것은?

#### 🧠 용어 설명

- **상속(Inheritance)**: 기존 클래스의 속성과 메서드를 재사용 또는 확장하는 객체지향 특성
- **부모 클래스**: 속성과 기능을 제공하는 클래스
- **자식 클래스**: 부모 클래스를 상속받는 클래스
- **오버라이딩**: 상속받은 메서드를 재정의하여 자식 클래스에서 다른 동작을 수행하는 것

---

## 🔹 152. 다형성 (Polymorphism)

#### 📘 정의
다형성(Polymorphism)이란, **하나의 메시지에 대해 객체마다 서로 다르게 반응하는 객체지향의 특성**이다.  
같은 이름의 메시지를 수신하더라도 객체의 종류에 따라 **다른 방식으로 동작**하도록 구현할 수 있다.

#### 🧩 다형성의 종류

| 종류 | 설명 |
|------|------|
| **오버라이딩 (Overriding)** | 상속받은 메서드를 자식 클래스에서 재정의 |
| **오버로딩 (Overloading)** | 하나의 클래스 내에서 같은 이름의 메서드를 매개변수만 다르게 정의 |

> ✅ 시험에서는 오버라이딩과 오버로딩의 구분을 묻는 문제가 자주 출제됨

#### 🧩 다형성의 특징 및 장점

- **유연한 설계 가능**: 객체에 따라 다른 동작 구현 가능
- **확장성 향상**: 새로운 객체 추가 시 기존 코드 변경 최소화
- **모듈화 및 유지보수성 우수**
- **메시지 중심 설계** 가능 (동일 메시지 → 다양한 객체 처리)

#### 🧩 관련 개념 비교

| 구분 | 오버라이딩 | 오버로딩 |
|------|------------|-----------|
| 적용 위치 | 상속 관계의 자식 클래스 | 동일 클래스 내부 |
| 메서드 이름 | 동일 | 동일 |
| 매개변수 | 동일 | 서로 다름 |
| 반환 타입 | 동일해야 함 | 달라도 무방함 |
| 실행 시점 | 런타임(동적 바인딩) | 컴파일 타임(정적 바인딩) |

#### 📝 기출 포맷 예시

- 다음 중 **다형성의 특징**으로 옳지 않은 것은?
- **오버라이딩과 오버로딩의 차이**에 대한 설명으로 틀린 것은?
- 다형성을 **활용한 설계 방식**에 대한 설명으로 알맞은 것은?

#### 🧠 용어 설명

- **다형성(Polymorphism)**: 동일한 메시지에 대해 객체별로 다르게 반응하는 객체지향 특성
- **오버라이딩**: 상속받은 메서드를 자식 클래스에서 재정의
- **오버로딩**: 같은 이름의 메서드를 매개변수만 달리하여 여러 개 정의하는 것
- **동적 바인딩**: 실행 시점에 호출할 메서드가 결정되는 방식 (오버라이딩)
- **정적 바인딩**: 컴파일 시점에 호출할 메서드가 결정되는 방식 (오버로딩)

---

## 🔹 153. 연관성 (Association)

#### 📘 정의
연관성(Association)은 **두 객체 간 의미 있는 연결 관계**를 표현하며,  
객체 간 메시지를 주고받기 위한 **논리적 연결 구조**를 나타낸다.

#### 🧩 시험 기준 주요 관계 표현

| 표현 | 의미 | 관계 유형 | 예시 |
|-------|------|------------|------|
| `is member of` | 객체가 집합의 구성원임 | 연관화 (Association) | 학생은 학급의 구성원이다 |
| `is instance of` | 객체가 클래스의 인스턴스임 | 분류화 (Classification) | 철수는 학생 클래스의 인스턴스이다 |
| `is part of` | 전체-부분 관계, 부분은 독립 생존 가능 | 집단화 (Aggregation) | 바퀴는 자동차의 일부이다 |
| `is a` | 상속 관계 표현 (일반화/특수화/상세화) | 일반화 (Generalization) | 고양이는 동물이다 |

> ✅ `is member of`는 연관화  
> ✅ `is part of`는 집단화  
> ✅ `is a`는 일반화로 분류됨

#### 📝 기출 포맷 예시

- 다음 중 `is part of` 관계를 나타내는 것은?
- 연관성 관계 중 `is member of`에 해당하는 것은?
- `is a` 관계로 알맞은 것은?

#### 🧠 용어 설명

- **연관화 (Association)**: 객체 간 의미 있는 연결
- **분류화 (Classification)**: 인스턴스와 클래스 간 관계
- **집단화 (Aggregation)**: 전체-부분 관계, 부분은 독립
- **일반화 (Generalization)**: 상속 관계, `is a` 표현

---

## 🔹 154. 객체지향 분석 (Object-Oriented Analysis, OOA)

#### 📘 정의
객체지향 분석이란, **현실 세계의 문제를 객체 모델로 표현하여 시스템 요구사항을 분석하는 기법**이다.  
사용자의 요구사항을 기반으로 **객체, 클래스, 속성, 메서드, 관계** 등을 도출한다.

#### 🧩 객체지향 분석의 특징

- **현실 세계 모델링에 적합**
- **재사용성과 확장성** 우수
- **모델 간 일관성** 유지 (분석 → 설계 → 구현)
- **유지보수성 향상**

#### 🧩 분석 절차 (출제 기준 중심)

1. **요구사항 분석**: 사용자 요구사항 식별
2. **클래스 도출**: 현실 세계 개체 → 클래스 모델링
3. **속성·메서드 정의**: 객체의 상태와 동작 정의
4. **객체 간 관계 정의**: 연관, 집합, 일반화 등
5. **객체 모델 작성**: 클래스 다이어그램 완성

#### 📝 기출 포맷 예시

- 객체지향 분석의 **장점**으로 적절하지 않은 것은?
- 객체지향 분석에서 수행하는 **활동으로 옳은 것**은?
- 다음 중 **객체지향 분석의 절차에 해당하지 않는 것**은?

#### 🧠 용어 설명

- **객체(Object)**: 속성과 동작을 갖는 독립된 개체
- **클래스(Class)**: 유사 객체들의 추상적 정의
- **메서드(Method)**: 객체가 수행하는 동작
- **속성(Attribute)**: 객체의 상태나 데이터

---

## 🔹 155. 객체지향 분석의 방법론

#### 📘 정의
객체지향 분석 방법론은 **현실 세계를 객체 기반으로 모델링하기 위한 체계적인 분석 기법**이다.

#### 🧩 주요 방법론 비교

| 방법론 | 제안자 | 분석 관점 | 특징                                                           |
|--------|--------|-----------|--------------------------------------------------------------|
| **럼바우 방법** | Rumbaugh | 기능, 객체, 동작 | 분석 활동 - 객체 모델링 기법(OMT), 정적 구조 중심                             |
| **부치 방법** | Booch | 객체, 클래스 | 미시적(Micro) 거시적(Macro) 개발프로세스 모두 사용 객체의 행위 및 상태 강조, 설계와 연계 강조 |
| **야콥슨 방법** | Jacobson | 사용자 중심 | 유스케이스 기반 분석, 사용자 관점 강조                                       |
| **Coad와 Yourdon 방법** | Coad & Yourdon | 객체 중심 | E-R 다이어그램 사용, 클래스-객체 식별, 객체 간 관계 표현                          |
| **Wirfs-Brock 방법** | Wirfs-Brock | 책임 중심 | 분석과 설계 구분 X, 객체의 책임과 협력 관계에 중점                               |

#### 📝 기출 포맷 예시

- 다음 중 **객체의 책임과 협력에 중점**을 두는 방법론은?
- **유스케이스 기반 분석**에 해당하는 방법론은?
- 객체 모델링 기법(OMT)을 사용하는 분석 기법은?

#### 🧠 용어 설명

- **유스케이스(Use Case)**: 사용자의 요구를 기능 단위로 정의한 시나리오
- **객체 모델링 기법 (OMT)**: 객체, 동작, 기능 모델을 조합하여 분석
- **책임 기반 설계**: 객체가 수행해야 할 책임을 명확히 정의하는 방식

---

## 🔹 156. 럼바우의 분석 기법 (OMT: Object Modeling Technique)

#### 📘 정의
럼바우의 분석 기법은 **객체 모델링 기법(OMT)**으로,  
시스템을 **객체, 동적, 기능** 모델의 세 가지 관점에서 분석하는 접근 방식이다.

#### 🧩 구성 모델

| 모델 | 설명 |
|------|------|
| **객체 모델 (Object Model)** | 클래스, 객체, 속성, 관계 등 **정적 구조 표현** |
| **동적 모델 (Dynamic Model)** | **상태 흐름과 이벤트 기반의 상태 변화**를 표현 |
| **기능 모델 (Functional Model)** | 데이터 흐름도(DFD) 기반으로 **처리 흐름 및 기능** 표현 |

#### 🧩 특징

- **정적 구조(Object Model)** 중심 분석
- **동적 모델(Dynamic Model)**에서는 상태와 전이, 이벤트를 다룸 :contentReference[oaicite:3]{index=3}
- **기능 모델(Functional Model)**은 DFD 기반 기능 흐름 표현 :contentReference[oaicite:4]{index=4}

#### 📝 기출 포맷 예시

- 럼바우 기법의 구성 요소가 아닌 것은?
- **동적 모델**에서 표현하는 것은?
- 럼바우 분석 기법이 다루는 **3가지 모델**은 무엇인가?

#### 🧠 용어 설명

- **객체 모델**: 시스템의 정적 구조 표현
- **동적 모델**: 객체의 상태 변화 및 이벤트 기반 행위 표현
- **기능 모델**: 시스템의 처리 흐름 중심 기능 표현

---

## 🔹 157. 객체지향 설계 원칙 (SOLID 원칙)

#### 📘 정의
객체지향 설계 원칙이란, **유지보수성과 확장성이 높은 소프트웨어 구조를 설계하기 위한 지침**이다.  
SOLID 원칙은 대표적인 5가지 객체지향 설계 원칙의 앞 글자를 따서 명명된 것이다.

#### 🧩 SOLID 원칙 구성

| 원칙 | 원어 | 설명 |
|------|------|------|
| **단일 책임 원칙** | SRP (Single Responsibility Principle) | 클래스는 하나의 책임만 가져야 하며, 변경 사유도 하나여야 한다. |
| **개방-폐쇄 원칙** | OCP (Open-Closed Principle) | 확장에는 열려 있고, 수정에는 닫혀 있어야 한다. (코드 수정 없이 기능 확장) |
| **리스코프 치환 원칙** | LSP (Liskov Substitution Principle) | 하위 클래스는 상위 클래스를 **대체**할 수 있어야 한다. |
| **인터페이스 분리 원칙** | ISP (Interface Segregation Principle) | 사용하지 않는 인터페이스에 의존하지 않도록 **인터페이스는 분리**되어야 한다. |
| **의존 역전 원칙** | DIP (Dependency Inversion Principle) | 상위 모듈이 하위 모듈에 의존하지 않고, **추상화(인터페이스)**에 의존해야 한다. |

#### 📝 기출 포맷 예시

- 다음 중 SOLID 원칙에 해당하지 않는 것은?
- “클래스는 하나의 책임만 가져야 한다”는 원칙은?
- 상위 모듈이 하위 모듈에 의존하지 않도록 하는 원칙은?

#### 🧠 용어 설명

- **책임**: 클래스가 수행해야 할 역할 또는 기능
- **확장/수정**: 기능을 추가하거나 기존 코드를 변경하는 행위
- **대체 가능성**: 하위 클래스가 상위 클래스 역할을 그대로 수행할 수 있음
- **인터페이스 분리**: 클라이언트가 필요하지 않은 기능에 의존하지 않도록 설계
- **의존성 역전**: 구체 구현이 아닌 추상에 의존하는 설계 방식
