## 134. 소프트웨어 아키텍처

- [ ] **소프트웨어 시스템 구성 요소들과 이들 간 관계**를 체계적으로 설계한 **고수준 구조**
- [ ] **목적**: 시스템 구조 명확화, **재사용성/확장성/유지보수성** 확보, **비기능 요구사항** 충족
- [ ] **구성요소**: 컴포넌트(기능 수행 단위) + 커넥터(통신 수단)
- [ ] **주요 스타일**: 계층형/클라이언트-서버/MVC/마이크로서비스(MSA)
- [ ] 전체 시스템 구조, **구성 요소 간 인터페이스 및 상호작용** 방식 포함

---

## 135. 모듈화 (Modularity)

- [ ] **소프트웨어를 독립된 기능 단위(모듈)로 분할**하여 개발하는 설계 원칙
- [ ] **핵심 원리**: **고응집도**(하나의 목적 집중) + **저결합도**(모듈 간 의존성 최소화)
- [ ] **장점**: 개발 생산성 향상, 유지보수 용이성, 재사용성 향상, 이식성 증가
- [ ] 각 모듈은 **하나의 기능만 수행**, 다른 모듈과 **최소한의 연결성** 유지
- [ ] **응집도↑ 결합도↓**가 모듈화의 궁극적 목적

---

## 136. 추상화 (Abstraction)

- [ ] **복잡한 시스템에서 핵심 정보만 표현**하고 **불필요한 세부사항 감추는** 설계 기법
- [ ] **유형**: 자료 추상화(핵심 속성만 공개) + 제어 추상화(제어 흐름 캡슐화) + 과정 추상화(처리 과정 단위화)
- [ ] **효과**: 복잡도 감소, 유지보수성 향상, 재사용성 향상
- [ ] **전체적이고 포괄적인 개념 설계** 후 세분화하여 구체화
- [ ] 단순화된 모델 구성으로 **이해도/재사용성/유지보수성** 향상

---

## 137. 단계적 분해 (Stepwise Refinement)

- [ ] **복잡한 문제를 상위 수준에서 시작해** 점차 **세부 수준으로 나누어** 설계하는 기법
- [ ] **Niklaus Wirth** 제안, **계층적 구조로 설계**
- [ ] **목적**: 복잡도 감소, 구조적 설계 기반, 유지보수성/확장성 향상
- [ ] **vs 추상화**: 단계적 분해(상위→하위 세분화) vs 추상화(세부정보→핵심정보 단순화)
- [ ] 알고리즘, 자료 구조 등은 뒤로 미루어 진행

---

## 138. 정보 은닉 (Information Hiding)

- [ ] **모듈 내부의 세부 구현 내용을 외부에 감추고** **필요한 정보나 기능만 공개**하는 설계 기법
- [ ] **목적**: 모듈 독립성 강화, **결합도(Coupling) 감소**, 유지보수성 향상, 보안성/안정성 강화
- [ ] **구현**: 클래스의 private 변수, **캡슐화(Encapsulation)**, getter/setter 제공
- [ ] **인터페이스를 통해서만 상호작용**하도록 하여 **모듈 간 결합도 낮추고 독립성** 확보
- [ ] 내부 변경이 외부에 영향을 주지 않음, **버그 수정/기능 변경 시 영향 범위 축소**

---

## 139. 협약에 의한 설계 (Design by Contract)

- [ ] **모듈 간 상호작용에서 지켜야 할 규칙을 '계약'으로 명시**하여 설계하는 방식
- [ ] **구성요소**: **선행 조건**(실행 전 참이어야 할 조건) + **결과 조건**(실행 후 만족 조건) + **불변 조건**(항상 유지 조건)
- [ ] **효과**: 모듈 간 책임 분담 명확화, 인터페이스 안정성 향상, 예외 방지
- [ ] 각 모듈은 **계약 조건에 따라 요구사항을 책임**짐
- [ ] **모듈 간 신뢰성과 안정성** 확보

---

## 140. 아키텍처 패턴 (Architecture Pattern)

- [ ] **시스템 설계 시 반복적으로 사용되는 구조적 설계 해결 방식**
- [ ] **주요 패턴**: 계층형(기능 계층 분리) + 클라이언트-서버 + MVC + 마이크로서비스(MSA) + 파이프-필터
- [ ] **장점**: 구조적 일관성, 모듈화/재사용성/유지보수성 향상, 품질 속성 충족
- [ ] **모듈 간 배치, 책임 분담, 데이터 흐름 구조** 정의
- [ ] 효율적인 구조와 품질 확보 가능

---

## 141. 레이어 패턴 (Layered Pattern)

- [ ] **기능별로 시스템을 계층(레이어) 구조로 분리**하여 구성하는 설계 방식
- [ ] **구조**: 프리젠테이션 계층(UI 처리) + 비즈니스 계층(핵심 로직) + 데이터 접근 계층(DB 처리)
- [ ] **특징**: 역할별 책임 분리, **하위 계층의 서비스만 이용**, 모듈화 향상
- [ ] **장점**: 구조 명확, 재사용성 향상, 계층 간 독립성
- [ ] **단점**: 계층이 많으면 **성능 저하**, 복잡도 증가 가능

---

## 142. 클라이언트-서버 패턴 (Client-Server Pattern)

- [ ] **서비스 요청하는 클라이언트**와 **요청 처리하는 서버**를 명확히 분리한 설계
- [ ] **구성**: 클라이언트(UI 제공, 서비스 요청) + 서버(요청 처리, 데이터 관리)
- [ ] **특징**: 역할 분리, **중앙 집중 처리 구조**, 다수 클라이언트 지원
- [ ] **장점**: 처리 분산, 관리 용이, 보안 적용 용이
- [ ] **단점**: 서버 과부하 시 **성능 저하** 발생 가능

---

## 143. 파이프-필터 패턴 (Pipe and Filter Pattern)

- [ ] **데이터 처리 과정을 여러 단계(필터)로 분할**하고 **파이프로 연결**하여 순차 처리
- [ ] **구성**: 필터(입력 데이터 가공하여 출력) + 파이프(필터 간 데이터 전달 통로)
- [ ] **특징**: 단계별 처리 분리, 필터의 독립성, 처리 파이프라인 구성 용이
- [ ] **활용 예시**: UNIX Shell 파이프라인, 멀티미디어 처리, 컴파일러
- [ ] **병렬 처리 가능성** 존재

---

## 144. 모델-뷰-컨트롤러 패턴 (MVC 패턴)

- [ ] **UI와 비즈니스 로직, 데이터 처리를 분리**하여 설계하는 패턴
- [ ] **구성**: 모델(데이터/비즈니스 로직) + 뷰(UI 출력/화면) + 컨트롤러(입력 해석/흐름 제어)
- [ ] **특징**: 역할 분리, 변경 영향 최소화, 유지보수성 향상
- [ ] **흐름**: 사용자 입력 → 컨트롤러 → 모델 → 뷰 화면 출력
- [ ] 컴포넌트 **재사용 가능성 증가**, **테스트 용이성** 향상

---

## 145. 기타 패턴

- [ ] **마이크로서비스 패턴(MSA)**: 작고 독립적인 서비스 단위로 분할, **자율적 배포/개발/운영**
- [ ] **블랙보드 패턴**: 공동 데이터 저장소(블랙보드) + 전문가 모듈, **AI/음성 인식** 활용
- [ ] **브로커 패턴**: 클라이언트-서버 사이 **중간 매개체(브로커)**, **분산 객체 간 통신 중재**
- [ ] **마스터-슬레이브 패턴**: 마스터(전체 제어) + 슬레이브(하위 작업 병렬 수행)
- [ ] **P2P 패턴**: 모든 노드가 **대등한 위치에서 직접 통신**, 중앙 서버 없음
- [ ] **이벤트 버스 패턴**: 이벤트 발생 → 버스 전달 → 구독자 처리, **느슨한 결합**
- [ ] **인터프리터 패턴**: 문법 규칙 해석하여 명령 실행, **DSL/수식 계산기** 활용

---

## 146. 객체지향 (Object-Oriented)

- [ ] **현실 세계를 객체 단위로 모델링**하여 소프트웨어를 구성하는 설계/프로그래밍 방식
- [ ] **구성요소**: 객체(데이터+기능 독립 단위) + 클래스(객체 생성 설계도) + 메시지(객체 간 상호작용)
- [ ] **4대 특성**: 캡슐화(정보 은닉) + 상속(코드 재사용) + 다형성(동일 메시지/다른 동작) + **추상화**(핵심만 표현) ※책에서는 연관성이라고 하지만 일반적으로는 추상화
- [ ] **장점**: 재사용성, 유지보수성, 확장성, 모델링 용이
- [ ] **재사용성/유지보수성/확장성** 높이는 핵심 패러다임

---

## 147. 객체 (Object)

- [ ] **속성(데이터)과 행위(메서드)를 함께 포함**하는 소프트웨어 기본 구성 단위
- [ ] **구성요소**: 속성(객체 상태 데이터) + 메서드(수행 기능) + 식별자(고유 구별값)
- [ ] **특징**: 고유성, 캡슐화, 상호작용(메시지), **동적 생성**(런타임 시 생성)
- [ ] **현실 세계 사물/개념을 프로그래밍적으로 추상화**한 존재
- [ ] **데이터와 이를 처리하는 함수를 묶어 놓은** 소프트웨어 모듈

---

## 148. 클래스 (Class)

- [ ] **객체를 생성하기 위한 설계도 또는 틀**
- [ ] **구성요소**: 속성(데이터 항목) + 메서드(수행 기능) + 생성자(초기화 함수)
- [ ] **특징**: 객체 생성의 틀, 정보은닉/캡슐화 지원, 재사용 가능한 코드 구조
- [ ] **vs 객체**: 클래스(설계도/코드 작성 시) vs 객체(실체/실행 시 생성)
- [ ] **동일한 구조와 동작을 갖는 객체들** 생성에 사용

---

## 149. 메시지 (Message)

- [ ] **객체 간 상호작용을 위해 주고받는 요청 또는 명령**
- [ ] **구성요소**: 수신자(메시지 받는 객체) + 메시지 이름(호출 메서드명) + 인자(전달값)
- [ ] **특징**: 객체 간 상호작용 핵심 수단, **캡슐화된 기능 외부 호출** 방식
- [ ] **다형성 실현**의 전제 조건 (동일 메시지, 다른 동작)
- [ ] **메서드 실행을 요청하는 형태**로 전달

---

## 150. 캡슐화 (Encapsulation)

- [ ] **데이터(속성)와 메서드(기능)를 하나로 묶고** **외부에서 내부 구현 직접 접근 못하게** 숨기는 특성
- [ ] **목적**: 내부 구현 보호, **정보 은닉**, 유지보수 용이, 보안성 향상
- [ ] **구현 방법**: 접근 제어자(private/protected/public) + Getter/Setter + 인터페이스 기반 설계
- [ ] **결합도 감소**, 내부 변경 시 **외부 영향 최소화**
- [ ] 객체지향 4대 특성 중 하나

---

## 151. 상속 (Inheritance)

- [ ] **기존 클래스(부모)의 속성과 메서드**를 **새로운 클래스(자식)가 물려받아** 재사용/확장
- [ ] **특징**: 코드 재사용성 증가, 확장성 향상, 유지보수 용이, **계층적 구조 설계**
- [ ] **관련 용어**: 부모 클래스(상속 제공) + 자식 클래스(상속 받음) + **오버라이딩**(메서드 재정의)
- [ ] **한계**: 다중 상속 미지원(Java), 부모 변경 시 자식에 영향
- [ ] **공통 기능을 상위 클래스**에 정의하고 하위에서 재사용

---

## 152. 다형성 (Polymorphism)

- [ ] **하나의 메시지에 대해 객체마다 서로 다르게 반응**하는 객체지향 특성
- [ ] **종류**: **오버라이딩**(상속받은 메서드 재정의) + **오버로딩**(같은 이름/다른 매개변수)
- [ ] **오버라이딩 vs 오버로딩**: 오버라이딩(상속 관계/런타임 바인딩) vs 오버로딩(동일 클래스/컴파일 타임 바인딩)
- [ ] **장점**: 유연한 설계, 확장성 향상, **메시지 중심 설계** 가능
- [ ] **동일한 메시지 → 다양한 객체 처리**

---

## 153. 연관성 (Association)

- [ ] **두 객체 간 의미 있는 연결 관계**, 객체 간 **논리적 연결 구조**
- [ ] **관계 표현**: `is member of`(연관화) + `is instance of`(분류화) + `is part of`(집단화) + `is a`(일반화)
- [ ] **연관화**: 객체가 집합의 구성원 (`is member of`)
- [ ] **분류화**: 객체가 클래스의 인스턴스 (`is instance of`) - 인스턴스와 클래스 간 관계
- [ ] **집단화**: 전체-부분 관계, 부분은 독립 생존 (`is part of`)
- [ ] **일반화**: 상속 관계 표현 (`is a`)

---

## 154. 객체지향 분석 (OOA)

- [ ] **현실 세계 문제를 객체 모델로 표현**하여 **시스템 요구사항을 분석**하는 기법
- [ ] **특징**: 현실 세계 모델링 적합, 재사용성/확장성 우수, 모델 간 일관성 유지
- [ ] **분석 절차**: 요구사항 분석 → 클래스 도출 → 속성·메서드 정의 → 객체 간 관계 정의 → 객체 모델 작성
- [ ] **객체, 클래스, 속성, 메서드, 관계** 등을 도출
- [ ] **분석 → 설계 → 구현** 모델 간 일관성

---

## 155. 객체지향 분석 방법론

- [ ] **럼바우 방법**: **객체 모델링 기법(OMT)**, 기능/객체/동작 관점, **정적 구조 중심**
- [ ] **부치 방법**: 객체/클래스 관점, **미시적/거시적 개발프로세스**, 객체 행위/상태 강조
- [ ] **야콥슨 방법**: **유스케이스 기반 분석**, **사용자 중심** 관점 강조
- [ ] **Coad와 Yourdon**: E-R 다이어그램 사용, **클래스-객체 식별**
- [ ] **Wirfs-Brock**: **책임 중심**, 분석과 설계 구분 X, **객체의 책임과 협력** 관계 중점

---

## 156. 럼바우 분석 기법 (OMT)

- [ ] **객체 모델링 기법(OMT)**, **객체/동적/기능** 모델의 3가지 관점에서 분석
- [ ] **객체 모델**: 클래스/객체/속성/관계 등 **정적 구조 표현**
- [ ] **동적 모델**: **상태 흐름과 이벤트 기반 상태 변화** 표현
- [ ] **기능 모델**: 데이터 흐름도(DFD) 기반으로 **처리 흐름 및 기능** 표현
- [ ] **정적 구조(객체 모델) 중심** 분석 접근

---

## 157. 객체지향 설계 원칙 (SOLID)

- [ ] **SOLID**: **S**RP(단일 책임) + **O**CP(개방-폐쇄) + **L**SP(리스코프 치환) + **I**SP(인터페이스 분리) + **D**IP(의존 역전)
- [ ] **SRP**: 클래스는 **하나의 책임**만, **변경의 이유가 하나**여야 함
- [ ] **OCP**: **확장에는 열리고 수정에는 닫혀야** 함 (**기존 코드 수정 없이 새 기능 추가**)
- [ ] **LSP**: **하위타입은 상위타입으로 완전 대체** 가능해야 함 (상위 클래스 객체를 하위 클래스 객체로 치환 가능)
- [ ] **ISP**: **클라이언트는 자신이 사용하지 않는 메서드에 의존하면 안됨** (인터페이스 분리)
- [ ] **DIP**: **구체적인 것이 추상적인 것에 의존** (상위 모듈이 하위 모듈 의존하지 않고 추상화에 의존)